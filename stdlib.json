{"items": [{"kind": "class", "name": "decidable", "uparams": [], "params": [{"name": "p", "is_out": 0, "type": "Prop"}]},
{"kind": "class", "name": "has_zero", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_one", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_add", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_mul", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_inv", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_neg", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_sub", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_div", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_dvd", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_mod", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_le", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_lt", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_append", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_andthen", "uparams": ["u","v","w"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "β", "is_out": 0, "type": "Type.{v}"},{"name": "σ", "is_out": 1, "type": "Type.{w}"}]},
{"kind": "class", "name": "has_union", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_inter", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_sdiff", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_equiv", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Sort.{u}"}]},
{"kind": "class", "name": "has_subset", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_ssubset", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_emptyc", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "class", "name": "has_insert", "uparams": ["u","v"], "params": [{"name": "α", "is_out": 1, "type": "Type.{u}"},{"name": "γ", "is_out": 0, "type": "Type.{v}"}]},
{"kind": "class", "name": "has_sep", "uparams": ["u","v"], "params": [{"name": "α", "is_out": 1, "type": "Type.{u}"},{"name": "γ", "is_out": 0, "type": "Type.{v}"}]},
{"kind": "class", "name": "has_mem", "uparams": ["u","v"], "params": [{"name": "α", "is_out": 1, "type": "Type.{u}"},{"name": "γ", "is_out": 0, "type": "Type.{v}"}]},
{"kind": "class", "name": "has_pow", "uparams": ["u","v"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "β", "is_out": 0, "type": "Type.{v}"}]},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_subset", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_subset.{u} α"},
{"kind": "ignored_problem", "class": "has_ssubset", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_ssubset.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_insert", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_insert.{u v} α γ"},
{"kind": "ignored_problem", "class": "has_insert", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_insert.{u v} α γ"},
{"kind": "ignored_problem", "class": "has_emptyc", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_emptyc.{v} γ"},
{"kind": "dep", "name": "nat", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "nat.has_zero", "class": "has_zero", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_zero.{0} nat"},
{"kind": "instance", "name": "nat.has_one", "class": "has_one", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_one.{0} nat"},
{"kind": "instance", "name": "nat.has_add", "class": "has_add", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_add.{0} nat"},
{"kind": "problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_one.{0} nat"},
{"kind": "problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_add.{0} nat"},
{"kind": "class", "name": "has_sizeof", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Sort.{u}"}]},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u} α"},
{"kind": "problem", "class": "has_zero", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_zero.{0} nat"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_sizeof.{v+1} β"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_sizeof.{v+1} β"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_sizeof.{v+1} β"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_sizeof.{v+1} β"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_sizeof.{v+1} β"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_sizeof.{v+1} β"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_sizeof.{v+1} (β a)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "Pi (a : α), (has_sizeof.{v+1} (β a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_sizeof.{v+1} (β a)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "Pi (a : α), (has_sizeof.{v+1} (β a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sizeof.{u+1} (bin_tree.{u} α)"},
{"kind": "dep", "name": "true", "uparams": [], "type": "Prop"},
{"kind": "instance", "name": "decidable.true", "class": "decidable", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "decidable true"},
{"kind": "dep", "name": "false", "uparams": [], "type": "Prop"},
{"kind": "instance", "name": "decidable.false", "class": "decidable", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "decidable false"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable q"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable q"},
{"kind": "dep", "name": "and", "uparams": [], "type": "Prop → Prop → Prop"},
{"kind": "instance", "name": "and.decidable", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"},{"name": "q", "type": "Prop"},{"name": "_inst_1", "class": "decidable", "type": "decidable p"},{"name": "_inst_2", "class": "decidable", "type": "decidable q"}], "coercion_like": 0, "type": "decidable (and p q)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable q"},
{"kind": "dep", "name": "or", "uparams": [], "type": "Prop → Prop → Prop"},
{"kind": "instance", "name": "or.decidable", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"},{"name": "q", "type": "Prop"},{"name": "_inst_1", "class": "decidable", "type": "decidable p"},{"name": "_inst_2", "class": "decidable", "type": "decidable q"}], "coercion_like": 0, "type": "decidable (or p q)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "dep", "name": "not", "uparams": [], "type": "Prop → Prop"},
{"kind": "instance", "name": "not.decidable", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"},{"name": "_inst_1", "class": "decidable", "type": "decidable p"}], "coercion_like": 0, "type": "decidable (not p)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable q"},
{"kind": "instance", "name": "implies.decidable", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"},{"name": "q", "type": "Prop"},{"name": "_inst_1", "class": "decidable", "type": "decidable p"},{"name": "_inst_2", "class": "decidable", "type": "decidable q"}], "coercion_like": 0, "type": "decidable (p → q)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable q"},
{"kind": "dep", "name": "iff", "uparams": [], "type": "Prop → Prop → Prop"},
{"kind": "instance", "name": "iff.decidable", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"},{"name": "q", "type": "Prop"},{"name": "_inst_1", "class": "decidable", "type": "decidable p"},{"name": "_inst_2", "class": "decidable", "type": "decidable q"}], "coercion_like": 0, "type": "decidable (iff p q)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable q"},
{"kind": "dep", "name": "xor", "uparams": [], "type": "Prop → Prop → Prop"},
{"kind": "instance", "name": "xor.decidable", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"},{"name": "q", "type": "Prop"},{"name": "_inst_1", "class": "decidable", "type": "decidable p"},{"name": "_inst_2", "class": "decidable", "type": "decidable q"}], "coercion_like": 0, "type": "decidable (xor p q)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable p"},
{"kind": "dep", "name": "Exists", "uparams": ["u"], "type": "Π (α : Sort u), (α → Prop) → Prop"},
{"kind": "instance", "name": "exists_prop_decidable", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"},{"name": "P", "type": "p → Prop"},{"name": "Dp", "class": "decidable", "type": "decidable p"},{"name": "DP", "class": "decidable", "type": "Π (h : p), decidable (P h)"}], "coercion_like": 0, "type": "decidable (@Exists.{0} p P)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable p"},
{"kind": "instance", "name": "forall_prop_decidable", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"},{"name": "P", "type": "p → Prop"},{"name": "Dp", "class": "decidable", "type": "decidable p"},{"name": "DP", "class": "decidable", "type": "Π (h : p), decidable (P h)"}], "coercion_like": 0, "type": "decidable (∀ (h : p), P h)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable (eq.{u} α a b)"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 10, "uparams": [], "type": "decidable false"},
{"kind": "dep", "name": "eq", "uparams": ["u"], "type": "Π (α : Sort u), α → α → Prop"},
{"kind": "instance", "name": "ne.decidable", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Sort u"},{"name": "_inst_1", "class": "decidable", "type": "Π (a b : α), decidable (@eq.{u} α a b)"},{"name": "a", "type": "α"},{"name": "b", "type": "α"}], "coercion_like": 0, "type": "decidable (not (@eq.{u} α a b))"},
{"kind": "dep", "name": "bool", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "bool.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "bool"},{"name": "b", "type": "bool"}], "coercion_like": 0, "type": "decidable (@eq.{1} bool a b)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (eq.{1} bool (p x y) bool.tt)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u} α"},
{"kind": "class", "name": "inhabited", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Sort.{u}"}]},
{"kind": "ignored_problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "inhabited.{u} α"},
{"kind": "ignored_problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "inhabited.{u} α"},
{"kind": "instance", "name": "prop.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} Prop"},
{"kind": "instance", "name": "fun.inhabited", "class": "inhabited", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Sort u"},{"name": "β", "type": "Sort v"},{"name": "h", "class": "inhabited", "type": "inhabited.{v} β"}], "coercion_like": 0, "type": "inhabited.{(imax u v)} (α → β)"},
{"kind": "ignored_problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "inhabited.{v} (β a)"},
{"kind": "instance", "name": "pi.inhabited", "class": "inhabited", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Sort u"},{"name": "β", "type": "α → Sort v"},{"name": "_inst_1", "class": "inhabited", "type": "Π (x : α), inhabited.{v} (β x)"}], "coercion_like": 0, "type": "inhabited.{(imax u v)} (Π (x : α), β x)"},
{"kind": "instance", "name": "bool.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} bool"},
{"kind": "instance", "name": "true.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{0} true"},
{"kind": "class", "name": "nonempty", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Sort.{u}"}]},
{"kind": "ignored_problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "inhabited.{u} α"},
{"kind": "instance", "name": "nonempty_of_inhabited", "class": "nonempty", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Sort u"},{"name": "_inst_1", "class": "inhabited", "type": "inhabited.{u} α"}], "coercion_like": 1, "type": "nonempty.{u} α"},
{"kind": "class", "name": "subsingleton", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Sort.{u}"}]},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "subsingleton.{u} α"},
{"kind": "instance", "name": "subsingleton_prop", "class": "subsingleton", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"}], "coercion_like": 0, "type": "subsingleton.{0} p"},
{"kind": "instance", "name": "decidable.subsingleton", "class": "subsingleton", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"}], "coercion_like": 0, "type": "subsingleton.{1} (decidable p)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable b"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable b"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable b"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable b"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable true"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable b"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable b"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable b"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable b"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 3, "uparams": [], "type": "decidable c"},
{"kind": "dep", "name": "ite", "uparams": ["u"], "type": "Π (c : Prop), decidable c → Π (α : Sort u), α → α → α"},
{"kind": "instance", "name": "ite.decidable", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "c", "type": "Prop"},{"name": "t", "type": "Prop"},{"name": "e", "type": "Prop"},{"name": "d_c", "class": "decidable", "type": "decidable c"},{"name": "d_t", "class": "decidable", "type": "decidable t"},{"name": "d_e", "class": "decidable", "type": "decidable e"}], "coercion_like": 0, "type": "decidable (@ite.{1} c d_c Prop t e)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 3, "uparams": [], "type": "decidable c"},
{"kind": "dep", "name": "dite", "uparams": ["u"], "type": "Π (c : Prop), decidable c → Π (α : Sort u), (c → α) → (not c → α) → α"},
{"kind": "instance", "name": "dite.decidable", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "c", "type": "Prop"},{"name": "t", "type": "c → Prop"},{"name": "e", "type": "not c → Prop"},{"name": "d_c", "class": "decidable", "type": "decidable c"},{"name": "d_t", "class": "decidable", "type": "Π (h : c), decidable (t h)"},{"name": "d_e", "class": "decidable", "type": "Π (h : not c), decidable (e h)"}], "coercion_like": 0, "type": "decidable (@dite.{1} c d_c Prop t e)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["s"], "type": "has_sizeof.{s+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u} α"},
{"kind": "ignored_problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "inhabited.{u+1} α"},
{"kind": "dep", "name": "punit", "uparams": ["u"], "type": "Sort u"},
{"kind": "instance", "name": "punit.subsingleton", "class": "subsingleton", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "subsingleton.{u_1} punit.{u_1}"},
{"kind": "ignored_problem", "class": "inhabited", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "inhabited.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 17, "uparams": ["u"], "type": "has_sizeof.{(max u 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "inhabited.{v+1} β"},
{"kind": "dep", "name": "sum", "uparams": ["u","v"], "type": "Type u → Type v → Type (max u v)"},
{"kind": "instance", "name": "sum.inhabited_left", "class": "inhabited", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "h", "class": "inhabited", "type": "inhabited.{u+1} α"}], "coercion_like": 0, "type": "inhabited.{(max (u+1) (v+1))} (sum.{u v} α β)"},
{"kind": "instance", "name": "punit.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} punit.{1}"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 17, "uparams": ["u"], "type": "has_sizeof.{0} (equivalence.{u} α r)"},
{"kind": "ignored_problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "inhabited.{v+1} β"},
{"kind": "instance", "name": "nat.has_le", "class": "has_le", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_le.{0} nat"},
{"kind": "dep", "name": "prod", "uparams": ["u","v"], "type": "Type u → Type v → Type (max u v)"},
{"kind": "instance", "name": "prod.inhabited", "class": "inhabited", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "_inst_1", "class": "inhabited", "type": "inhabited.{u+1} α"},{"name": "_inst_2", "class": "inhabited", "type": "inhabited.{v+1} β"}], "coercion_like": 0, "type": "inhabited.{(max (u+1) (v+1))} (prod.{u v} α β)"},
{"kind": "instance", "name": "punit.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": ["u_1"], "params": [{"name": "a", "type": "punit.{u_1}"},{"name": "b", "type": "punit.{u_1}"}], "coercion_like": 0, "type": "decidable (@eq.{u_1} punit.{u_1} a b)"},
{"kind": "instance", "name": "sum.inhabited_right", "class": "inhabited", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "h", "class": "inhabited", "type": "inhabited.{v+1} β"}], "coercion_like": 0, "type": "inhabited.{(max (u+1) (v+1))} (sum.{u v} α β)"},
{"kind": "instance", "name": "nat.has_lt", "class": "has_lt", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_lt.{0} nat"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 18, "uparams": ["u"], "type": "has_sizeof.{0} (equivalence.{u} α r)"},
{"kind": "class", "name": "setoid", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Sort.{u}"}]},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "instance", "name": "setoid_has_equiv", "class": "has_equiv", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Sort u"},{"name": "_inst_1", "class": "setoid", "type": "setoid.{u} α"}], "coercion_like": 1, "type": "has_equiv.{u} α"},
{"kind": "dep", "name": "subtype", "uparams": ["u"], "type": "Π (α : Sort u), (α → Prop) → Sort (max 1 u)"},
{"kind": "instance", "name": "subtype.inhabited", "class": "inhabited", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "p", "type": "α → Prop"},{"name": "a", "type": "α"},{"name": "h", "type": "p a"}], "coercion_like": 0, "type": "inhabited.{(max 1 (u+1))} (@subtype.{u+1} α p)"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_equiv.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_equiv.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_equiv.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "instance", "name": "nat.has_sub", "class": "has_sub", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_sub.{0} nat"},
{"kind": "instance", "name": "nat.has_mul", "class": "has_mul", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_mul.{0} nat"},
{"kind": "instance", "name": "prod.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "h₁", "class": "decidable", "type": "Π (a b : α), decidable (@eq.{u+1} α a b)"},{"name": "h₂", "class": "decidable", "type": "Π (a b : β), decidable (@eq.{v+1} β a b)"},{"name": "a", "type": "prod.{u v} α β"},{"name": "b", "type": "prod.{u v} α β"}], "coercion_like": 0, "type": "decidable (@eq.{(max (u+1) (v+1))} (prod.{u v} α β) a b)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_lt.{v} β"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "instance", "name": "prod.has_lt", "class": "has_lt", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "_inst_1", "class": "has_lt", "type": "has_lt.{u} α"},{"name": "_inst_2", "class": "has_lt", "type": "has_lt.{v} β"}], "coercion_like": 0, "type": "has_lt.{(max u v)} (prod.{u v} α β)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_lt.{v} β"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 6, "uparams": ["u","v"], "type": "has_lt.{(max u v)} (prod.{u v} α β)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": ["u","v"], "type": "decidable (has_lt.lt.{u} α _inst_1 (prod.fst.{u v} α β t) (prod.fst.{u v} α β s))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 22, "uparams": ["u","v"], "type": "decidable (and (eq.{u+1} α (prod.fst.{u v} α β t) (prod.fst.{u v} α β s)) (has_lt.lt.{v} β _inst_2 (prod.snd.{u v} α β t) (prod.snd.{u v} α β s)))"},
{"kind": "instance", "name": "nat.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "nat"},{"name": "b", "type": "nat"}], "coercion_like": 0, "type": "decidable (@eq.{1} nat a b)"},
{"kind": "dep", "name": "has_lt.lt", "uparams": ["u"], "type": "Π (α : Type u), has_lt.{u} α → α → α → Prop"},
{"kind": "instance", "name": "prod_has_decidable_lt", "class": "decidable", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "_inst_1", "class": "has_lt", "type": "has_lt.{u} α"},{"name": "_inst_2", "class": "has_lt", "type": "has_lt.{v} β"},{"name": "_inst_3", "class": "decidable", "type": "Π (a b : α), decidable (@eq.{u+1} α a b)"},{"name": "_inst_4", "class": "decidable", "type": "Π (a b : β), decidable (@eq.{v+1} β a b)"},{"name": "_inst_5", "class": "decidable", "type": "Π (a b : α), decidable (@has_lt.lt.{u} α _inst_1 a b)"},{"name": "_inst_6", "class": "decidable", "type": "Π (a b : β), decidable (@has_lt.lt.{v} β _inst_2 a b)"},{"name": "s", "type": "prod.{u v} α β"},{"name": "t", "type": "prod.{u v} α β"}], "coercion_like": 0, "type": "decidable (@has_lt.lt.{(max u v)} (prod.{u v} α β) (@prod.has_lt.{u v} α β _inst_1 _inst_2) s t)"},
{"kind": "instance", "name": "nat.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} nat"},
{"kind": "problem", "class": "has_le", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_le.{0} nat"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_lt.{v} β"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 6, "uparams": ["u","v"], "type": "has_lt.{(max u v)} (prod.{u v} α β)"},
{"kind": "problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} nat"},
{"kind": "dep", "name": "has_le.le", "uparams": ["u"], "type": "Π (α : Type u), has_le.{u} α → α → α → Prop"},
{"kind": "instance", "name": "nat.decidable_le", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "nat"},{"name": "b", "type": "nat"}], "coercion_like": 0, "type": "decidable (@has_le.le.{0} nat nat.has_le a b)"},
{"kind": "instance", "name": "nat.decidable_lt", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "nat"},{"name": "b", "type": "nat"}], "coercion_like": 0, "type": "decidable (@has_lt.lt.{0} nat nat.has_lt a b)"},
{"kind": "problem", "class": "has_sub", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_sub.{0} nat"},
{"kind": "problem", "class": "has_mul", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_mul.{0} nat"},
{"kind": "instance", "name": "nat.has_pow", "class": "has_pow", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_pow.{0 0} nat nat"},
{"kind": "problem", "class": "has_pow", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_pow.{0 0} nat nat"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 15, "uparams": [], "type": "has_sizeof.{1} nat"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 16, "uparams": [], "type": "has_sizeof.{0} (has_lt.lt.{0} nat nat.has_lt val n)"},
{"kind": "dep", "name": "list", "uparams": ["u"], "type": "Type u → Type u"},
{"kind": "instance", "name": "list.inhabited", "class": "inhabited", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "inhabited.{u+1} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 17, "uparams": [], "type": "has_sizeof.{0} (has_lt.lt.{0} nat nat.has_lt val n)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 16, "uparams": [], "type": "has_sizeof.{0} (or (has_lt.lt.{0} nat nat.has_lt val (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) val) (has_lt.lt.{0} nat nat.has_lt val (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))))))))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 17, "uparams": [], "type": "has_sizeof.{0} (or (has_lt.lt.{0} nat nat.has_lt val (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) val) (has_lt.lt.{0} nat nat.has_lt val (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))))))))))"},
{"kind": "dep", "name": "fin", "uparams": [], "type": "nat → Type"},
{"kind": "instance", "name": "fin.has_lt", "class": "has_lt", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"}], "coercion_like": 0, "type": "has_lt.{0} (fin n)"},
{"kind": "instance", "name": "fin.has_le", "class": "has_le", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"}], "coercion_like": 0, "type": "has_le.{0} (fin n)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 17, "uparams": ["u"], "type": "has_sizeof.{(max u 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} (fin n)"},
{"kind": "dep", "name": "char", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "char.has_lt", "class": "has_lt", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_lt.{0} char"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 17, "uparams": ["u"], "type": "has_sizeof.{0} (well_founded.{u} α r)"},
{"kind": "instance", "name": "char.has_le", "class": "has_le", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_le.{0} char"},
{"kind": "instance", "name": "fin.decidable_lt", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"},{"name": "a", "type": "fin n"},{"name": "b", "type": "fin n"}], "coercion_like": 0, "type": "decidable (@has_lt.lt.{0} (fin n) (@fin.has_lt n) a b)"},
{"kind": "problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} char"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_le.{0} (fin n)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 18, "uparams": ["u"], "type": "has_sizeof.{0} (well_founded.{u} α r)"},
{"kind": "instance", "name": "char.decidable_lt", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "char"},{"name": "b", "type": "char"}], "coercion_like": 0, "type": "decidable (@has_lt.lt.{0} char char.has_lt a b)"},
{"kind": "problem", "class": "has_le", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_le.{0} char"},
{"kind": "instance", "name": "fin.decidable_le", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"},{"name": "a", "type": "fin n"},{"name": "b", "type": "fin n"}], "coercion_like": 0, "type": "decidable (@has_le.le.{0} (fin n) (@fin.has_le n) a b)"},
{"kind": "instance", "name": "char.decidable_le", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "char"},{"name": "b", "type": "char"}], "coercion_like": 0, "type": "decidable (@has_le.le.{0} char char.has_le a b)"},
{"kind": "class", "name": "has_well_founded", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Sort.{u}"}]},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 42, "uparams": [], "type": "decidable (or (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) n) (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))))))))))"},
{"kind": "instance", "name": "fin.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"},{"name": "a", "type": "fin n"},{"name": "b", "type": "fin n"}], "coercion_like": 0, "type": "decidable (@eq.{1} (fin n) a b)"},
{"kind": "instance", "name": "char.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "char"},{"name": "b", "type": "char"}], "coercion_like": 0, "type": "decidable (@eq.{1} char a b)"},
{"kind": "instance", "name": "char.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} char"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 4, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt n unsigned_sz)"},
{"kind": "dep", "name": "unsigned", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "unsigned.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "unsigned"},{"name": "b", "type": "unsigned"}], "coercion_like": 0, "type": "decidable (@eq.{1} unsigned a b)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (a : α) (b : α), (decidable (eq.{u+1} α a b))"},
{"kind": "instance", "name": "list.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "decidable", "type": "Π (a b : α), decidable (@eq.{u+1} α a b)"},{"name": "a", "type": "list.{u} α"},{"name": "b", "type": "list.{u} α"}], "coercion_like": 0, "type": "decidable (@eq.{u+1} (list.{u} α) a b)"},
{"kind": "instance", "name": "list.has_append", "class": "has_append", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_append.{u} (list.{u} α)"},
{"kind": "instance", "name": "list.has_mem", "class": "has_mem", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable (eq.{u+1} α a b)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u} α"},
{"kind": "instance", "name": "has_well_founded_of_has_sizeof", "class": "has_well_founded", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Sort u"},{"name": "_inst_1", "class": "has_sizeof", "type": "has_sizeof.{u} α"}], "coercion_like": 1, "type": "has_well_founded.{u} α"},
{"kind": "dep", "name": "has_mem.mem", "uparams": ["u","v"], "type": "Π (α : Type u) (γ : Type v), has_mem.{u v} α γ → α → γ → Prop"},
{"kind": "instance", "name": "list.decidable_mem", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "decidable", "type": "Π (a b : α), decidable (@eq.{u+1} α a b)"},{"name": "a", "type": "α"},{"name": "l", "type": "list.{u} α"}], "coercion_like": 0, "type": "decidable (@has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) a l)"},
{"kind": "instance", "name": "list.has_emptyc", "class": "has_emptyc", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_emptyc.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u_1"], "type": "decidable (eq.{u_1+1} α a b)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u_1"], "type": "Pi (a : α) (b : α), (decidable (eq.{u_1+1} α a b))"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u_1"], "type": "has_mem.{u_1 u_1} α (list.{u_1} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 3, "uparams": ["u_1"], "type": "decidable (has_mem.mem.{u_1 u_1} α (list.{u_1} α) (list.has_mem.{u_1} α) a l₂)"},
{"kind": "instance", "name": "prod.has_well_founded", "class": "has_well_founded", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "s₁", "class": "has_well_founded", "type": "has_well_founded.{u+1} α"},{"name": "s₂", "class": "has_well_founded", "type": "has_well_founded.{v+1} β"}], "coercion_like": 0, "type": "has_well_founded.{(max (u+1) (v+1))} (prod.{u v} α β)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u_1"], "type": "Pi (a : α) (b : α), (decidable (eq.{u_1+1} α a b))"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u_1"], "type": "has_mem.{u_1 u_1} α (list.{u_1} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 3, "uparams": ["u_1"], "type": "decidable (has_mem.mem.{u_1 u_1} α (list.{u_1} α) (list.has_mem.{u_1} α) a l₁)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 24, "uparams": [], "type": "decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) y) (has_le.le.{0} nat nat.has_le y x))"},
{"kind": "instance", "name": "nat.has_div", "class": "has_div", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_div.{0} nat"},
{"kind": "problem", "class": "has_div", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_div.{0} nat"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 24, "uparams": [], "type": "decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) y) (has_le.le.{0} nat nat.has_le y x))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 24, "uparams": [], "type": "decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) y) (has_le.le.{0} nat nat.has_le y x))"},
{"kind": "instance", "name": "nat.has_mod", "class": "has_mod", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_mod.{0} nat"},
{"kind": "problem", "class": "has_mod", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_mod.{0} nat"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 24, "uparams": [], "type": "decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) y) (has_le.le.{0} nat nat.has_le y x))"},
{"kind": "ignored_problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "inhabited.{u+1} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "subsingleton.{v} (β (quot.mk.{u} α r b))"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_equiv.{u} α"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_equiv.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_equiv.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_equiv.{u} α"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_equiv.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_equiv.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p a)"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u_b"], "type": "has_equiv.{u_b} β"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 3, "uparams": ["u_a"], "type": "has_equiv.{u_a} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 2, "uparams": ["u_a"], "type": "setoid.{u_a} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u_b"], "type": "setoid.{u_b} β"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p a)"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u_b"], "type": "has_equiv.{u_b} β"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 3, "uparams": ["u_a"], "type": "has_equiv.{u_a} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 2, "uparams": ["u_a"], "type": "setoid.{u_a} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u_b"], "type": "setoid.{u_b} β"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 2, "uparams": ["u_a"], "type": "setoid.{u_a} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u_b"], "type": "setoid.{u_b} β"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 2, "uparams": ["u_a"], "type": "setoid.{u_a} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u_b"], "type": "setoid.{u_b} β"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 3, "uparams": ["u_a"], "type": "setoid.{u_a} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 2, "uparams": ["u_b"], "type": "setoid.{u_b} β"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u_c"], "type": "setoid.{u_c} φ"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p a)"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_equiv.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p a)"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_equiv.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 2, "uparams": ["u_a"], "type": "setoid.{u_a} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u_b"], "type": "setoid.{u_b} β"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 1, "uparams": ["u_a","u_c","u_b"], "type": "Pi (a_1 : β), (subsingleton.{u_c} (φ (quotient.mk.{u_a} α s₁ a) (quotient.mk.{u_b} β s₂ a_1)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (a_1 : α), (decidable (eq.{u+1} α a a_1))"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 19, "uparams": ["u"], "type": "Pi (a : α), (decidable (not (has_mem.mem.{u u} α (list.{u} α) (list.has_mem.{u} α) a ys)))"},
{"kind": "ignored_problem", "class": "has_equiv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_equiv.{u} α"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "setoid.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (a : α) (b : α), (subsingleton.{1} (decidable (eq.{u} (quotient.{u} α s) (quotient.mk.{u} α s a) (quotient.mk.{u} α s b))))"},
{"kind": "dep", "name": "has_equiv.equiv", "uparams": ["u"], "type": "Π (α : Sort u), has_equiv.{u} α → α → α → Prop"},
{"kind": "dep", "name": "quotient", "uparams": ["u"], "type": "Π (α : Sort u), setoid.{u} α → Sort u"},
{"kind": "instance", "name": "quotient.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Sort u"},{"name": "s", "type": "setoid.{u} α"},{"name": "d", "class": "decidable", "type": "Π (a b : α), decidable (@has_equiv.equiv.{u} α (@setoid_has_equiv.{u} α s) a b)"},{"name": "a", "type": "@quotient.{u} α s"},{"name": "b", "type": "@quotient.{u} α s"}], "coercion_like": 0, "type": "decidable (@eq.{u} (@quotient.{u} α s) a b)"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "setoid.{(imax u v)} (Pi (x : α), (β x))"},
{"kind": "ignored_problem", "class": "setoid", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "setoid.{(imax u v)} (Pi (x : α), (β x))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "subsingleton.{v} (β a)"},
{"kind": "instance", "name": "pi.subsingleton", "class": "subsingleton", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Sort u"},{"name": "β", "type": "α → Sort v"},{"name": "_inst_1", "class": "subsingleton", "type": "∀ (a : α), subsingleton.{v} (β a)"}], "coercion_like": 0, "type": "subsingleton.{(imax u v)} (Π (a : α), β a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable (Exists.{u} α p)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "decidable (has_mem.mem.{u u} α (list.{u} α) (list.has_mem.{u} α) a l)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (a : α) (b : α), (decidable (eq.{u+1} α a b))"},
{"kind": "instance", "name": "list.has_insert", "class": "has_insert", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "decidable", "type": "Π (a b : α), decidable (@eq.{u+1} α a b)"}], "coercion_like": 0, "type": "has_insert.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_insert", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_insert.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (a : α) (b : α), (decidable (eq.{u+1} α a b))"},
{"kind": "instance", "name": "list.has_union", "class": "has_union", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "decidable", "type": "Π (a b : α), decidable (@eq.{u+1} α a b)"}], "coercion_like": 0, "type": "has_union.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "Pi (a : α), (decidable (has_mem.mem.{u u} α (list.{u} α) (list.has_mem.{u} α) a l₂))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (a : α) (b : α), (decidable (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "instance", "name": "list.has_inter", "class": "has_inter", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "decidable", "type": "Π (a b : α), decidable (@eq.{u+1} α a b)"}], "coercion_like": 0, "type": "has_inter.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "inhabited.{u+1} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "instance", "name": "list.has_lt", "class": "has_lt", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_lt", "type": "has_lt.{u} α"}], "coercion_like": 0, "type": "has_lt.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_lt.{u} (list.{u} α)"},
{"kind": "instance", "name": "list.has_decidable_lt", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_lt", "type": "has_lt.{u} α"},{"name": "h", "class": "decidable", "type": "Π (a b : α), decidable (@has_lt.lt.{u} α _inst_1 a b)"},{"name": "l₁", "type": "list.{u} α"},{"name": "l₂", "type": "list.{u} α"}], "coercion_like": 0, "type": "decidable (@has_lt.lt.{u} (list.{u} α) (@list.has_lt.{u} α _inst_1) l₁ l₂)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_lt.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "instance", "name": "list.has_le", "class": "has_le", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_lt", "type": "has_lt.{u} α"}], "coercion_like": 0, "type": "has_le.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_le.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "decidable (has_lt.lt.{u} (list.{u} α) (list.has_lt.{u} α _inst_1) b a)"},
{"kind": "instance", "name": "list.has_decidable_le", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_lt", "type": "has_lt.{u} α"},{"name": "h", "class": "decidable", "type": "Π (a b : α), decidable (@has_lt.lt.{u} α _inst_1 a b)"},{"name": "l₁", "type": "list.{u} α"},{"name": "l₂", "type": "list.{u} α"}], "coercion_like": 0, "type": "decidable (@has_le.le.{u} (list.{u} α) (@list.has_le.{u} α _inst_1) l₁ l₂)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_lt.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_le.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_le.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_lt.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable (eq.{u+1} α a b)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 5, "uparams": ["u"], "type": "decidable (has_lt.lt.{u} (list.{u} α) (list.has_lt.{u} α _inst_1) l₁ l₂)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (a : α) (b : α), (decidable (eq.{u+1} α a b))"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 1, "steps": 9, "uparams": [], "type": "has_sizeof.{1} (list.{0} char)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 18, "uparams": ["u","v"], "type": "has_sizeof.{(imax u v)} (a -> b)"},
{"kind": "problem", "class": "has_lt", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_lt.{0} (list.{0} char)"},
{"kind": "class", "name": "has_lift", "uparams": ["u","v"], "params": [{"name": "a", "is_out": 0, "type": "Sort.{u}"},{"name": "b", "is_out": 0, "type": "Sort.{v}"}]},
{"kind": "dep", "name": "string", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "string.has_lt", "class": "has_lt", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_lt.{0} string"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 19, "uparams": ["u","v"], "type": "has_sizeof.{(imax u v)} (a -> b)"},
{"kind": "problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} string"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 3, "uparams": [], "type": "Pi (a : char) (b : char), (decidable (has_lt.lt.{0} char char.has_lt a b))"},
{"kind": "instance", "name": "string.has_decidable_lt", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "s₁", "type": "string"},{"name": "s₂", "type": "string"}], "coercion_like": 0, "type": "decidable (@has_lt.lt.{0} string string.has_lt s₁ s₂)"},
{"kind": "class", "name": "has_lift_t", "uparams": ["u","v"], "params": [{"name": "a", "is_out": 0, "type": "Sort.{u}"},{"name": "b", "is_out": 0, "type": "Sort.{v}"}]},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 20, "uparams": ["u","v"], "type": "has_sizeof.{(imax u v)} (a -> b)"},
{"kind": "problem", "class": "has_append", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_append.{0} (list.{0} char)"},
{"kind": "class", "name": "has_coe", "uparams": ["u","v"], "params": [{"name": "a", "is_out": 0, "type": "Sort.{u}"},{"name": "b", "is_out": 0, "type": "Sort.{v}"}]},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 21, "uparams": ["u","v"], "type": "has_sizeof.{(imax u v)} (a -> b)"},
{"kind": "class", "name": "has_coe_t", "uparams": ["u","v"], "params": [{"name": "a", "is_out": 0, "type": "Sort.{u}"},{"name": "b", "is_out": 0, "type": "Sort.{v}"}]},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 21, "uparams": ["u","v"], "type": "has_sizeof.{(max u (v+1))} (a -> Sort.{v})"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 21, "uparams": ["u","v"], "type": "has_sizeof.{(imax u v)} (Pi (x : a), (F x))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 22, "uparams": ["u","v"], "type": "has_sizeof.{(imax u v)} (Pi (x : a), (F x))"},
{"kind": "problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": [], "type": "inhabited.{1} char"},
{"kind": "class", "name": "has_coe_to_fun", "uparams": ["u","v"], "params": [{"name": "a", "is_out": 0, "type": "Sort.{u}"}]},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 22, "uparams": ["v"], "type": "has_sizeof.{v+1} Sort.{v}"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 22, "uparams": ["u","v"], "type": "has_sizeof.{(imax u v)} (a -> S)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 23, "uparams": ["u","v"], "type": "has_sizeof.{(imax u v)} (a -> S)"},
{"kind": "class", "name": "has_coe_to_sort", "uparams": ["u","v"], "params": [{"name": "a", "is_out": 0, "type": "Sort.{u}"}]},
{"kind": "ignored_problem", "class": "has_lift", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_lift.{u v} a b"},
{"kind": "ignored_problem", "class": "has_lift_t", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_lift_t.{u v} a b"},
{"kind": "ignored_problem", "class": "has_coe", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_coe.{u v} a b"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_coe_t.{u v} a b"},
{"kind": "ignored_problem", "class": "has_coe_to_fun", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_coe_to_fun.{u v} a"},
{"kind": "ignored_problem", "class": "has_lift_t", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_lift_t.{u v} a b"},
{"kind": "ignored_problem", "class": "has_coe_to_fun", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_coe_to_fun.{u v} a"},
{"kind": "ignored_problem", "class": "has_coe_to_sort", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_coe_to_sort.{u v} a"},
{"kind": "ignored_problem", "class": "has_lift", "max_depth": 0, "steps": 1, "uparams": ["u₁","u₂"], "type": "has_lift.{u₁ u₂} a b"},
{"kind": "ignored_problem", "class": "has_lift_t", "max_depth": 0, "steps": 1, "uparams": ["u₂","u₃"], "type": "has_lift_t.{u₂ u₃} b c"},
{"kind": "instance", "name": "lift_trans", "class": "has_lift_t", "from_extends": 0, "uparams": ["u₁","u₂","u₃"], "params": [{"name": "a", "type": "Sort u₁"},{"name": "b", "type": "Sort u₂"},{"name": "c", "type": "Sort u₃"},{"name": "_inst_1", "class": "has_lift", "type": "has_lift.{u₁ u₂} a b"},{"name": "_inst_2", "class": "has_lift_t", "type": "has_lift_t.{u₂ u₃} b c"}], "coercion_like": 0, "type": "has_lift_t.{u₁ u₃} a c"},
{"kind": "ignored_problem", "class": "has_lift", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_lift.{u v} a b"},
{"kind": "instance", "name": "lift_base", "class": "has_lift_t", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "a", "type": "Sort u"},{"name": "b", "type": "Sort v"},{"name": "_inst_1", "class": "has_lift", "type": "has_lift.{u v} a b"}], "coercion_like": 1, "type": "has_lift_t.{u v} a b"},
{"kind": "ignored_problem", "class": "has_coe", "max_depth": 0, "steps": 1, "uparams": ["u₁","u₂"], "type": "has_coe.{u₁ u₂} a b"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 0, "steps": 1, "uparams": ["u₂","u₃"], "type": "has_coe_t.{u₂ u₃} b c"},
{"kind": "instance", "name": "coe_trans", "class": "has_coe_t", "from_extends": 0, "uparams": ["u₁","u₂","u₃"], "params": [{"name": "a", "type": "Sort u₁"},{"name": "b", "type": "Sort u₂"},{"name": "c", "type": "Sort u₃"},{"name": "_inst_1", "class": "has_coe", "type": "has_coe.{u₁ u₂} a b"},{"name": "_inst_2", "class": "has_coe_t", "type": "has_coe_t.{u₂ u₃} b c"}], "coercion_like": 0, "type": "has_coe_t.{u₁ u₃} a c"},
{"kind": "ignored_problem", "class": "has_coe", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_coe.{u v} a b"},
{"kind": "instance", "name": "coe_base", "class": "has_coe_t", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "a", "type": "Sort u"},{"name": "b", "type": "Sort v"},{"name": "_inst_1", "class": "has_coe", "type": "has_coe.{u v} a b"}], "coercion_like": 1, "type": "has_coe_t.{u v} a b"},
{"kind": "dep", "name": "option", "uparams": ["u"], "type": "Type u → Type u"},
{"kind": "instance", "name": "coe_option", "class": "has_coe_t", "from_extends": 0, "uparams": ["u"], "params": [{"name": "a", "type": "Type u"}], "coercion_like": 0, "type": "has_coe_t.{u+1 u+1} a (option.{u} a)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 24, "uparams": ["u","v"], "type": "has_sizeof.{(imax u v)} (a -> b)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 10, "uparams": [], "type": "decidable (eq.{1} (list.{0} char) cs₁ cs₂)"},
{"kind": "class", "name": "has_coe_t_aux", "uparams": ["u","v"], "params": [{"name": "a", "is_out": 0, "type": "Sort.{u}"},{"name": "b", "is_out": 0, "type": "Sort.{v}"}]},
{"kind": "ignored_problem", "class": "has_coe_t_aux", "max_depth": 0, "steps": 1, "uparams": ["u₂","u₃"], "type": "has_coe_t_aux.{u₂ u₃} b c"},
{"kind": "ignored_problem", "class": "has_coe", "max_depth": 0, "steps": 1, "uparams": ["u₁","u₂"], "type": "has_coe.{u₁ u₂} a b"},
{"kind": "instance", "name": "coe_trans_aux", "class": "has_coe_t_aux", "from_extends": 0, "uparams": ["u₁","u₂","u₃"], "params": [{"name": "a", "type": "Sort u₁"},{"name": "b", "type": "Sort u₂"},{"name": "c", "type": "Sort u₃"},{"name": "_inst_1", "class": "has_coe", "type": "has_coe.{u₁ u₂} a b"},{"name": "_inst_2", "class": "has_coe_t_aux", "type": "has_coe_t_aux.{u₂ u₃} b c"}], "coercion_like": 0, "type": "has_coe_t_aux.{u₁ u₃} a c"},
{"kind": "ignored_problem", "class": "has_coe", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_coe.{u v} a b"},
{"kind": "instance", "name": "coe_base_aux", "class": "has_coe_t_aux", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "a", "type": "Sort u"},{"name": "b", "type": "Sort v"},{"name": "_inst_1", "class": "has_coe", "type": "has_coe.{u v} a b"}], "coercion_like": 1, "type": "has_coe_t_aux.{u v} a b"},
{"kind": "ignored_problem", "class": "has_coe_to_fun", "max_depth": 0, "steps": 1, "uparams": ["u₂","u₃"], "type": "has_coe_to_fun.{u₂ u₃} b"},
{"kind": "ignored_problem", "class": "has_coe_t_aux", "max_depth": 0, "steps": 1, "uparams": ["u₁","u₂"], "type": "has_coe_t_aux.{u₁ u₂} a b"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 10, "uparams": [], "type": "decidable (eq.{1} (list.{0} char) n₁ n₂)"},
{"kind": "instance", "name": "coe_fn_trans", "class": "has_coe_to_fun", "from_extends": 0, "uparams": ["u₁","u₂","u₃"], "params": [{"name": "a", "type": "Sort u₁"},{"name": "b", "type": "Sort u₂"},{"name": "_inst_1", "class": "has_coe_t_aux", "type": "has_coe_t_aux.{u₁ u₂} a b"},{"name": "_inst_2", "class": "has_coe_to_fun", "type": "has_coe_to_fun.{u₂ u₃} b"}], "coercion_like": 0, "type": "has_coe_to_fun.{u₁ u₃} a"},
{"kind": "ignored_problem", "class": "has_coe_to_sort", "max_depth": 0, "steps": 1, "uparams": ["u₂","u₃"], "type": "has_coe_to_sort.{u₂ u₃} b"},
{"kind": "ignored_problem", "class": "has_coe_t_aux", "max_depth": 0, "steps": 1, "uparams": ["u₁","u₂"], "type": "has_coe_t_aux.{u₁ u₂} a b"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 25, "uparams": [], "type": "decidable (not (eq.{1} (list.{0} char) (has_append.append.{0} (list.{0} char) (list.has_append.{0} char) (list.reverse.{0} char p₁) n₁) (has_append.append.{0} (list.{0} char) (list.has_append.{0} char) (list.reverse.{0} char p₂) n₂)))"},
{"kind": "instance", "name": "coe_sort_trans", "class": "has_coe_to_sort", "from_extends": 0, "uparams": ["u₁","u₂","u₃"], "params": [{"name": "a", "type": "Sort u₁"},{"name": "b", "type": "Sort u₂"},{"name": "_inst_1", "class": "has_coe_t_aux", "type": "has_coe_t_aux.{u₁ u₂} a b"},{"name": "_inst_2", "class": "has_coe_to_sort", "type": "has_coe_to_sort.{u₂ u₃} b"}], "coercion_like": 0, "type": "has_coe_to_sort.{u₁ u₃} a"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_coe_t.{u v} a b"},
{"kind": "instance", "name": "coe_to_lift", "class": "has_lift_t", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "a", "type": "Sort u"},{"name": "b", "type": "Sort v"},{"name": "_inst_1", "class": "has_coe_t", "type": "has_coe_t.{u v} a b"}], "coercion_like": 1, "type": "has_lift_t.{u v} a b"},
{"kind": "instance", "name": "coe_bool_to_Prop", "class": "has_coe", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_coe.{1 1} bool Prop"},
{"kind": "instance", "name": "coe_sort_bool", "class": "has_coe_to_sort", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_coe_to_sort.{1 1} bool"},
{"kind": "problem", "class": "has_lift_t", "max_depth": 2, "steps": 4, "uparams": [], "type": "has_lift_t.{1 1} bool Prop"},
{"kind": "dep", "name": "lift_t", "uparams": ["u","v"], "type": "Π (a : Sort u) (b : Sort v), has_lift_t.{u v} a b → a → b"},
{"kind": "instance", "name": "coe_decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "x", "type": "bool"}], "coercion_like": 0, "type": "decidable (@lift_t.{1 1} bool Prop (@coe_to_lift.{1 1} bool Prop (@coe_base.{1 1} bool Prop coe_bool_to_Prop)) x)"},
{"kind": "instance", "name": "string.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} string"},
{"kind": "instance", "name": "coe_subtype", "class": "has_coe", "from_extends": 0, "uparams": ["u"], "params": [{"name": "a", "type": "Sort u"},{"name": "p", "type": "a → Prop"}], "coercion_like": 0, "type": "has_coe.{(max 1 u) u} (@subtype.{u} a p) a"},
{"kind": "instance", "name": "string.has_append", "class": "has_append", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_append.{0} string"},
{"kind": "ignored_problem", "class": "has_lift_t", "max_depth": 2, "steps": 11, "uparams": ["ua₂","ua₁"], "type": "has_lift_t.{ua₂ ua₁} a₂ a₁"},
{"kind": "ignored_problem", "class": "has_lift_t", "max_depth": 0, "steps": 1, "uparams": ["ub₁","ub₂"], "type": "has_lift_t.{ub₁ ub₂} b₁ b₂"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 11, "uparams": [], "type": "decidable (eq.{1} nat (string.length s) (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "instance", "name": "lift_fn", "class": "has_lift", "from_extends": 0, "uparams": ["ua₁","ua₂","ub₁","ub₂"], "params": [{"name": "a₁", "type": "Sort ua₁"},{"name": "a₂", "type": "Sort ua₂"},{"name": "b₁", "type": "Sort ub₁"},{"name": "b₂", "type": "Sort ub₂"},{"name": "_inst_1", "class": "has_lift", "type": "has_lift.{ua₂ ua₁} a₂ a₁"},{"name": "_inst_2", "class": "has_lift_t", "type": "has_lift_t.{ub₁ ub₂} b₁ b₂"}], "coercion_like": 0, "type": "has_lift.{(imax ua₁ ub₁) (imax ua₂ ub₂)} (a₁ → b₁) (a₂ → b₂)"},
{"kind": "problem", "class": "has_append", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_append.{0} string"},
{"kind": "ignored_problem", "class": "has_lift_t", "max_depth": 0, "steps": 1, "uparams": ["ub₁","ub₂"], "type": "has_lift_t.{ub₁ ub₂} b₁ b₂"},
{"kind": "instance", "name": "lift_fn_range", "class": "has_lift", "from_extends": 0, "uparams": ["ua","ub₁","ub₂"], "params": [{"name": "a", "type": "Sort ua"},{"name": "b₁", "type": "Sort ub₁"},{"name": "b₂", "type": "Sort ub₂"},{"name": "_inst_1", "class": "has_lift_t", "type": "has_lift_t.{ub₁ ub₂} b₁ b₂"}], "coercion_like": 0, "type": "has_lift.{(imax ua ub₁) (imax ua ub₂)} (a → b₁) (a → b₂)"},
{"kind": "ignored_problem", "class": "has_lift_t", "max_depth": 2, "steps": 10, "uparams": ["ua₂","ua₁"], "type": "has_lift_t.{ua₂ ua₁} a₂ a₁"},
{"kind": "instance", "name": "lift_fn_dom", "class": "has_lift", "from_extends": 0, "uparams": ["ua₁","ua₂","ub"], "params": [{"name": "a₁", "type": "Sort ua₁"},{"name": "a₂", "type": "Sort ua₂"},{"name": "b", "type": "Sort ub"},{"name": "_inst_1", "class": "has_lift", "type": "has_lift.{ua₂ ua₁} a₂ a₁"}], "coercion_like": 0, "type": "has_lift.{(imax ua₁ ub) (imax ua₂ ub)} (a₁ → b) (a₂ → b)"},
{"kind": "ignored_problem", "class": "has_lift_t", "max_depth": 0, "steps": 1, "uparams": ["ub₁","ub₂"], "type": "has_lift_t.{ub₁+1 ub₂+1} b₁ b₂"},
{"kind": "ignored_problem", "class": "has_lift_t", "max_depth": 0, "steps": 2, "uparams": ["ub₂","ua₁"], "type": "has_lift_t.{ua₁+1 ub₂+1} a₁ a₂"},
{"kind": "instance", "name": "lift_pair", "class": "has_lift", "from_extends": 0, "uparams": ["ua₁","ub₁","ub₂"], "params": [{"name": "a₁", "type": "Type ua₁"},{"name": "a₂", "type": "Type ub₂"},{"name": "b₁", "type": "Type ub₁"},{"name": "b₂", "type": "Type ub₂"},{"name": "_inst_1", "class": "has_lift_t", "type": "has_lift_t.{ua₁+1 ub₂+1} a₁ a₂"},{"name": "_inst_2", "class": "has_lift_t", "type": "has_lift_t.{ub₁+1 ub₂+1} b₁ b₂"}], "coercion_like": 0, "type": "has_lift.{(max (ua₁+1) (ub₁+1)) ub₂+1} (prod.{ua₁ ub₁} a₁ b₁) (prod.{ub₂ ub₂} a₂ b₂)"},
{"kind": "ignored_problem", "class": "has_lift_t", "max_depth": 0, "steps": 1, "uparams": ["ua₂","ua₁"], "type": "has_lift_t.{ua₁+1 ua₂+1} a₁ a₂"},
{"kind": "instance", "name": "lift_pair₁", "class": "has_lift", "from_extends": 0, "uparams": ["ua₁","ua₂","ub"], "params": [{"name": "a₁", "type": "Type ua₁"},{"name": "a₂", "type": "Type ua₂"},{"name": "b", "type": "Type ub"},{"name": "_inst_1", "class": "has_lift_t", "type": "has_lift_t.{ua₁+1 ua₂+1} a₁ a₂"}], "coercion_like": 0, "type": "has_lift.{(max (ua₁+1) (ub+1)) (max (ua₂+1) (ub+1))} (prod.{ua₁ ub} a₁ b) (prod.{ua₂ ub} a₂ b)"},
{"kind": "ignored_problem", "class": "has_lift_t", "max_depth": 0, "steps": 1, "uparams": ["ub₁","ub₂"], "type": "has_lift_t.{ub₁+1 ub₂+1} b₁ b₂"},
{"kind": "instance", "name": "lift_pair₂", "class": "has_lift", "from_extends": 0, "uparams": ["ua","ub₁","ub₂"], "params": [{"name": "a", "type": "Type ua"},{"name": "b₁", "type": "Type ub₁"},{"name": "b₂", "type": "Type ub₂"},{"name": "_inst_1", "class": "has_lift_t", "type": "has_lift_t.{ub₁+1 ub₂+1} b₁ b₂"}], "coercion_like": 0, "type": "has_lift.{(max (ua+1) (ub₁+1)) (max (ua+1) (ub₂+1))} (prod.{ua ub₁} a b₁) (prod.{ua ub₂} a b₂)"},
{"kind": "ignored_problem", "class": "has_lift_t", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_lift_t.{u+1 v+1} a b"},
{"kind": "instance", "name": "lift_list", "class": "has_lift", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "a", "type": "Type u"},{"name": "b", "type": "Type v"},{"name": "_inst_1", "class": "has_lift_t", "type": "has_lift_t.{u+1 v+1} a b"}], "coercion_like": 0, "type": "has_lift.{u+1 v+1} (list.{u} a) (list.{v} b)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 24, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> string)"},
{"kind": "class", "name": "has_repr", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_repr.{u} α"},
{"kind": "instance", "name": "bool.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_repr.{0} bool"},
{"kind": "dep", "name": "has_one.one", "uparams": ["u"], "type": "Π (α : Type u), has_one.{u} α → α"},
{"kind": "dep", "name": "has_zero.zero", "uparams": ["u"], "type": "Π (α : Type u), has_zero.{u} α → α"},
{"kind": "problem", "class": "decidable", "max_depth": 1, "steps": 26, "uparams": [], "type": "decidable (not (eq.{1} nat (has_one.one.{0} nat nat.has_one) (has_zero.zero.{0} nat nat.has_zero)))"},
{"kind": "instance", "name": "decidable.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"}], "coercion_like": 0, "type": "has_repr.{0} (decidable p)"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_repr.{u} α"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_repr.{u} α"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_repr.{u} α"},
{"kind": "instance", "name": "list.has_repr", "class": "has_repr", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_repr", "type": "has_repr.{u} α"}], "coercion_like": 0, "type": "has_repr.{u} (list.{u} α)"},
{"kind": "instance", "name": "unit.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_repr.{0} punit.{1}"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_repr.{u} α"},
{"kind": "instance", "name": "option.has_repr", "class": "has_repr", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_repr", "type": "has_repr.{u} α"}], "coercion_like": 0, "type": "has_repr.{u} (option.{u} α)"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_repr.{u} α"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_repr.{v} β"},
{"kind": "instance", "name": "sum.has_repr", "class": "has_repr", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "_inst_1", "class": "has_repr", "type": "has_repr.{u} α"},{"name": "_inst_2", "class": "has_repr", "type": "has_repr.{v} β"}], "coercion_like": 0, "type": "has_repr.{(max u v)} (sum.{u v} α β)"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_repr.{v} β"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_repr.{u} α"},
{"kind": "instance", "name": "prod.has_repr", "class": "has_repr", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "_inst_1", "class": "has_repr", "type": "has_repr.{u} α"},{"name": "_inst_2", "class": "has_repr", "type": "has_repr.{v} β"}], "coercion_like": 0, "type": "has_repr.{(max u v)} (prod.{u v} α β)"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_repr.{v} (β a)"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_repr.{u} α"},
{"kind": "dep", "name": "sigma", "uparams": ["u","v"], "type": "Π (α : Type u), (α → Type v) → Type (max u v)"},
{"kind": "instance", "name": "sigma.has_repr", "class": "has_repr", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "α → Type v"},{"name": "_inst_1", "class": "has_repr", "type": "has_repr.{u} α"},{"name": "s", "class": "has_repr", "type": "Π (x : α), has_repr.{v} (β x)"}], "coercion_like": 0, "type": "has_repr.{(max u v)} (@sigma.{u v} α β)"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_repr.{u} α"},
{"kind": "instance", "name": "subtype.has_repr", "class": "has_repr", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "p", "type": "α → Prop"},{"name": "_inst_1", "class": "has_repr", "type": "has_repr.{u} α"}], "coercion_like": 0, "type": "has_repr.{u} (@subtype.{u+1} α p)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (has_one.one.{0} nat nat.has_one))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 17, "uparams": [], "type": "decidable (eq.{1} nat (has_add.add.{0} nat nat.has_add d (has_one.one.{0} nat nat.has_one)) base)"},
{"kind": "instance", "name": "nat.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_repr.{0} nat"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 8, "uparams": [], "type": "decidable (eq.{1} char c (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 8, "uparams": [], "type": "decidable (eq.{1} char c (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 8, "uparams": [], "type": "decidable (eq.{1} char c (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 8, "uparams": [], "type": "decidable (eq.{1} char c (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 52, "uparams": [], "type": "decidable (or (has_le.le.{0} nat nat.has_le (char.to_nat c) (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))) (eq.{1} char c (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))"},
{"kind": "instance", "name": "char.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_repr.{0} char"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 20, "uparams": [], "type": "decidable (eq.{1} bool (string.is_empty s) bool.tt)"},
{"kind": "instance", "name": "string.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_repr.{0} string"},
{"kind": "problem", "class": "has_repr", "max_depth": 0, "steps": 3, "uparams": [], "type": "has_repr.{0} nat"},
{"kind": "instance", "name": "fin.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"}], "coercion_like": 0, "type": "has_repr.{0} (fin n)"},
{"kind": "instance", "name": "unsigned.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_repr.{0} unsigned"},
{"kind": "problem", "class": "has_repr", "max_depth": 0, "steps": 4, "uparams": [], "type": "has_repr.{0} char"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 25, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> string)"},
{"kind": "dep", "name": "ordering", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "ordering.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_repr.{0} ordering"},
{"kind": "class", "name": "has_to_string", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_string.{u} α"},
{"kind": "instance", "name": "string.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_string.{0} string"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (lt a b)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (lt b a)"},
{"kind": "instance", "name": "bool.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_string.{0} bool"},
{"kind": "instance", "name": "decidable.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"}], "coercion_like": 0, "type": "has_to_string.{0} (decidable p)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α _inst_1 a b))"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_string.{u} α"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_string.{u} α"},
{"kind": "instance", "name": "ordering.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "ordering"},{"name": "b", "type": "ordering"}], "coercion_like": 0, "type": "decidable (@eq.{1} ordering a b)"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_string.{u} α"},
{"kind": "instance", "name": "list.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_to_string", "type": "has_to_string.{u} α"}], "coercion_like": 0, "type": "has_to_string.{u} (list.{u} α)"},
{"kind": "instance", "name": "unit.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_string.{0} punit.{1}"},
{"kind": "instance", "name": "nat.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_string.{0} nat"},
{"kind": "instance", "name": "char.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_string.{0} char"},
{"kind": "problem", "class": "has_to_string", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_to_string.{0} nat"},
{"kind": "instance", "name": "fin.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"}], "coercion_like": 0, "type": "has_to_string.{0} (fin n)"},
{"kind": "instance", "name": "unsigned.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_string.{0} unsigned"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_string.{u} α"},
{"kind": "instance", "name": "option.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_to_string", "type": "has_to_string.{u} α"}], "coercion_like": 0, "type": "has_to_string.{u} (option.{u} α)"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_to_string.{u} α"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_to_string.{v} β"},
{"kind": "instance", "name": "sum.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "_inst_1", "class": "has_to_string", "type": "has_to_string.{u} α"},{"name": "_inst_2", "class": "has_to_string", "type": "has_to_string.{v} β"}], "coercion_like": 0, "type": "has_to_string.{(max u v)} (sum.{u v} α β)"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_to_string.{v} β"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_to_string.{u} α"},
{"kind": "instance", "name": "prod.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "_inst_1", "class": "has_to_string", "type": "has_to_string.{u} α"},{"name": "_inst_2", "class": "has_to_string", "type": "has_to_string.{v} β"}], "coercion_like": 0, "type": "has_to_string.{(max u v)} (prod.{u v} α β)"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_to_string.{v} (β a)"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_to_string.{u} α"},
{"kind": "instance", "name": "sigma.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "α → Type v"},{"name": "_inst_1", "class": "has_to_string", "type": "has_to_string.{u} α"},{"name": "s", "class": "has_to_string", "type": "Π (x : α), has_to_string.{v} (β x)"}], "coercion_like": 0, "type": "has_to_string.{(max u v)} (@sigma.{u v} α β)"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_string.{u} α"},
{"kind": "instance", "name": "subtype.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "p", "type": "α → Prop"},{"name": "_inst_1", "class": "has_to_string", "type": "has_to_string.{u} α"}], "coercion_like": 0, "type": "has_to_string.{u} (@subtype.{u+1} α p)"},
{"kind": "class", "name": "is_symm_op", "uparams": ["u","v"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "β", "is_out": 1, "type": "Type.{v}"},{"name": "op", "is_out": 0, "type": "α -> α -> β"}]},
{"kind": "class", "name": "is_commutative", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"}]},
{"kind": "ignored_problem", "class": "is_commutative", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_commutative.{u} α op"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 13, "uparams": [], "type": "has_sizeof.{1} string"},
{"kind": "instance", "name": "is_symm_op_of_is_commutative", "class": "is_symm_op", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "op", "type": "α → α → α"},{"name": "_inst_1", "class": "is_commutative", "type": "is_commutative.{u} α op"}], "coercion_like": 1, "type": "is_symm_op.{u u} α α op"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 33, "uparams": [], "type": "has_sizeof.{1} unsigned"},
{"kind": "dep", "name": "name", "uparams": [], "type": "Type"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_sizeof.{1} name"},
{"kind": "class", "name": "is_associative", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"}]},
{"kind": "instance", "name": "name.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} name"},
{"kind": "class", "name": "is_left_id", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"},{"name": "o", "is_out": 1, "type": "α"}]},
{"kind": "instance", "name": "string_to_name", "class": "has_coe", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_coe.{1 1} string name"},
{"kind": "class", "name": "is_right_id", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"},{"name": "o", "is_out": 1, "type": "α"}]},
{"kind": "class", "name": "is_left_null", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"},{"name": "o", "is_out": 1, "type": "α"}]},
{"kind": "class", "name": "is_right_null", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"},{"name": "o", "is_out": 1, "type": "α"}]},
{"kind": "problem", "class": "has_repr", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_repr.{0} unsigned"},
{"kind": "class", "name": "is_left_cancel", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"}]},
{"kind": "class", "name": "is_right_cancel", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"}]},
{"kind": "class", "name": "is_idempotent", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"}]},
{"kind": "class", "name": "is_left_distrib", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op₁", "is_out": 0, "type": "α -> α -> α"},{"name": "op₂", "is_out": 1, "type": "α -> α -> α"}]},
{"kind": "class", "name": "is_right_distrib", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op₁", "is_out": 0, "type": "α -> α -> α"},{"name": "op₂", "is_out": 1, "type": "α -> α -> α"}]},
{"kind": "class", "name": "is_left_inv", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"},{"name": "inv", "is_out": 1, "type": "α -> α"},{"name": "o", "is_out": 1, "type": "α"}]},
{"kind": "class", "name": "is_right_inv", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"},{"name": "inv", "is_out": 1, "type": "α -> α"},{"name": "o", "is_out": 1, "type": "α"}]},
{"kind": "class", "name": "is_cond_left_inv", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"},{"name": "inv", "is_out": 1, "type": "α -> α"},{"name": "o", "is_out": 1, "type": "α"},{"name": "p", "is_out": 1, "type": "α -> Prop"}]},
{"kind": "instance", "name": "name.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_string.{0} name"},
{"kind": "dep", "name": "name.lt", "uparams": [], "type": "name → name → Prop"},
{"kind": "instance", "name": "name.lt.decidable_rel", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "name"},{"name": "b", "type": "name"}], "coercion_like": 0, "type": "decidable (name.lt a b)"},
{"kind": "class", "name": "is_cond_right_inv", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "op", "is_out": 0, "type": "α -> α -> α"},{"name": "inv", "is_out": 1, "type": "α -> α"},{"name": "o", "is_out": 1, "type": "α"},{"name": "p", "is_out": 1, "type": "α -> Prop"}]},
{"kind": "instance", "name": "name.has_lt", "class": "has_lt", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_lt.{0} name"},
{"kind": "instance", "name": "name.has_decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "name"},{"name": "b", "type": "name"}], "coercion_like": 0, "type": "decidable (@eq.{1} name a b)"},
{"kind": "instance", "name": "name.has_append", "class": "has_append", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_append.{0} name"},
{"kind": "class", "name": "is_distinct", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "a", "is_out": 0, "type": "α"},{"name": "b", "is_out": 0, "type": "α"}]},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (eq.{1} name p n)"},
{"kind": "class", "name": "is_irrefl", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "class", "name": "is_refl", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (eq.{1} name c p)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (eq.{1} name c p)"},
{"kind": "class", "name": "is_symm", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "ignored_problem", "class": "is_symm", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_symm.{u} α r"},
{"kind": "instance", "name": "is_symm_op_of_is_symm", "class": "is_symm_op", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "_inst_1", "class": "is_symm", "type": "is_symm.{u} α r"}], "coercion_like": 0, "type": "is_symm_op.{u 0} α Prop r"},
{"kind": "class", "name": "is_asymm", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "class", "name": "is_antisymm", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "class", "name": "is_trans", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "class", "name": "is_total", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "class", "name": "is_preorder", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "instance", "name": "is_preorder.to_is_refl", "class": "is_refl", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_preorder", "type": "is_preorder.{u} α r"}], "coercion_like": 1, "type": "is_refl.{u} α r"},
{"kind": "instance", "name": "is_preorder.to_is_trans", "class": "is_trans", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_preorder", "type": "is_preorder.{u} α r"}], "coercion_like": 1, "type": "is_trans.{u} α r"},
{"kind": "class", "name": "is_total_preorder", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "instance", "name": "is_total_preorder.to_is_trans", "class": "is_trans", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_total_preorder", "type": "is_total_preorder.{u} α r"}], "coercion_like": 1, "type": "is_trans.{u} α r"},
{"kind": "instance", "name": "is_total_preorder.to_is_total", "class": "is_total", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_total_preorder", "type": "is_total_preorder.{u} α r"}], "coercion_like": 1, "type": "is_total.{u} α r"},
{"kind": "dep", "name": "options", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "options.has_decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "options"},{"name": "b", "type": "options"}], "coercion_like": 0, "type": "decidable (@eq.{1} options a b)"},
{"kind": "ignored_problem", "class": "is_total", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "is_total.{u} α r"},
{"kind": "instance", "name": "options.has_add", "class": "has_add", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_add.{0} options"},
{"kind": "instance", "name": "options.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} options"},
{"kind": "instance", "name": "is_total_preorder_is_preorder", "class": "is_preorder", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "s", "class": "is_total_preorder", "type": "is_total_preorder.{u} α r"}], "coercion_like": 1, "type": "is_preorder.{u} α r"},
{"kind": "class", "name": "is_partial_order", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "instance", "name": "is_partial_order.to_is_preorder", "class": "is_preorder", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_partial_order", "type": "is_partial_order.{u} α r"}], "coercion_like": 1, "type": "is_preorder.{u} α r"},
{"kind": "instance", "name": "is_partial_order.to_is_antisymm", "class": "is_antisymm", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_partial_order", "type": "is_partial_order.{u} α r"}], "coercion_like": 1, "type": "is_antisymm.{u} α r"},
{"kind": "class", "name": "is_linear_order", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "instance", "name": "is_linear_order.to_is_partial_order", "class": "is_partial_order", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_linear_order", "type": "is_linear_order.{u} α r"}], "coercion_like": 1, "type": "is_partial_order.{u} α r"},
{"kind": "instance", "name": "is_linear_order.to_is_total", "class": "is_total", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_linear_order", "type": "is_linear_order.{u} α r"}], "coercion_like": 1, "type": "is_total.{u} α r"},
{"kind": "dep", "name": "format", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "format.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} format"},
{"kind": "instance", "name": "format.has_append", "class": "has_append", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_append.{0} format"},
{"kind": "instance", "name": "format.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_string.{0} format"},
{"kind": "class", "name": "is_equiv", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "instance", "name": "is_equiv.to_is_preorder", "class": "is_preorder", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_equiv", "type": "is_equiv.{u} α r"}], "coercion_like": 1, "type": "is_preorder.{u} α r"},
{"kind": "instance", "name": "is_equiv.to_is_symm", "class": "is_symm", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_equiv", "type": "is_equiv.{u} α r"}], "coercion_like": 1, "type": "is_symm.{u} α r"},
{"kind": "class", "name": "has_to_format", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "format.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} format"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_format.{u} α"},
{"kind": "instance", "name": "nat_to_format", "class": "has_coe", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_coe.{1 1} nat format"},
{"kind": "instance", "name": "string_to_format", "class": "has_coe", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_coe.{1 1} string format"},
{"kind": "class", "name": "is_per", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "instance", "name": "is_per.to_is_symm", "class": "is_symm", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_per", "type": "is_per.{u} α r"}], "coercion_like": 1, "type": "is_symm.{u} α r"},
{"kind": "instance", "name": "is_per.to_is_trans", "class": "is_trans", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_per", "type": "is_per.{u} α r"}], "coercion_like": 1, "type": "is_trans.{u} α r"},
{"kind": "problem", "class": "has_append", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_append.{0} format"},
{"kind": "class", "name": "is_strict_order", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "r", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "instance", "name": "is_strict_order.to_is_irrefl", "class": "is_irrefl", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_strict_order", "type": "is_strict_order.{u} α r"}], "coercion_like": 1, "type": "is_irrefl.{u} α r"},
{"kind": "instance", "name": "is_strict_order.to_is_trans", "class": "is_trans", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "c", "class": "is_strict_order", "type": "is_strict_order.{u} α r"}], "coercion_like": 1, "type": "is_trans.{u} α r"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_format.{u} α"},
{"kind": "instance", "name": "options.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} options"},
{"kind": "problem", "class": "has_coe_to_sort", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_coe_to_sort.{1 1} bool"},
{"kind": "class", "name": "is_incomp_trans", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "lt", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 26, "uparams": [], "type": "decidable (eq.{1} bool b bool.tt)"},
{"kind": "instance", "name": "bool.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} bool"},
{"kind": "class", "name": "is_strict_weak_order", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "lt", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "instance", "name": "decidable.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [{"name": "p", "type": "Prop"}], "coercion_like": 0, "type": "has_to_format.{0} (decidable p)"},
{"kind": "instance", "name": "is_strict_weak_order.to_is_strict_order", "class": "is_strict_order", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "lt", "type": "α → α → Prop"},{"name": "c", "class": "is_strict_weak_order", "type": "is_strict_weak_order.{u} α lt"}], "coercion_like": 1, "type": "is_strict_order.{u} α lt"},
{"kind": "instance", "name": "is_strict_weak_order.to_is_incomp_trans", "class": "is_incomp_trans", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "lt", "type": "α → α → Prop"},{"name": "c", "class": "is_strict_weak_order", "type": "is_strict_weak_order.{u} α lt"}], "coercion_like": 1, "type": "is_incomp_trans.{u} α lt"},
{"kind": "instance", "name": "string.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} string"},
{"kind": "instance", "name": "nat.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} nat"},
{"kind": "problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_format.{0} nat"},
{"kind": "instance", "name": "unsigned.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} unsigned"},
{"kind": "class", "name": "is_trichotomous", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "lt", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "instance", "name": "char.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} char"},
{"kind": "problem", "class": "has_to_format", "max_depth": 0, "steps": 5, "uparams": [], "type": "has_to_format.{0} string"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} string format"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_format.{u} α"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_format.{u} α"},
{"kind": "instance", "name": "list.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_to_format", "type": "has_to_format.{u} α"}], "coercion_like": 0, "type": "has_to_format.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 27, "uparams": ["u"], "type": "has_sizeof.{0} (is_trichotomous.{u} α lt)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 27, "uparams": ["u"], "type": "has_sizeof.{0} (is_strict_weak_order.{u} α lt)"},
{"kind": "instance", "name": "name.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} name"},
{"kind": "instance", "name": "unit.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} punit.{1}"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_format.{u} α"},
{"kind": "instance", "name": "option.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_to_format", "type": "has_to_format.{u} α"}], "coercion_like": 0, "type": "has_to_format.{u} (option.{u} α)"},
{"kind": "class", "name": "is_strict_total_order", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"},{"name": "lt", "is_out": 0, "type": "α -> α -> Prop"}]},
{"kind": "instance", "name": "is_strict_total_order.to_is_trichotomous", "class": "is_trichotomous", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "lt", "type": "α → α → Prop"},{"name": "c", "class": "is_strict_total_order", "type": "is_strict_total_order.{u} α lt"}], "coercion_like": 1, "type": "is_trichotomous.{u} α lt"},
{"kind": "instance", "name": "is_strict_total_order.to_is_strict_weak_order", "class": "is_strict_weak_order", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "lt", "type": "α → α → Prop"},{"name": "c", "class": "is_strict_total_order", "type": "is_strict_total_order.{u} α lt"}], "coercion_like": 1, "type": "is_strict_weak_order.{u} α lt"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_to_format.{u} α"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_to_format.{v} β"},
{"kind": "instance", "name": "eq_is_equiv", "class": "is_equiv", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "is_equiv.{u} α (@eq.{u+1} α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 36, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} {β : Type.{u}} (a : α -> β) (a : f α), (f β))"},
{"kind": "ignored_problem", "class": "is_irrefl", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_irrefl.{u} α r"},
{"kind": "ignored_problem", "class": "is_refl", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_refl.{u} α r"},
{"kind": "ignored_problem", "class": "is_trans", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_trans.{u} α r"},
{"kind": "ignored_problem", "class": "is_symm", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_symm.{u} α r"},
{"kind": "instance", "name": "sum_has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "_inst_1", "class": "has_to_format", "type": "has_to_format.{u} α"},{"name": "_inst_2", "class": "has_to_format", "type": "has_to_format.{v} β"}], "coercion_like": 0, "type": "has_to_format.{(max u v)} (sum.{u v} α β)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 36, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} {β : Type.{u}} (a : α) (a : f β), (f α))"},
{"kind": "ignored_problem", "class": "is_antisymm", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_antisymm.{u} α r"},
{"kind": "ignored_problem", "class": "is_asymm", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_asymm.{u} α r"},
{"kind": "ignored_problem", "class": "is_trichotomous", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_trichotomous.{u} α r"},
{"kind": "ignored_problem", "class": "is_incomp_trans", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_incomp_trans.{u} α r"},
{"kind": "ignored_problem", "class": "is_irrefl", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_irrefl.{u} α r"},
{"kind": "ignored_problem", "class": "is_trans", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_trans.{u} α r"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_to_format.{v} β"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_to_format.{u} α"},
{"kind": "instance", "name": "is_asymm_of_is_trans_of_is_irrefl", "class": "is_asymm", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "_inst_1", "class": "is_trans", "type": "is_trans.{u} α r"},{"name": "_inst_2", "class": "is_irrefl", "type": "is_irrefl.{u} α r"}], "coercion_like": 0, "type": "is_asymm.{u} α r"},
{"kind": "ignored_problem", "class": "is_irrefl", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_irrefl.{u} α r"},
{"kind": "ignored_problem", "class": "is_refl", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_refl.{u} α r"},
{"kind": "ignored_problem", "class": "is_trans", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_trans.{u} α r"},
{"kind": "ignored_problem", "class": "is_symm", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_symm.{u} α r"},
{"kind": "ignored_problem", "class": "is_asymm", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_asymm.{u} α r"},
{"kind": "ignored_problem", "class": "is_total", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_total.{u} α r"},
{"kind": "ignored_problem", "class": "is_trichotomous", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_trichotomous.{u} α r"},
{"kind": "instance", "name": "prod.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "_inst_1", "class": "has_to_format", "type": "has_to_format.{u} α"},{"name": "_inst_2", "class": "has_to_format", "type": "has_to_format.{v} β"}], "coercion_like": 0, "type": "has_to_format.{(max u v)} (prod.{u v} α β)"},
{"kind": "ignored_problem", "class": "is_incomp_trans", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_incomp_trans.{u} α r"},
{"kind": "class", "name": "functor", "uparams": ["u","v"], "params": [{"name": "f", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "functor", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "functor.{u v} f"},
{"kind": "ignored_problem", "class": "is_irrefl", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "is_irrefl.{u} α r"},
{"kind": "ignored_problem", "class": "is_incomp_trans", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "is_incomp_trans.{u} α r"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_to_format.{v} (β a)"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_to_format.{u} α"},
{"kind": "instance", "name": "sigma.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "α → Type v"},{"name": "_inst_1", "class": "has_to_format", "type": "has_to_format.{u} α"},{"name": "s", "class": "has_to_format", "type": "Π (x : α), has_to_format.{v} (β x)"}], "coercion_like": 0, "type": "has_to_format.{(max u v)} (@sigma.{u v} α β)"},
{"kind": "dep", "name": "strict_weak_order.equiv", "uparams": ["u"], "type": "Π (α : Type u), (α → α → Prop) → α → α → Prop"},
{"kind": "instance", "name": "strict_weak_order.is_equiv", "class": "is_equiv", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "r", "type": "α → α → Prop"},{"name": "_inst_1", "class": "is_strict_weak_order", "type": "is_strict_weak_order.{u} α r"}], "coercion_like": 0, "type": "is_equiv.{u} α (@strict_weak_order.equiv.{u} α r)"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_format.{u} α"},
{"kind": "instance", "name": "subtype.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "p", "type": "α → Prop"},{"name": "_inst_1", "class": "has_to_format", "type": "has_to_format.{u} α"}], "coercion_like": 0, "type": "has_to_format.{u} (@subtype.{u+1} α p)"},
{"kind": "ignored_problem", "class": "is_refl", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "is_refl.{u} α le"},
{"kind": "ignored_problem", "class": "is_trans", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "is_trans.{u} α lt"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (lt a c)"},
{"kind": "ignored_problem", "class": "is_incomp_trans", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "is_incomp_trans.{u} α lt"},
{"kind": "ignored_problem", "class": "is_total", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "is_total.{u} α le"},
{"kind": "ignored_problem", "class": "is_trans", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "is_trans.{u} α lt"},
{"kind": "ignored_problem", "class": "is_trans", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "is_trans.{u} α le"},
{"kind": "ignored_problem", "class": "is_trichotomous", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_trichotomous.{u} α lt"},
{"kind": "ignored_problem", "class": "is_trichotomous", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_trichotomous.{u} α lt"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (le b a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (lt a c)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (le a b)"},
{"kind": "ignored_problem", "class": "is_incomp_trans", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "is_incomp_trans.{u} α lt"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (le c b)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (le b c)"},
{"kind": "ignored_problem", "class": "is_trichotomous", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_trichotomous.{u} α lt"},
{"kind": "ignored_problem", "class": "is_trichotomous", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_trichotomous.{u} α lt"},
{"kind": "ignored_problem", "class": "is_irrefl", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_irrefl.{u} α lt"},
{"kind": "ignored_problem", "class": "is_irrefl", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "is_irrefl.{u} α lt"},
{"kind": "ignored_problem", "class": "is_irrefl", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "is_irrefl.{u} α lt"},
{"kind": "ignored_problem", "class": "is_trans", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "is_trans.{u} α lt"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_format.{u} α"},
{"kind": "dep", "name": "level", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "level.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} level"},
{"kind": "instance", "name": "level.has_decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "level"},{"name": "b", "type": "level"}], "coercion_like": 0, "type": "decidable (@eq.{1} level a b)"},
{"kind": "instance", "name": "level.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_string.{0} level"},
{"kind": "instance", "name": "level.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} level"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 4, "uparams": [], "type": "decidable (eq.{1} name n₁ n)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 37, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} (a : α), (f α))"},
{"kind": "class", "name": "has_pure", "uparams": ["u","v"], "params": [{"name": "f", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 38, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (v+1))} (Pi {α : Type.{u}} {β : Type.{u}} (a : f (α -> β)) (a : f α), (f β))"},
{"kind": "class", "name": "has_seq", "uparams": ["u","v"], "params": [{"name": "f", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 39, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (v+1))} (Pi {α : Type.{u}} {β : Type.{u}} (a : f α) (a : f β), (f α))"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "class", "name": "has_seq_left", "uparams": ["u","v"], "params": [{"name": "f", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (v+1))} (Pi {α : Type.{u}} {β : Type.{u}} (a : f α) (a : f β), (f β))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 37, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 37, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 37, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 37, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "class", "name": "has_seq_right", "uparams": ["u","v"], "params": [{"name": "f", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 38, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_seq", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_seq.{u v} f"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "functor.{u v} f"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 38, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 38, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 6, "uparams": ["u","v"], "type": "has_sizeof.{(max (u+1) v)+1} (functor.{u v} f)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 5, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (v+1))} (has_pure.{u v} f)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 4, "uparams": ["u","v"], "type": "has_sizeof.{(max (u+1) v)+1} (has_seq.{u v} f)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 3, "uparams": ["u","v"], "type": "has_sizeof.{(max (u+1) v)+1} (has_seq_left.{u v} f)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u","v"], "type": "has_sizeof.{(max (u+1) v)+1} (has_seq_right.{u v} f)"},
{"kind": "class", "name": "preorder", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "preorder.to_has_le", "class": "has_le", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "preorder", "type": "preorder.{u} α"}], "coercion_like": 1, "type": "has_le.{u} α"},
{"kind": "instance", "name": "preorder.to_has_lt", "class": "has_lt", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "preorder", "type": "preorder.{u} α"}], "coercion_like": 1, "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "class", "name": "applicative", "uparams": ["u","v"], "params": [{"name": "f", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "instance", "name": "applicative.to_functor", "class": "functor", "from_extends": 1, "uparams": ["u","v"], "params": [{"name": "f", "type": "Type u → Type v"},{"name": "c", "class": "applicative", "type": "applicative.{u v} f"}], "coercion_like": 1, "type": "functor.{u v} f"},
{"kind": "instance", "name": "applicative.to_has_pure", "class": "has_pure", "from_extends": 1, "uparams": ["u","v"], "params": [{"name": "f", "type": "Type u → Type v"},{"name": "c", "class": "applicative", "type": "applicative.{u v} f"}], "coercion_like": 1, "type": "has_pure.{u v} f"},
{"kind": "instance", "name": "applicative.to_has_seq", "class": "has_seq", "from_extends": 1, "uparams": ["u","v"], "params": [{"name": "f", "type": "Type u → Type v"},{"name": "c", "class": "applicative", "type": "applicative.{u v} f"}], "coercion_like": 1, "type": "has_seq.{u v} f"},
{"kind": "instance", "name": "applicative.to_has_seq_left", "class": "has_seq_left", "from_extends": 1, "uparams": ["u","v"], "params": [{"name": "f", "type": "Type u → Type v"},{"name": "c", "class": "applicative", "type": "applicative.{u v} f"}], "coercion_like": 1, "type": "has_seq_left.{u v} f"},
{"kind": "instance", "name": "applicative.to_has_seq_right", "class": "has_seq_right", "from_extends": 1, "uparams": ["u","v"], "params": [{"name": "f", "type": "Type u → Type v"},{"name": "c", "class": "applicative", "type": "applicative.{u v} f"}], "coercion_like": 1, "type": "has_seq_right.{u v} f"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 38, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 38, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 38, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 38, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 38, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 42, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} {β : Type.{u}} (a : m α) (a : α -> (m β)), (m β))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 39, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 39, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "class", "name": "has_bind", "uparams": ["u","v"], "params": [{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 39, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 39, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "functor.{u v} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 3, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (v+1))} (applicative.{u v} m)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (v+1))} (has_bind.{u v} m)"},
{"kind": "class", "name": "partial_order", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "partial_order.to_preorder", "class": "preorder", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "partial_order", "type": "partial_order.{u} α"}], "coercion_like": 1, "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 2, "steps": 7, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "class", "name": "monad", "uparams": ["u","v"], "params": [{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "instance", "name": "monad.to_applicative", "class": "applicative", "from_extends": 1, "uparams": ["u","v"], "params": [{"name": "m", "type": "Type u → Type v"},{"name": "c", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 1, "type": "applicative.{u v} m"},
{"kind": "instance", "name": "monad.to_has_bind", "class": "has_bind", "from_extends": 1, "uparams": ["u","v"], "params": [{"name": "m", "type": "Type u → Type v"},{"name": "c", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 1, "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 39, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 39, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 39, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 39, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 39, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 39, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_string.{0} α"},
{"kind": "problem", "class": "has_to_string", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_to_string.{0} format"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_string.{0} α"},
{"kind": "dep", "name": "exceptional", "uparams": [], "type": "Type → Type"},
{"kind": "instance", "name": "exceptional.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [{"name": "α", "type": "Type"},{"name": "_inst_1", "class": "has_to_string", "type": "has_to_string.{0} α"}], "coercion_like": 0, "type": "has_to_string.{0} (exceptional α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 26, "uparams": [], "type": "decidable (eq.{1} bool first bool.tt)"},
{"kind": "class", "name": "linear_order", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["u_1"], "type": "has_to_format.{u_1} key"},
{"kind": "instance", "name": "exceptional.monad", "class": "monad", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "monad.{0 0} exceptional"},
{"kind": "instance", "name": "linear_order.to_partial_order", "class": "partial_order", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "linear_order", "type": "linear_order.{u} α"}], "coercion_like": 1, "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} key"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 2, "steps": 7, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 2, "steps": 7, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 42, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (v+1))} (Pi {α : Type.{u}} (a : f α) (a : f α), (f α))"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "class", "name": "has_orelse", "uparams": ["u","v"], "params": [{"name": "f", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad.{0 0} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_bind.{0 0} m"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 11, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} key"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} key"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 3, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (v+1))} (applicative.{u v} f)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u","v"], "type": "has_sizeof.{(max (u+1) v)+1} (has_orelse.{u v} f)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 43, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (v+1))} (Pi {α : Type.{u}}, (f α))"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} key"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 2, "steps": 10, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 2, "steps": 7, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "class", "name": "alternative", "uparams": ["u","v"], "params": [{"name": "f", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "instance", "name": "alternative.to_applicative", "class": "applicative", "from_extends": 1, "uparams": ["u","v"], "params": [{"name": "f", "type": "Type u → Type v"},{"name": "c", "class": "alternative", "type": "alternative.{u v} f"}], "coercion_like": 1, "type": "applicative.{u v} f"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "instance", "name": "alternative.to_has_orelse", "class": "has_orelse", "from_extends": 1, "uparams": ["u","v"], "params": [{"name": "f", "type": "Type u → Type v"},{"name": "c", "class": "alternative", "type": "alternative.{u v} f"}], "coercion_like": 1, "type": "has_orelse.{u v} f"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 45, "uparams": ["u","w","v"], "type": "has_sizeof.{(max ((u+1)+1) (v+1) (w+1))} (Pi {α : Type.{u}} (a : m α), (n α))"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 2, "steps": 10, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 2, "steps": 7, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "alternative.{u v} f"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 2, "steps": 10, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 2, "steps": 7, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} key"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["v"], "type": "has_pure.{0 v} f"},
{"kind": "ignored_problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "alternative.{0 v} f"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 11, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 11, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "class", "name": "has_monad_lift", "uparams": ["u","v","w"], "params": [{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"},{"name": "n", "is_out": 0, "type": "Type.{u} -> Type.{w}"}]},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["v"], "type": "has_pure.{0 v} f"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} key"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 11, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "alternative.{0 v} f"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 11, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 11, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 46, "uparams": ["u","w","v"], "type": "has_sizeof.{(max ((u+1)+1) (v+1) (w+1))} (Pi {α : Type.{u}} (a : m α), (n α))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (f b)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} key"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["v"], "type": "has_pure.{0 v} f"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))"},
{"kind": "ignored_problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "alternative.{0 v} f"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 11, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 11, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} key"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_orelse", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_orelse.{u v} f"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "functor.{u v} f"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 11, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} f"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 1, "steps": 6, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "class", "name": "has_monad_lift_t", "uparams": ["u","v","w"], "params": [{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"},{"name": "n", "is_out": 0, "type": "Type.{u} -> Type.{w}"}]},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 1, "steps": 9, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 0, "steps": 1, "uparams": ["u_2","u_3","u_1"], "type": "has_monad_lift_t.{u_1 u_2 u_3} m n"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α _inst_1) b a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α _inst_1) a b)"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 21, "uparams": [], "type": "Pi (a : nat) (b : nat), (decidable (has_lt.lt.{0} nat nat.has_lt a b))"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 0, "steps": 1, "uparams": ["u_2","u_3","u_1"], "type": "has_monad_lift_t.{u_1 u_2 u_3} m n"},
{"kind": "ignored_problem", "class": "has_monad_lift", "max_depth": 0, "steps": 1, "uparams": ["u_2","u_3","u_1"], "type": "has_monad_lift.{u_1 u_2 u_3} n o"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "instance", "name": "has_monad_lift_t_trans", "class": "has_monad_lift_t", "from_extends": 0, "uparams": ["u_1","u_2","u_3","u_4"], "params": [{"name": "m", "type": "Type u_1 → Type u_2"},{"name": "n", "type": "Type u_1 → Type u_3"},{"name": "o", "type": "Type u_1 → Type u_4"},{"name": "_inst_1", "class": "has_monad_lift", "type": "has_monad_lift.{u_1 u_3 u_4} n o"},{"name": "_inst_2", "class": "has_monad_lift_t", "type": "has_monad_lift_t.{u_1 u_2 u_3} m n"}], "coercion_like": 0, "type": "has_monad_lift_t.{u_1 u_2 u_4} m o"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 26, "uparams": [], "type": "decidable (eq.{1} bool first bool.tt)"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_format.{0} data"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_to_format.{0} key"},
{"kind": "instance", "name": "has_monad_lift_t_refl", "class": "has_monad_lift_t", "from_extends": 0, "uparams": ["u_1","u_2"], "params": [{"name": "m", "type": "Type u_1 → Type u_2"}], "coercion_like": 0, "type": "has_monad_lift_t.{u_1 u_2 u_2} m m"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_monad_lift_t.{u v v} m m"},
{"kind": "instance", "name": "decidable_lt_of_decidable_le", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "preorder", "type": "preorder.{u} α"},{"name": "_inst_2", "class": "decidable", "type": "Π (a b : α), decidable (@has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a b)"},{"name": "a", "type": "α"},{"name": "b", "type": "α"}], "coercion_like": 0, "type": "decidable (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a b)"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 2, "steps": 7, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_format.{0} data"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_to_format.{0} key"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α _inst_1)) b a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α _inst_1)) a b)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "monad.{0 v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["v"], "type": "has_bind.{0 v} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 49, "uparams": ["u","w","v"], "type": "has_sizeof.{(max ((u+1)+1) (max ((u+1)+1) (v+1)) (w+1))} (Pi {α : Type.{u}} (a : Pi {α : Type.{u}} (a : m α), (m' α)) (a : n α), (n' α))"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "dep", "name": "native.rb_map", "uparams": ["u₁","u₂"], "type": "Type u₁ → Type u₂ → Type (max u₁ u₂)"},
{"kind": "instance", "name": "native.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [{"name": "key", "type": "Type"},{"name": "data", "type": "Type"},{"name": "_inst_1", "class": "has_to_format", "type": "has_to_format.{0} key"},{"name": "_inst_2", "class": "has_to_format", "type": "has_to_format.{0} data"}], "coercion_like": 0, "type": "has_to_format.{0} (native.rb_map.{0 0} key data)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 26, "uparams": [], "type": "decidable (eq.{1} bool first bool.tt)"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_to_string.{0} key"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_string.{0} data"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_bind.{u u} m"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_string.{0} data"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_to_string.{0} key"},
{"kind": "class", "name": "monad_functor", "uparams": ["u","v","w"], "params": [{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"},{"name": "m'", "is_out": 0, "type": "Type.{u} -> Type.{v}"},{"name": "n", "is_out": 0, "type": "Type.{u} -> Type.{w}"},{"name": "n'", "is_out": 0, "type": "Type.{u} -> Type.{w}"}]},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "monad.{0 v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["v"], "type": "has_bind.{0 v} m"},
{"kind": "instance", "name": "native.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [{"name": "key", "type": "Type"},{"name": "data", "type": "Type"},{"name": "_inst_1", "class": "has_to_string", "type": "has_to_string.{0} key"},{"name": "_inst_2", "class": "has_to_string", "type": "has_to_string.{0} data"}], "coercion_like": 0, "type": "has_to_string.{0} (native.rb_map.{0 0} key data)"},
{"kind": "instance", "name": "decidable_eq_of_decidable_le", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "partial_order", "type": "partial_order.{u} α"},{"name": "_inst_2", "class": "decidable", "type": "Π (a b : α), decidable (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b)"},{"name": "a", "type": "α"},{"name": "b", "type": "α"}], "coercion_like": 0, "type": "decidable (@eq.{u+1} α a b)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} key"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 50, "uparams": ["u","w","v"], "type": "has_sizeof.{(max ((u+1)+1) (max ((u+1)+1) (v+1)) (w+1))} (Pi {α : Type.{u}} (a : Pi {α : Type.{u}} (a : m α), (m' α)) (a : n α), (n' α))"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 11, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": ["u_1"], "type": "has_lt.{u_1} key"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} key"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))"},
{"kind": "class", "name": "monad_functor_t", "uparams": ["u","v","w"], "params": [{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"},{"name": "m'", "is_out": 0, "type": "Type.{u} -> Type.{v}"},{"name": "n", "is_out": 0, "type": "Type.{u} -> Type.{w}"},{"name": "n'", "is_out": 0, "type": "Type.{u} -> Type.{w}"}]},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 0, "steps": 1, "uparams": ["u_2","u_3","u_1"], "type": "monad_functor_t.{u_1 u_2 u_3} m m' n n'"},
{"kind": "ignored_problem", "class": "monad_functor", "max_depth": 0, "steps": 1, "uparams": ["u_2","u_3","u_1"], "type": "monad_functor.{u_1 u_2 u_3} n n' o o'"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad.{0 0} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_bind.{0 0} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_format.{0} key"},
{"kind": "instance", "name": "monad_functor_t_trans", "class": "monad_functor_t", "from_extends": 0, "uparams": ["u_1","u_2","u_3","u_4"], "params": [{"name": "m", "type": "Type u_1 → Type u_2"},{"name": "m'", "type": "Type u_1 → Type u_2"},{"name": "n", "type": "Type u_1 → Type u_3"},{"name": "n'", "type": "Type u_1 → Type u_3"},{"name": "o", "type": "Type u_1 → Type u_4"},{"name": "o'", "type": "Type u_1 → Type u_4"},{"name": "_inst_1", "class": "monad_functor", "type": "monad_functor.{u_1 u_3 u_4} n n' o o'"},{"name": "_inst_2", "class": "monad_functor_t", "type": "monad_functor_t.{u_1 u_2 u_3} m m' n n'"}], "coercion_like": 0, "type": "monad_functor_t.{u_1 u_2 u_4} m m' o o'"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "instance", "name": "monad_functor_t_refl", "class": "monad_functor_t", "from_extends": 0, "uparams": ["u_1","u_2"], "params": [{"name": "m", "type": "Type u_1 → Type u_2"},{"name": "m'", "type": "Type u_1 → Type u_2"}], "coercion_like": 0, "type": "monad_functor_t.{u_1 u_2 u_2} m m' m m'"},
{"kind": "dep", "name": "native.rb_set", "uparams": ["u_1"], "type": "Type u_1 → Type u_1"},
{"kind": "instance", "name": "native.rb_set.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [{"name": "key", "type": "Type"},{"name": "_inst_1", "class": "has_to_format", "type": "has_to_format.{0} key"}], "coercion_like": 0, "type": "has_to_format.{0} (native.rb_set.{0} key)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad_functor_t.{u v v} m m' m m'"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "alternative.{u v} m"},
{"kind": "ignored_problem", "class": "has_orelse", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_orelse.{u v} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 49, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (v+1))} (Pi {α : Type.{u}} (a : m α), (out α))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 40, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "problem", "class": "has_to_format", "max_depth": 0, "steps": 9, "uparams": [], "type": "has_to_format.{0} name"},
{"kind": "dep", "name": "name_set", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "name_set.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} name_set"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad.{0 0} m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_bind.{0 0} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 4, "uparams": [], "type": "has_pure.{0 0} m"},
{"kind": "class", "name": "monad_run", "uparams": ["u","v"], "params": [{"name": "out", "is_out": 1, "type": "Type.{u} -> Type.{v}"},{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_bind.{0 0} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 41, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 41, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 41, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 41, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 41, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad.{0 0} m"},
{"kind": "ignored_problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": [], "type": "alternative.{0 0} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 41, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad.{0 0} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 41, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_sizeof.{u+1} ε"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_sizeof.{v+1} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 24, "uparams": [], "type": "decidable (eq.{1} nat l₁ l₂)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 24, "uparams": [], "type": "decidable (eq.{1} nat c₁ c₂)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "monad.{0 u} m"},
{"kind": "dep", "name": "pos", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "pos.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "pos"},{"name": "b", "type": "pos"}], "coercion_like": 0, "type": "decidable (@eq.{1} pos a b)"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_bind.{0 u} m"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 4, "uparams": [], "type": "has_coe_t.{1 1} nat format"},
{"kind": "instance", "name": "pos.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} pos"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad.{0 0} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad.{0 0} m"},
{"kind": "dep", "name": "binder_info", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "binder_info.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_repr.{0} binder_info"},
{"kind": "instance", "name": "option.monad", "class": "monad", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "monad.{u_1 u_1} option.{u_1}"},
{"kind": "problem", "class": "has_pure", "max_depth": 2, "steps": 4, "uparams": ["u_1"], "type": "has_pure.{u_1 u_1} option.{u_1}"},
{"kind": "class", "name": "decidable_linear_order", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "problem", "class": "has_seq", "max_depth": 2, "steps": 4, "uparams": ["u_1"], "type": "has_seq.{u_1 u_1} option.{u_1}"},
{"kind": "instance", "name": "decidable_linear_order.to_linear_order", "class": "linear_order", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "decidable_linear_order", "type": "decidable_linear_order.{u} α"}], "coercion_like": 1, "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "dep", "name": "except", "uparams": ["u","v"], "type": "Type u → Type v → Type (max u v)"},
{"kind": "instance", "name": "except.monad", "class": "monad", "from_extends": 0, "uparams": ["u","u_1"], "params": [{"name": "ε", "type": "Type u"}], "coercion_like": 0, "type": "monad.{u_1 (max u u_1)} (except.{u u_1} ε)"},
{"kind": "dep", "name": "decidable_linear_order.le", "uparams": ["u"], "type": "Π (α : Type u), decidable_linear_order.{u} α → α → α → Prop"},
{"kind": "dep", "name": "decidable_linear_order.lt", "uparams": ["u"], "type": "Π (α : Type u), decidable_linear_order.{u} α → α → α → Prop"},
{"kind": "dep", "name": "decidable_linear_order.le_refl", "uparams": ["u"], "type": "∀ (α : Type u) (c : decidable_linear_order.{u} α) (a : α), @decidable_linear_order.le.{u} α c a a"},
{"kind": "dep", "name": "decidable_linear_order.le_trans", "uparams": ["u"], "type": "∀ (α : Type u) (c : decidable_linear_order.{u} α) (a b c_1 : α), @decidable_linear_order.le.{u} α c a b → @decidable_linear_order.le.{u} α c b c_1 → @decidable_linear_order.le.{u} α c a c_1"},
{"kind": "dep", "name": "decidable_linear_order.lt_iff_le_not_le", "uparams": ["u"], "type": "∀ (α : Type u) (c : decidable_linear_order.{u} α) (a b : α), iff (@decidable_linear_order.lt.{u} α c a b) (and (@decidable_linear_order.le.{u} α c a b) (not (@decidable_linear_order.le.{u} α c b a)))"},
{"kind": "dep", "name": "decidable_linear_order.le_antisymm", "uparams": ["u"], "type": "∀ (α : Type u) (c : decidable_linear_order.{u} α) (a b : α), @has_le.le.{u} α (@preorder.to_has_le.{u} α (@preorder.mk.{u} α (@decidable_linear_order.le.{u} α c) (@decidable_linear_order.lt.{u} α c) (@decidable_linear_order.le_refl.{u} α c) (@decidable_linear_order.le_trans.{u} α c) (@decidable_linear_order.lt_iff_le_not_le.{u} α c))) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@preorder.mk.{u} α (@decidable_linear_order.le.{u} α c) (@decidable_linear_order.lt.{u} α c) (@decidable_linear_order.le_refl.{u} α c) (@decidable_linear_order.le_trans.{u} α c) (@decidable_linear_order.lt_iff_le_not_le.{u} α c))) b a → @eq.{u+1} α a b"},
{"kind": "dep", "name": "decidable_linear_order.le_total", "uparams": ["u"], "type": "∀ (α : Type u) (c : decidable_linear_order.{u} α) (a b : α), or (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@partial_order.mk.{u} α (@decidable_linear_order.le.{u} α c) (@decidable_linear_order.lt.{u} α c) (@decidable_linear_order.le_refl.{u} α c) (@decidable_linear_order.le_trans.{u} α c) (@decidable_linear_order.lt_iff_le_not_le.{u} α c) (@decidable_linear_order.le_antisymm.{u} α c)))) a b) (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@partial_order.mk.{u} α (@decidable_linear_order.le.{u} α c) (@decidable_linear_order.lt.{u} α c) (@decidable_linear_order.le_refl.{u} α c) (@decidable_linear_order.le_trans.{u} α c) (@decidable_linear_order.lt_iff_le_not_le.{u} α c) (@decidable_linear_order.le_antisymm.{u} α c)))) b a)"},
{"kind": "instance", "name": "has_lt.lt.decidable", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "decidable_linear_order", "type": "decidable_linear_order.{u} α"},{"name": "a", "type": "α"},{"name": "b", "type": "α"}], "coercion_like": 0, "type": "decidable (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1) (@decidable_linear_order.lt.{u} α _inst_1) (@decidable_linear_order.le_refl.{u} α _inst_1) (@decidable_linear_order.le_trans.{u} α _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1) (@decidable_linear_order.le_antisymm.{u} α _inst_1) (@decidable_linear_order.le_total.{u} α _inst_1))))) a b)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 49, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) 1 (v+1))} (Pi {a : Type.{u}} (a_1 : string), (m a))"},
{"kind": "instance", "name": "option.alternative", "class": "alternative", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "alternative.{u_1 u_1} option.{u_1}"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u","v"], "type": "has_sizeof.{v+1} (m (except.{u u} ε α))"},
{"kind": "dep", "name": "id", "uparams": ["u"], "type": "Π (α : Sort u), α → α"},
{"kind": "instance", "name": "id.monad", "class": "monad", "from_extends": 0, "uparams": ["u"], "params": [], "coercion_like": 0, "type": "monad.{u u} (@id.{u+2} (Type u))"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "instance", "name": "id.monad_run", "class": "monad_run", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "monad_run.{u_1 u_1} (@id.{u_1+2} (Type u_1)) (@id.{u_1+2} (Type u_1))"},
{"kind": "instance", "name": "option.inhabited", "class": "inhabited", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "inhabited.{u+1} (option.{u} α)"},
{"kind": "class", "name": "monad_fail", "uparams": ["u","v"], "params": [{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "instance", "name": "has_le.le.decidable", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "decidable_linear_order", "type": "decidable_linear_order.{u} α"},{"name": "a", "type": "α"},{"name": "b", "type": "α"}], "coercion_like": 0, "type": "decidable (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1) (@decidable_linear_order.lt.{u} α _inst_1) (@decidable_linear_order.le_refl.{u} α _inst_1) (@decidable_linear_order.le_trans.{u} α _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1) (@decidable_linear_order.le_antisymm.{u} α _inst_1) (@decidable_linear_order.le_total.{u} α _inst_1))))) a b)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "monad_fail", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad_fail.{u v} m"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "monad_fail", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad_fail.{u v} m"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 1, "steps": 4, "uparams": ["u","v"], "type": "has_monad_lift_t.{u v v} m n"},
{"kind": "instance", "name": "eq.decidable", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "decidable_linear_order", "type": "decidable_linear_order.{u} α"},{"name": "a", "type": "α"},{"name": "b", "type": "α"}], "coercion_like": 0, "type": "decidable (@eq.{u+1} α a b)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "instance", "name": "monad_fail_lift", "class": "monad_fail", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "m", "type": "Type u → Type v"},{"name": "n", "type": "Type u → Type v"},{"name": "_inst_1", "class": "has_monad_lift", "type": "has_monad_lift.{u v v} m n"},{"name": "_inst_2", "class": "monad_fail", "type": "monad_fail.{u v} m"},{"name": "_inst_3", "class": "monad", "type": "monad.{u v} n"}], "coercion_like": 0, "type": "monad_fail.{u v} n"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 38, "uparams": ["u"], "type": "decidable (eq.{u+1} α a b)"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "instance", "name": "has_le.le.is_total_preorder", "class": "is_total_preorder", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "decidable_linear_order", "type": "decidable_linear_order.{u} α"}], "coercion_like": 0, "type": "is_total_preorder.{u} α (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1)))))"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "instance", "name": "option.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "d", "class": "decidable", "type": "Π (a b : α), decidable (@eq.{u+1} α a b)"},{"name": "a", "type": "option.{u} α"},{"name": "b", "type": "option.{u} α"}], "coercion_like": 0, "type": "decidable (@eq.{u+1} (option.{u} α) a b)"},
{"kind": "ignored_problem", "class": "is_total_preorder", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "is_total_preorder.{u} α (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))))"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 39, "uparams": ["u"], "type": "Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b))"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "functor.{u v} m"},
{"kind": "dep", "name": "expr", "uparams": [], "type": "bool → Type"},
{"kind": "dep", "name": "bool.tt", "uparams": [], "type": "bool"},
{"kind": "instance", "name": "expr.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} (expr bool.tt)"},
{"kind": "instance", "name": "is_strict_weak_order_of_decidable_linear_order", "class": "is_strict_weak_order", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "decidable_linear_order", "type": "decidable_linear_order.{u} α"}], "coercion_like": 0, "type": "is_strict_weak_order.{u} α (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1)))))"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "is_irrefl", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "is_irrefl.{u} α (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))))"},
{"kind": "dep", "name": "except_t", "uparams": ["u","v"], "type": "Type u → (Type u → Type v) → Type u → Type v"},
{"kind": "instance", "name": "except_t.has_monad_lift", "class": "has_monad_lift", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "ε", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "has_monad_lift.{u v v} m (except_t.{u v} ε m)"},
{"kind": "instance", "name": "expr.has_decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "expr bool.tt"},{"name": "b", "type": "expr bool.tt"}], "coercion_like": 0, "type": "decidable (@eq.{1} (expr bool.tt) a b)"},
{"kind": "ignored_problem", "class": "is_trans", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "is_trans.{u} α (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))))"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "is_incomp_trans", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "is_incomp_trans.{u} α (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))))"},
{"kind": "instance", "name": "expr.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [{"name": "elab", "type": "bool"}], "coercion_like": 0, "type": "has_to_string.{0} (expr elab)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "instance", "name": "expr.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [{"name": "elab", "type": "bool"}], "coercion_like": 0, "type": "has_to_format.{0} (expr elab)"},
{"kind": "instance", "name": "is_strict_total_order_of_decidable_linear_order", "class": "is_strict_total_order", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "decidable_linear_order", "type": "decidable_linear_order.{u} α"}], "coercion_like": 0, "type": "is_strict_total_order.{u} α (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1)))))"},
{"kind": "instance", "name": "expr.has_coe_to_fun", "class": "has_coe_to_fun", "from_extends": 0, "uparams": [], "params": [{"name": "elab", "type": "bool"}], "coercion_like": 0, "type": "has_coe_to_fun.{1 1} (expr elab)"},
{"kind": "class", "name": "reflected", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Sort.{u}"},{"name": "a", "is_out": 0, "type": "α"}]},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m'"},
{"kind": "instance", "name": "except_t.monad_functor", "class": "monad_functor", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "ε", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"},{"name": "m'", "type": "Type u → Type v"},{"name": "_inst_2", "class": "monad", "type": "monad.{u v} m'"}], "coercion_like": 0, "type": "monad_functor.{u v v} m m' (except_t.{u v} ε m) (except_t.{u v} ε m')"},
{"kind": "instance", "name": "expr.reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "elab", "type": "bool"},{"name": "e", "type": "expr elab"}], "coercion_like": 0, "type": "@reflected.{1} (expr elab) e"},
{"kind": "instance", "name": "string.reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "s", "type": "string"}], "coercion_like": 0, "type": "@reflected.{1} string s"},
{"kind": "instance", "name": "expr.has_coe", "class": "has_coe", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Sort u"},{"name": "a", "type": "α"}], "coercion_like": 0, "type": "has_coe.{1 1} (@reflected.{u} α a) (expr bool.tt)"},
{"kind": "problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_format.{0} (expr bool.tt)"},
{"kind": "instance", "name": "reflected.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": ["u_1"], "params": [{"name": "α", "type": "Sort u_1"},{"name": "a", "type": "α"}], "coercion_like": 0, "type": "has_to_format.{0} (@reflected.{u_1} α a)"},
{"kind": "dep", "name": "expr.expr.lt_prop", "uparams": [], "type": "expr bool.tt → expr bool.tt → Prop"},
{"kind": "instance", "name": "expr.decidable_rel", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "expr bool.tt"},{"name": "b", "type": "expr bool.tt"}], "coercion_like": 0, "type": "decidable (expr.expr.lt_prop a b)"},
{"kind": "instance", "name": "expr.has_lt", "class": "has_lt", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_lt.{0} (expr bool.tt)"},
{"kind": "problem", "class": "has_coe_to_fun", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_coe_to_fun.{1 1} (expr bool.tt)"},
{"kind": "instance", "name": "except_t.monad", "class": "monad", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "ε", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "monad.{u v} (except_t.{u v} ε m)"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "functor.{u v} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 54, "uparams": ["u","w","v"], "type": "has_sizeof.{(max ((v+1)+1) (u+1) (w+1))} (Pi {α : Type.{v}} (a : ε), (m α))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 54, "uparams": ["u","w","v"], "type": "has_sizeof.{(max ((v+1)+1) (u+1) (w+1))} (Pi {α : Type.{v}} (a : m α) (a : ε -> (m α)), (m α))"},
{"kind": "class", "name": "monad_except", "uparams": ["u","v","w"], "params": [{"name": "ε", "is_out": 1, "type": "Type.{u}"},{"name": "m", "is_out": 0, "type": "Type.{v} -> Type.{w}"}]},
{"kind": "ignored_problem", "class": "monad_except", "max_depth": 0, "steps": 1, "uparams": ["u","w","v"], "type": "monad_except.{u v w} ε m"},
{"kind": "ignored_problem", "class": "monad_except", "max_depth": 0, "steps": 1, "uparams": ["u","w","v"], "type": "monad_except.{u v w} ε m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 25, "uparams": [], "type": "decidable (eq.{1} bool use_first_ex bool.tt)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u_2","u_1"], "type": "has_pure.{u_1 u_2} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u_2","u_1"], "type": "monad.{u_1 u_2} m"},
{"kind": "instance", "name": "except_t.monad_except", "class": "monad_except", "from_extends": 0, "uparams": ["u_1","u_2"], "params": [{"name": "m", "type": "Type u_1 → Type u_2"},{"name": "ε", "type": "Type u_1"},{"name": "_inst_1", "class": "monad", "type": "monad.{u_1 u_2} m"}], "coercion_like": 0, "type": "monad_except.{u_1 u_1 u_2} ε (except_t.{u_1 u_2} ε m)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 57, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} (a : ε -> ε') (a : m α), (m' α))"},
{"kind": "class", "name": "monad_except_adapter", "uparams": ["u","v"], "params": [{"name": "ε", "is_out": 1, "type": "Type.{u}"},{"name": "ε'", "is_out": 1, "type": "Type.{u}"},{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"},{"name": "m'", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "monad_except_adapter", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad_except_adapter.{u v} ε ε' m m'"},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 1, "steps": 4, "uparams": ["u","v"], "type": "monad_functor_t.{u v v} m m' n n'"},
{"kind": "instance", "name": "monad_except_adapter_trans", "class": "monad_except_adapter", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "ε", "type": "Type u"},{"name": "ε'", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "m'", "type": "Type u → Type v"},{"name": "n", "type": "Type u → Type v"},{"name": "n'", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad_functor", "type": "monad_functor.{u v v} m m' n n'"},{"name": "_inst_2", "class": "monad_except_adapter", "type": "monad_except_adapter.{u v} ε ε' m m'"}], "coercion_like": 0, "type": "monad_except_adapter.{u v} ε ε' n n'"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "instance", "name": "except_t.monad_except_adapter", "class": "monad_except_adapter", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "ε", "type": "Type u"},{"name": "ε'", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "monad_except_adapter.{u v} ε ε' (except_t.{u v} ε m) (except_t.{u v} ε' m)"},
{"kind": "ignored_problem", "class": "monad_run", "max_depth": 0, "steps": 1, "uparams": ["u_2","u_1"], "type": "monad_run.{u_1 u_2} out m"},
{"kind": "instance", "name": "except_t.monad_run", "class": "monad_run", "from_extends": 0, "uparams": ["u_1","u_2"], "params": [{"name": "ε", "type": "Type u_1"},{"name": "m", "type": "Type u_1 → Type u_2"},{"name": "out", "type": "Type u_1 → Type u_2"},{"name": "_inst_1", "class": "monad_run", "type": "monad_run.{u_1 u_2} out m"}], "coercion_like": 0, "type": "monad_run.{u_1 u_2} (λ (α : Type u_1), out (except.{u_1 u_1} ε α)) (except_t.{u_1 u_2} ε m)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name n₁ n₂)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 57, "uparams": ["u","v"], "type": "has_sizeof.{(max (u+1) (v+1))} (σ -> (m (prod.{u u} α σ)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 96, "uparams": [], "type": "decidable (and (eq.{1} bool (expr.is_app_of e c) bool.tt) (eq.{1} nat (expr.get_app_num_args e) n))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": ["u","v"], "type": "has_sizeof.{v+1} (m (option.{u} α))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 57, "uparams": ["u","v"], "type": "has_sizeof.{(max (u+1) (v+1))} (ρ -> (m α))"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_3_a (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 4, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 4, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "dep", "name": "reader_t", "uparams": ["u","v"], "type": "Type u → (Type u → Type v) → Type u → Type (max u v)"},
{"kind": "instance", "name": "reader_t.monad", "class": "monad", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "ρ", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "monad.{u (max u v)} (reader_t.{u v} ρ m)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","u_1"], "type": "monad.{u u_1} m"},
{"kind": "instance", "name": "reader_t.has_monad_lift", "class": "has_monad_lift", "from_extends": 0, "uparams": ["u","u_1"], "params": [{"name": "ρ", "type": "Type u"},{"name": "m", "type": "Type u → Type u_1"},{"name": "_inst_2", "class": "monad", "type": "monad.{u u_1} m"}], "coercion_like": 0, "type": "has_monad_lift.{u u_1 (max u u_1)} m (reader_t.{u u_1} ρ m)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 2, "uparams": ["u_2","u_1"], "type": "monad.{u_1 u_2} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u_2","u_1"], "type": "monad.{u_1 u_2} m'"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "instance", "name": "reader_t.monad_functor", "class": "monad_functor", "from_extends": 0, "uparams": ["u_1","u_2"], "params": [{"name": "ρ", "type": "Type u_1"},{"name": "m", "type": "Type u_1 → Type u_2"},{"name": "m'", "type": "Type u_1 → Type u_2"},{"name": "_inst_2", "class": "monad", "type": "monad.{u_1 u_2} m"},{"name": "_inst_3", "class": "monad", "type": "monad.{u_1 u_2} m'"}], "coercion_like": 0, "type": "monad_functor.{u_1 u_2 (max u_1 u_2)} m m' (reader_t.{u_1 u_2} ρ m) (reader_t.{u_1 u_2} ρ m')"},
{"kind": "ignored_problem", "class": "has_orelse", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_orelse.{u v} m"},
{"kind": "dep", "name": "state_t", "uparams": ["u","v"], "type": "Type u → (Type u → Type v) → Type u → Type (max u v)"},
{"kind": "instance", "name": "state_t.monad", "class": "monad", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "σ", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "monad.{u (max u v)} (state_t.{u v} σ m)"},
{"kind": "dep", "name": "option_t", "uparams": ["u","v"], "type": "(Type u → Type v) → Type u → Type v"},
{"kind": "instance", "name": "option_t.monad", "class": "monad", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "monad.{u v} (option_t.{u v} m)"},
{"kind": "ignored_problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "alternative.{u v} m"},
{"kind": "ignored_problem", "class": "has_orelse", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_orelse.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 3, "steps": 7, "uparams": ["u","v"], "type": "has_pure.{u (max u v)} (reader_t.{u v} ρ m)"},
{"kind": "ignored_problem", "class": "has_seq", "max_depth": 3, "steps": 7, "uparams": ["u","v"], "type": "has_seq.{u (max u v)} (reader_t.{u v} ρ m)"},
{"kind": "ignored_problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "alternative.{u v} m"},
{"kind": "ignored_problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "alternative.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 3, "steps": 5, "uparams": ["u","v"], "type": "has_pure.{u (max u v)} (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_seq", "max_depth": 3, "steps": 5, "uparams": ["u","v"], "type": "has_seq.{u (max u v)} (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "alternative.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "instance", "name": "reader_t.alternative", "class": "alternative", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "ρ", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"},{"name": "_inst_2", "class": "alternative", "type": "alternative.{u v} m"}], "coercion_like": 0, "type": "alternative.{u (max u v)} (reader_t.{u v} ρ m)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "monad_except", "max_depth": 0, "steps": 1, "uparams": ["u","u_1","v"], "type": "monad_except.{u_1 u v} ε m"},
{"kind": "instance", "name": "option_t.alternative", "class": "alternative", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "alternative.{u v} (option_t.{u v} m)"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "functor.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "instance", "name": "reader_t.monad_except", "class": "monad_except", "from_extends": 0, "uparams": ["u","v","u_1"], "params": [{"name": "ρ", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"},{"name": "ε", "type": "Type u_1"},{"name": "_inst_2", "class": "monad", "type": "monad.{u v} m"},{"name": "_inst_3", "class": "monad_except", "type": "monad_except.{u_1 u v} ε m"}], "coercion_like": 0, "type": "monad_except.{u_1 u (max u v)} ε (reader_t.{u v} ρ m)"},
{"kind": "instance", "name": "option_t.has_monad_lift", "class": "has_monad_lift", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "has_monad_lift.{u v v} m (option_t.{u v} m)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_sizeof.{v+1} (m ρ)"},
{"kind": "class", "name": "monad_reader", "uparams": ["u","v"], "params": [{"name": "ρ", "is_out": 1, "type": "Type.{u}"},{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 2, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m'"},
{"kind": "ignored_problem", "class": "monad_reader", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad_reader.{u v} ρ m"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 1, "steps": 4, "uparams": ["u","w","v"], "type": "has_monad_lift_t.{u v w} m n"},
{"kind": "instance", "name": "state_t.alternative", "class": "alternative", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "σ", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"},{"name": "_inst_2", "class": "alternative", "type": "alternative.{u v} m"}], "coercion_like": 0, "type": "alternative.{u (max u v)} (state_t.{u v} σ m)"},
{"kind": "instance", "name": "monad_reader_trans", "class": "monad_reader", "from_extends": 0, "uparams": ["u","v","w"], "params": [{"name": "ρ", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "n", "type": "Type u → Type w"},{"name": "_inst_1", "class": "has_monad_lift", "type": "has_monad_lift.{u v w} m n"},{"name": "_inst_2", "class": "monad_reader", "type": "monad_reader.{u v} ρ m"}], "coercion_like": 0, "type": "monad_reader.{u w} ρ n"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 30, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_napp_of e op (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))) bool.tt)"},
{"kind": "instance", "name": "option_t.monad_functor", "class": "monad_functor", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"},{"name": "m'", "type": "Type u → Type v"},{"name": "_inst_2", "class": "monad", "type": "monad.{u v} m'"}], "coercion_like": 0, "type": "monad_functor.{u v v} m m' (option_t.{u v} m) (option_t.{u v} m')"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_coe_t.{u+1 u+1} α (option.{u} α)"},
{"kind": "instance", "name": "reader_t.monad_reader", "class": "monad_reader", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "ρ", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "monad_reader.{u (max u v)} ρ (reader_t.{u v} ρ m)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 60, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} (a : ρ' -> ρ) (a : m α), (m' α))"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "instance", "name": "option_t.monad_except", "class": "monad_except", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "monad_except.{0 u v} punit.{1} (option_t.{u v} m)"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "monad_run", "max_depth": 0, "steps": 1, "uparams": ["u_2","u_1"], "type": "monad_run.{u_1 u_2} out m"},
{"kind": "instance", "name": "option_t.monad_run", "class": "monad_run", "from_extends": 0, "uparams": ["u_1","u_2"], "params": [{"name": "m", "type": "Type u_1 → Type u_2"},{"name": "out", "type": "Type u_1 → Type u_2"},{"name": "_inst_2", "class": "monad_run", "type": "monad_run.{u_1 u_2} out m"}], "coercion_like": 0, "type": "monad_run.{u_1 u_2} (λ (α : Type u_1), out (option.{u_1} α)) (option_t.{u_1 u_2} m)"},
{"kind": "class", "name": "monad_reader_adapter", "uparams": ["u","v"], "params": [{"name": "ρ", "is_out": 1, "type": "Type.{u}"},{"name": "ρ'", "is_out": 1, "type": "Type.{u}"},{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"},{"name": "m'", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "monad_reader_adapter", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad_reader_adapter.{u v} ρ ρ' m m'"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 1, "steps": 4, "uparams": ["u","v"], "type": "monad_functor_t.{u v v} m m' n n'"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "instance", "name": "monad_reader_adapter_trans", "class": "monad_reader_adapter", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "ρ", "type": "Type u"},{"name": "ρ'", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "m'", "type": "Type u → Type v"},{"name": "n", "type": "Type u → Type v"},{"name": "n'", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad_functor", "type": "monad_functor.{u v v} m m' n n'"},{"name": "_inst_2", "class": "monad_reader_adapter", "type": "monad_reader_adapter.{u v} ρ ρ' m m'"}], "coercion_like": 0, "type": "monad_reader_adapter.{u v} ρ ρ' n n'"},
{"kind": "instance", "name": "state_t.has_monad_lift", "class": "has_monad_lift", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "σ", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "has_monad_lift.{u v (max u v)} m (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "instance", "name": "reader_t.monad_reader_adapter", "class": "monad_reader_adapter", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "ρ", "type": "Type u"},{"name": "ρ'", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "monad_reader_adapter.{u (max u v)} ρ ρ' (reader_t.{u v} ρ m) (reader_t.{u v} ρ' m)"},
{"kind": "ignored_problem", "class": "monad_run", "max_depth": 0, "steps": 1, "uparams": ["u","u_1"], "type": "monad_run.{u u_1} out m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 2, "uparams": ["u_2","u_1"], "type": "monad.{u_1 u_2} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u_2","u_1"], "type": "monad.{u_1 u_2} m'"},
{"kind": "instance", "name": "reader_t.monad_run", "class": "monad_run", "from_extends": 0, "uparams": ["u","u_1"], "params": [{"name": "ρ", "type": "Type u"},{"name": "m", "type": "Type u → Type u_1"},{"name": "out", "type": "Type u → Type u_1"},{"name": "_inst_1", "class": "monad_run", "type": "monad_run.{u u_1} out m"}], "coercion_like": 0, "type": "monad_run.{u (max u u_1)} (λ (α : Type u), ρ → out α) (reader_t.{u u_1} ρ m)"},
{"kind": "instance", "name": "state_t.monad_functor", "class": "monad_functor", "from_extends": 0, "uparams": ["u_1","u_2"], "params": [{"name": "σ", "type": "Type u_1"},{"name": "m", "type": "Type u_1 → Type u_2"},{"name": "m'", "type": "Type u_1 → Type u_2"},{"name": "_inst_2", "class": "monad", "type": "monad.{u_1 u_2} m"},{"name": "_inst_3", "class": "monad", "type": "monad.{u_1 u_2} m'"}], "coercion_like": 0, "type": "monad_functor.{u_1 u_2 (max u_1 u_2)} m m' (state_t.{u_1 u_2} σ m) (state_t.{u_1 u_2} σ m')"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "monad_except", "max_depth": 0, "steps": 1, "uparams": ["u","u_1","v"], "type": "monad_except.{u_1 u v} ε m"},
{"kind": "instance", "name": "state_t.monad_except", "class": "monad_except", "from_extends": 0, "uparams": ["u","v","u_1"], "params": [{"name": "σ", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"},{"name": "ε", "type": "Type u_1"},{"name": "_inst_2", "class": "monad_except", "type": "monad_except.{u_1 u v} ε m"}], "coercion_like": 0, "type": "monad_except.{u_1 u (max u v)} ε (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 57, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} (a : state_t.{u u} σ (id.{(u+1)+1} Type.{u}) α), (m α))"},
{"kind": "class", "name": "monad_state", "uparams": ["u","v"], "params": [{"name": "σ", "is_out": 1, "type": "Type.{u}"},{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "monad_state", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad_state.{u v} σ m"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 1, "steps": 4, "uparams": ["u","w","v"], "type": "has_monad_lift_t.{u v w} m n"},
{"kind": "instance", "name": "monad_state_trans", "class": "monad_state", "from_extends": 0, "uparams": ["u","v","w"], "params": [{"name": "σ", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "n", "type": "Type u → Type w"},{"name": "_inst_1", "class": "has_monad_lift", "type": "has_monad_lift.{u v w} m n"},{"name": "_inst_2", "class": "monad_state", "type": "monad_state.{u v} σ m"}], "coercion_like": 0, "type": "monad_state.{u w} σ n"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "instance", "name": "state_t.monad_state", "class": "monad_state", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "σ", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "monad_state.{u (max u v)} σ (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "monad_state", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad_state.{u v} σ m"},
{"kind": "problem", "class": "monad", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "monad.{u u} (id.{(u+1)+1} Type.{u})"},
{"kind": "ignored_problem", "class": "monad_state", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad_state.{u v} σ m"},
{"kind": "ignored_problem", "class": "monad_state", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad_state.{u v} σ m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 60, "uparams": ["u","v"], "type": "has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {σ'' : Type.{u}} {α : Type.{u}} (split : σ' -> (prod.{u u} σ σ'')) (join : σ -> σ'' -> σ') (a : m α), (m' α))"},
{"kind": "class", "name": "monad_state_adapter", "uparams": ["u","v"], "params": [{"name": "σ", "is_out": 1, "type": "Type.{u}"},{"name": "σ'", "is_out": 1, "type": "Type.{u}"},{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"},{"name": "m'", "is_out": 0, "type": "Type.{u} -> Type.{v}"}]},
{"kind": "ignored_problem", "class": "monad_state_adapter", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad_state_adapter.{u v} σ σ' m m'"},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 1, "steps": 4, "uparams": ["u","v"], "type": "monad_functor_t.{u v v} m m' n n'"},
{"kind": "instance", "name": "monad_state_adapter_trans", "class": "monad_state_adapter", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "σ", "type": "Type u"},{"name": "σ'", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "m'", "type": "Type u → Type v"},{"name": "n", "type": "Type u → Type v"},{"name": "n'", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad_functor", "type": "monad_functor.{u v v} m m' n n'"},{"name": "_inst_2", "class": "monad_state_adapter", "type": "monad_state_adapter.{u v} σ σ' m m'"}], "coercion_like": 0, "type": "monad_state_adapter.{u v} σ σ' n n'"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "instance", "name": "state_t.monad_state_adapter", "class": "monad_state_adapter", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "σ", "type": "Type u"},{"name": "σ'", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"}], "coercion_like": 0, "type": "monad_state_adapter.{u (max u v)} σ σ' (state_t.{u v} σ m) (state_t.{u v} σ' m)"},
{"kind": "ignored_problem", "class": "monad_run", "max_depth": 0, "steps": 1, "uparams": ["u_2","u_1"], "type": "monad_run.{u_1 u_2} out m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "instance", "name": "state_t.monad_run", "class": "monad_run", "from_extends": 0, "uparams": ["u_1","u_2"], "params": [{"name": "σ", "type": "Type u_1"},{"name": "m", "type": "Type u_1 → Type u_2"},{"name": "out", "type": "Type u_1 → Type u_2"},{"name": "_inst_1", "class": "monad_run", "type": "monad_run.{u_1 u_2} out m"}], "coercion_like": 0, "type": "monad_run.{u_1 (max u_1 u_2)} (λ (α : Type u_1), σ → out (prod.{u_1 u_1} α σ)) (state_t.{u_1 u_2} σ m)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "problem", "class": "has_to_format", "max_depth": 0, "steps": 7, "uparams": [], "type": "has_to_format.{0} level"},
{"kind": "problem", "class": "has_to_format", "max_depth": 1, "steps": 23, "uparams": [], "type": "has_to_format.{0} (list.{0} level)"},
{"kind": "problem", "class": "has_repr", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_repr.{0} binder_info"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad.{0 0} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_bind.{0 0} m"},
{"kind": "problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} (expr bool.tt)"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : expr bool.tt) (b : expr bool.tt), (decidable (has_lt.lt.{0} (expr bool.tt) expr.has_lt a b))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 27, "uparams": [], "type": "decidable (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} nat (has_zero.zero.{0} nat nat.has_zero)"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 38, "uparams": [], "type": "has_sizeof.{1} bool"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 27, "uparams": [], "type": "decidable (eq.{1} nat n (has_one.one.{0} nat nat.has_one))"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} nat (has_one.one.{0} nat nat.has_one)"},
{"kind": "class", "name": "has_to_pexpr", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Sort.{u}"}]},
{"kind": "ignored_problem", "class": "has_to_pexpr", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_pexpr.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 27, "uparams": [], "type": "decidable (eq.{1} nat (has_mod.mod.{0} nat nat.has_mod n (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))) (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "dep", "name": "bool.ff", "uparams": [], "type": "bool"},
{"kind": "instance", "name": "pexpr.has_to_pexpr", "class": "has_to_pexpr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_pexpr.{1} (expr bool.ff)"},
{"kind": "instance", "name": "expr.has_to_pexpr", "class": "has_to_pexpr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_pexpr.{1} (expr bool.tt)"},
{"kind": "instance", "name": "reflected.has_to_pexpr", "class": "has_to_pexpr", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Sort u"},{"name": "a", "type": "α"}], "coercion_like": 0, "type": "has_to_pexpr.{1} (@reflected.{u} α a)"},
{"kind": "instance", "name": "nat.reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "nat"}], "coercion_like": 0, "type": "@reflected.{1} nat a"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 1, "uparams": [], "type": "reflected.{1} unsigned (unsigned.of_nat' n)"},
{"kind": "instance", "name": "unsigned.reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "unsigned"}], "coercion_like": 0, "type": "@reflected.{1} unsigned a"},
{"kind": "dep", "name": "name.anonymous", "uparams": [], "type": "name"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} name name.anonymous"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 3, "uparams": [], "type": "reflected.{1} (name -> name) (name.mk_string s)"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 1, "uparams": [], "type": "reflected.{1} (name -> name) (name.mk_numeral i)"},
{"kind": "problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": [], "type": "inhabited.{1} (expr bool.tt)"},
{"kind": "instance", "name": "name.reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "name"}], "coercion_like": 0, "type": "@reflected.{1} name a"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 1, "uparams": [], "type": "reflected.{1} (list.{0} α) (list.nil.{0} α)"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 3, "uparams": [], "type": "reflected.{1} ((list.{0} α) -> (list.{0} α)) (list.cons.{0} α h)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 26, "uparams": [], "type": "decidable (has_le.le.{0} nat nat.has_le (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)) (expr.get_app_num_args e))"},
{"kind": "instance", "name": "list.reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "α", "type": "Type"},{"name": "_inst_1", "class": "reflected", "type": "Π (a : α), @reflected.{1} α a"},{"name": "_inst_2", "class": "reflected", "type": "@reflected.{2} Type α"},{"name": "a", "type": "list.{0} α"}], "coercion_like": 0, "type": "@reflected.{1} (list.{0} α) a"},
{"kind": "dep", "name": "environment", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "environment.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_repr.{0} environment"},
{"kind": "dep", "name": "punit.star", "uparams": ["u"], "type": "punit.{u}"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} punit.{1} punit.star.{1}"},
{"kind": "instance", "name": "environment.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} environment"},
{"kind": "instance", "name": "punit.reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "punit.{1}"}], "coercion_like": 0, "type": "@reflected.{1} punit.{1} a"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_string.{u} α"},
{"kind": "ignored_problem", "class": "has_to_string", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_string.{u} α"},
{"kind": "dep", "name": "interaction_monad.result", "uparams": ["u"], "type": "Type → Type u → Type u"},
{"kind": "instance", "name": "interaction_monad.result_has_string", "class": "has_to_string", "from_extends": 0, "uparams": ["u"], "params": [{"name": "state", "type": "Type"},{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_to_string", "type": "has_to_string.{u} α"}], "coercion_like": 0, "type": "has_to_string.{u} (interaction_monad.result.{u} state α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 24, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt (pos.line p) line0)"},
{"kind": "instance", "name": "interaction_monad.monad", "class": "monad", "from_extends": 0, "uparams": ["u_1"], "params": [{"name": "state", "type": "Type"}], "coercion_like": 0, "type": "monad.{u_1 u_1} (λ (α : Type u_1), state → interaction_monad.result.{u_1} state α)"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_to_format.{v} β"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_to_format.{v} β"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool use_first_ex bool.tt)"},
{"kind": "problem", "class": "has_to_format", "max_depth": 0, "steps": 23, "uparams": [], "type": "has_to_format.{0} format"},
{"kind": "instance", "name": "interaction_monad.monad_fail", "class": "monad_fail", "from_extends": 0, "uparams": ["u_1"], "params": [{"name": "state", "type": "Type"}], "coercion_like": 0, "type": "monad_fail.{u_1 u_1} (λ (α : Type u_1), state → interaction_monad.result.{u_1} state α)"},
{"kind": "dep", "name": "tactic_state", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "tactic_state.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} tactic_state"},
{"kind": "problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_format.{0} tactic_state"},
{"kind": "instance", "name": "tactic_state.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_string.{0} tactic_state"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_to_format.{v} β"},
{"kind": "instance", "name": "tactic.alternative", "class": "alternative", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "alternative.{u_1 u_1} (λ (α : Type u_1), tactic_state → interaction_monad.result.{u_1} tactic_state α)"},
{"kind": "problem", "class": "has_orelse", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))"},
{"kind": "problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))"},
{"kind": "instance", "name": "tactic.opt_to_tac", "class": "has_coe", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_coe.{u+1 (max 1 (u+1))} (option.{u} α) (tactic_state → interaction_monad.result.{u} tactic_state α)"},
{"kind": "problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))"},
{"kind": "instance", "name": "tactic.ex_to_tac", "class": "has_coe", "from_extends": 0, "uparams": [], "params": [{"name": "α", "type": "Type"}], "coercion_like": 0, "type": "has_coe.{1 1} (exceptional α) (tactic_state → interaction_monad.result.{0} tactic_state α)"},
{"kind": "class", "name": "has_to_tactic_format", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "expr.has_to_tactic_format", "class": "has_to_tactic_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_tactic_format.{0} (expr bool.tt)"},
{"kind": "ignored_problem", "class": "has_to_tactic_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_tactic_format.{u} α"},
{"kind": "problem", "class": "functor", "max_depth": 2, "steps": 3, "uparams": [], "type": "functor.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))"},
{"kind": "ignored_problem", "class": "has_to_tactic_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_tactic_format.{u} α"},
{"kind": "problem", "class": "has_to_format", "max_depth": 1, "steps": 41, "uparams": [], "type": "has_to_format.{0} (list.{0} format)"},
{"kind": "instance", "name": "list.has_to_tactic_format", "class": "has_to_tactic_format", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_to_tactic_format", "type": "has_to_tactic_format.{u} α"}], "coercion_like": 0, "type": "has_to_tactic_format.{u} (list.{u} α)"},
{"kind": "problem", "class": "has_seq", "max_depth": 2, "steps": 3, "uparams": [], "type": "has_seq.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))"},
{"kind": "ignored_problem", "class": "has_to_tactic_format", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "has_to_tactic_format.{v} β"},
{"kind": "ignored_problem", "class": "has_to_tactic_format", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "has_to_tactic_format.{u} α"},
{"kind": "problem", "class": "has_to_format", "max_depth": 1, "steps": 59, "uparams": [], "type": "has_to_format.{0} (prod.{0 0} format format)"},
{"kind": "instance", "name": "prod.has_to_tactic_format", "class": "has_to_tactic_format", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "_inst_1", "class": "has_to_tactic_format", "type": "has_to_tactic_format.{u} α"},{"name": "_inst_2", "class": "has_to_tactic_format", "type": "has_to_tactic_format.{v} β"}], "coercion_like": 0, "type": "has_to_tactic_format.{(max u v)} (prod.{u v} α β)"},
{"kind": "ignored_problem", "class": "has_to_tactic_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_tactic_format.{u} α"},
{"kind": "ignored_problem", "class": "has_to_tactic_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_tactic_format.{u} α"},
{"kind": "instance", "name": "option.has_to_tactic_format", "class": "has_to_tactic_format", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_to_tactic_format", "type": "has_to_tactic_format.{u} α"}], "coercion_like": 0, "type": "has_to_tactic_format.{u} (option.{u} α)"},
{"kind": "problem", "class": "has_to_tactic_format", "max_depth": 0, "steps": 4, "uparams": [], "type": "has_to_tactic_format.{0} (expr bool.tt)"},
{"kind": "instance", "name": "reflected.has_to_tactic_format", "class": "has_to_tactic_format", "from_extends": 0, "uparams": ["u_1"], "params": [{"name": "α", "type": "Sort u_1"},{"name": "a", "type": "α"}], "coercion_like": 0, "type": "has_to_tactic_format.{0} (@reflected.{u_1} α a)"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_format.{0} α"},
{"kind": "instance", "name": "has_to_format_to_has_to_tactic_format", "class": "has_to_tactic_format", "from_extends": 0, "uparams": [], "params": [{"name": "α", "type": "Type"},{"name": "_inst_1", "class": "has_to_format", "type": "has_to_format.{0} α"}], "coercion_like": 1, "type": "has_to_tactic_format.{0} α"},
{"kind": "dep", "name": "declaration", "uparams": [], "type": "Type"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (exceptional declaration) (tactic_state -> (interaction_monad.result.{0} tactic_state declaration))"},
{"kind": "ignored_problem", "class": "has_to_tactic_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_tactic_format.{u} α"},
{"kind": "problem", "class": "has_to_tactic_format", "max_depth": 1, "steps": 30, "uparams": [], "type": "has_to_tactic_format.{0} format"},
{"kind": "dep", "name": "tactic.transparency", "uparams": [], "type": "Type"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_sizeof.{1} tactic.transparency"},
{"kind": "dep", "name": "tactic.new_goals", "uparams": [], "type": "Type"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_sizeof.{1} tactic.new_goals"},
{"kind": "problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u_1"], "type": "has_bind.{u_1 u_1} (fun (α : Type.{u_1}), (tactic_state -> (interaction_monad.result.{u_1} tactic_state α)))"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type Prop"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 5, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{2} Type Prop) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable (eq.{1} (expr bool.tt) t (lift_t.{1 1} (reflected.{2} Type Prop) (expr bool.tt) (coe_to_lift.{1 1} (reflected.{2} Type Prop) (expr bool.tt) (coe_base.{1 1} (reflected.{2} Type Prop) (expr bool.tt) (expr.has_coe.{2} Type Prop))) `(Prop)))"},
{"kind": "problem", "class": "monad", "max_depth": 0, "steps": 2, "uparams": [], "type": "monad.{0 0} exceptional"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 101, "uparams": [], "type": "decidable (or (eq.{1} bool (expr.is_pi t) bool.tt) (eq.{1} bool (expr.is_let t) bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.has_var_idx b (has_zero.zero.{0} nat nat.has_zero)) bool.tt)"},
{"kind": "problem", "class": "has_append", "max_depth": 0, "steps": 4, "uparams": [], "type": "has_append.{0} (list.{0} (expr bool.tt))"},
{"kind": "problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": [], "type": "has_pure.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))"},
{"kind": "problem", "class": "monad_fail", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad_fail.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name (expr.local_uniq_name h) (expr.local_uniq_name hi))"},
{"kind": "problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": [], "type": "alternative.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_app_of e n) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 26, "uparams": [], "type": "decidable (eq.{1} nat ng (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "problem", "class": "has_orelse", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_orelse.{u u} (fun (α : Type.{u}), (tactic_state -> (interaction_monad.result.{u} tactic_state α)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool progress bool.tt)"},
{"kind": "instance", "name": "tactic.andthen_seq", "class": "has_andthen", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_andthen.{0 0 0} (tactic_state → interaction_monad.result.{0} tactic_state punit.{1}) (tactic_state → interaction_monad.result.{0} tactic_state punit.{1}) (tactic_state → interaction_monad.result.{0} tactic_state punit.{1})"},
{"kind": "instance", "name": "tactic.andthen_seq_focus", "class": "has_andthen", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_andthen.{0 0 0} (tactic_state → interaction_monad.result.{0} tactic_state punit.{1}) (list.{0} (tactic_state → interaction_monad.result.{0} tactic_state punit.{1})) (tactic_state → interaction_monad.result.{0} tactic_state punit.{1})"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (tactic.is_trace_enabled_for n) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 26, "uparams": [], "type": "decidable (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 58, "uparams": [], "type": "decidable (not (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type name"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (bor (tactic.apply_cfg.auto_param cfg) (tactic.apply_cfg.opt_param cfg)) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (tactic.apply_cfg.opt_param cfg) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (tactic.apply_cfg.auto_param cfg) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (tactic.apply_cfg.opt_param cfg) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (tactic.apply_cfg.auto_param cfg) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool b bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool d bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_local_constant e) bool.tt)"},
{"kind": "problem", "class": "has_to_pexpr", "max_depth": 0, "steps": 3, "uparams": [], "type": "has_to_pexpr.{1} (expr bool.ff)"},
{"kind": "problem", "class": "has_to_pexpr", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_to_pexpr.{1} (expr bool.tt)"},
{"kind": "problem", "class": "functor", "max_depth": 2, "steps": 3, "uparams": ["u_1"], "type": "functor.{u_1 u_1} (fun (α : Type.{u_1}), (tactic_state -> (interaction_monad.result.{u_1} tactic_state α)))"},
{"kind": "problem", "class": "inhabited", "max_depth": 0, "steps": 7, "uparams": [], "type": "inhabited.{1} name"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 77, "uparams": [], "type": "decidable (or (eq.{1} bool (list.empty.{0} name ids) bool.tt) (eq.{1} name (list.head.{0} name name.inhabited ids) (name.mk_string (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool (environment.contains env (mk_str_name base (has_append.append.{0} string string.has_append (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (repr.{0} nat nat.has_repr i)))) bool.tt))"},
{"kind": "problem", "class": "has_append", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_append.{0} name"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool zeta_reduce bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 58, "uparams": [], "type": "decidable (not (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_local_constant h) bool.tt)"},
{"kind": "dep", "name": "task", "uparams": ["u"], "type": "Type u → Type u"},
{"kind": "instance", "name": "task.monad", "class": "monad", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "monad.{u_1 u_1} task.{u_1}"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 1, "steps": 107, "uparams": [], "type": "has_sizeof.{1} (list.{0} nat)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool (environment.is_inductive env I) bool.tt))"},
{"kind": "problem", "class": "monad", "max_depth": 0, "steps": 4, "uparams": [], "type": "monad.{0 0} option.{0}"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 4, "uparams": [], "type": "has_coe_t.{1 1} (option.{0} name) (tactic_state -> (interaction_monad.result.{0} tactic_state name))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_false t) bool.tt)"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_format.{0} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_app t) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (list.empty.{0} name ns) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 26, "uparams": [], "type": "decidable (eq.{1} nat (list.length.{0} (expr bool.tt) args) arity)"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 4, "uparams": [], "type": "has_coe_t.{1 1} (option.{0} (prod.{0 0} (expr bool.tt) (expr bool.tt))) (tactic_state -> (interaction_monad.result.{0} tactic_state (prod.{0 0} (expr bool.tt) (expr bool.tt))))"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 4, "uparams": [], "type": "has_coe_t.{1 1} (option.{0} (expr bool.tt)) (tactic_state -> (interaction_monad.result.{0} tactic_state (expr bool.tt)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (format.is_nil f₁) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (format.is_nil f₂) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 35, "uparams": [], "type": "decidable (not (eq.{1} pos (lean.parser_state.cur_pos s) (lean.parser_state.cur_pos s')))"},
{"kind": "problem", "class": "has_to_format", "max_depth": 1, "steps": 37, "uparams": [], "type": "has_to_format.{0} (list.{0} nat)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 24, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) (list.length.{0} nat ds))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt lhs)) (expr.const_name bool.tt (expr.get_app_fn bool.tt rhs)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_napp_of type (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (has_one.one.{0} nat nat.has_one)) bool.tt)"},
{"kind": "dep", "name": "param_info", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "param_info.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} param_info"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (name_set.contains s r) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (environment.contains env (mk_str_name (expr.const_name bool.tt (expr.get_app_fn bool.tt lhs)) (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))) bool.tt)"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 1, "steps": 51, "uparams": [], "type": "has_sizeof.{1} (list.{0} param_info)"},
{"kind": "dep", "name": "lean.parser_state", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "lean.parser.alternative", "class": "alternative", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "alternative.{0 0} (λ (α : Type), lean.parser_state → interaction_monad.result.{0} lean.parser_state α)"},
{"kind": "ignored_problem", "class": "has_orelse", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_orelse.{u v} f"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} f"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (name_set.contains s r) bool.tt)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} f"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "has_pure.{u v} f"},
{"kind": "problem", "class": "has_orelse", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_orelse.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))"},
{"kind": "problem", "class": "has_seq", "max_depth": 2, "steps": 3, "uparams": [], "type": "has_seq.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))"},
{"kind": "problem", "class": "has_to_format", "max_depth": 1, "steps": 19, "uparams": [], "type": "has_to_format.{0} (list.{0} param_info)"},
{"kind": "problem", "class": "functor", "max_depth": 2, "steps": 3, "uparams": [], "type": "functor.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 26, "uparams": [], "type": "decidable (eq.{1} nat nparams (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "problem", "class": "monad", "max_depth": 0, "steps": 2, "uparams": [], "type": "monad.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))"},
{"kind": "problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": [], "type": "alternative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))"},
{"kind": "problem", "class": "has_seq_right", "max_depth": 2, "steps": 3, "uparams": [], "type": "has_seq_right.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))"},
{"kind": "dep", "name": "fun_info", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "fun_info.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} fun_info"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 3, "steps": 181, "uparams": [], "type": "decidable (and (eq.{1} bool (environment.is_constructor_app env lhs) bool.tt) (and (eq.{1} bool (environment.is_constructor_app env rhs) bool.tt) (not (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt lhs)) (expr.const_name bool.tt (expr.get_app_fn bool.tt rhs))))))"},
{"kind": "instance", "name": "lean.parser.has_coe", "class": "has_coe", "from_extends": 0, "uparams": [], "params": [{"name": "α", "type": "Type"}], "coercion_like": 0, "type": "has_coe.{1 1} (tactic_state → interaction_monad.result.{0} tactic_state α) (lean.parser_state → interaction_monad.result.{0} lean.parser_state α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_app lhs) bool.tt)"},
{"kind": "dep", "name": "subsingleton_info", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "subsingleton_info.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} subsingleton_info"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "dep", "name": "user_attribute_cache_cfg", "uparams": [], "type": "Type → Type"},
{"kind": "dep", "name": "user_attribute_cache_cfg.mk", "uparams": [], "type": "Π (cache_ty : Type), (list.{0} name → tactic_state → interaction_monad.result.{0} tactic_state cache_ty) → list.{0} name → user_attribute_cache_cfg cache_ty"},
{"kind": "dep", "name": "has_pure.pure", "uparams": ["u","v"], "type": "Π (f : Type u → Type v), has_pure.{u v} f → Π (α : Type u), α → f α"},
{"kind": "dep", "name": "list.nil", "uparams": ["u"], "type": "Π (T : Type u), list.{u} T"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} (user_attribute_cache_cfg punit.{1}) (user_attribute_cache_cfg.mk punit.{1} (fun (_x : list.{0} name), (has_pure.pure.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) tactic.alternative.{0})) punit.{1} punit.star.{1})) (list.nil.{0} name))"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{1} (user_attribute_cache_cfg punit.{1}) (user_attribute_cache_cfg.mk punit.{1} (fun (_x : list.{0} name), (has_pure.pure.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) tactic.alternative.{0})) punit.{1} punit.star.{1})) (list.nil.{0} name))) (expr bool.tt)"},
{"kind": "problem", "class": "has_pure", "max_depth": 2, "steps": 3, "uparams": [], "type": "has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))"},
{"kind": "problem", "class": "monad", "max_depth": 0, "steps": 2, "uparams": ["u_1"], "type": "monad.{u_1 u_1} (fun (α : Type.{u_1}), (tactic_state -> (interaction_monad.result.{u_1} tactic_state α)))"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state punit.{1})) (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1})"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{1} (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state punit.{1})) (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1})) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (_private.2952678747.is_next_explicit ps) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_app lhs) bool.tt)"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_coe_t.{1 1} nat (option.{0} nat)"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{1} β a) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_app e) bool.tt)"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 1, "uparams": [], "type": "reflected.{2} Type β"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 1, "uparams": [], "type": "reflected.{2} Type β"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{1} β val) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 24, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 39, "uparams": [], "type": "decidable (not (eq.{1} name n (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_pi t_type) bool.tt)"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 2, "steps": 124, "uparams": [], "type": "has_sizeof.{1} (list.{0} (option.{0} name))"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 1, "uparams": [], "type": "reflected.{2} Type (tactic_state -> (interaction_monad.result.{0} tactic_state α))"},
{"kind": "dep", "name": "user_attribute", "uparams": [], "type": "Type → Type → Type"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type (user_attribute name_set punit.{1})"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : punit.{1}), (reflected.{1} punit.{1} a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (interactive.loc.include_goal l) bool.tt)"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 3, "uparams": [], "type": "reflected.{1} (user_attribute name_set punit.{1}) (user_attribute.mk name_set punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.none.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (option.none.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (user_attribute_cache_cfg.mk name_set (fun (ns : list.{0} name), (has_pure.pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (applicative.to_has_pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_applicative.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state))) name_set (name_set.of_list ns))) (list.nil.{0} name)) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{2} Type (user_attribute name_set punit.{1})) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{1} (user_attribute name_set punit.{1}) (user_attribute.mk name_set punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.none.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (option.none.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (user_attribute_cache_cfg.mk name_set (fun (ns : list.{0} name), (has_pure.pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (applicative.to_has_pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_applicative.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state))) name_set (name_set.of_list ns))) (list.nil.{0} name)) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (interactive.loc.include_goal l) bool.tt)"},
{"kind": "problem", "class": "has_append", "max_depth": 0, "steps": 4, "uparams": [], "type": "has_append.{0} (list.{0} (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})))"},
{"kind": "problem", "class": "has_seq_left", "max_depth": 2, "steps": 3, "uparams": [], "type": "has_seq_left.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type name_set"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool rec bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 39, "uparams": [], "type": "decidable (not (eq.{1} name n (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool use_default bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool rec bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (list.empty.{0} format f₁) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (list.empty.{0} format f₂) bool.tt)"},
{"kind": "problem", "class": "has_append", "max_depth": 0, "steps": 4, "uparams": [], "type": "has_append.{0} (list.{0} format)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 26, "uparams": [], "type": "decidable (eq.{1} nat (environment.inductive_num_indices env I_name) (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (environment.is_recursive env I_name) bool.tt)"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type string"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type format"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (environment.is_recursive env I_name) bool.tt)"},
{"kind": "problem", "class": "has_append", "max_depth": 0, "steps": 4, "uparams": [], "type": "has_append.{0} (list.{0} name)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (list.empty.{0} format f₁) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (list.empty.{0} format f₂) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 34, "uparams": [], "type": "decidable (not (eq.{1} (expr bool.tt) e' e))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_mem.{0 0} nat (list.{0} nat)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 52, "uparams": [], "type": "decidable (has_mem.mem.{0 0} nat (list.{0} nat) (list.has_mem.{0} nat) p ps)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 90, "uparams": [], "type": "decidable (not (has_mem.mem.{0 0} nat (list.{0} nat) (list.has_mem.{0} nat) p ps))"},
{"kind": "dep", "name": "occurrences", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "occurrences.inhabited", "class": "inhabited", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "inhabited.{1} occurrences"},
{"kind": "problem", "class": "has_repr", "max_depth": 1, "steps": 23, "uparams": [], "type": "has_repr.{0} (list.{0} nat)"},
{"kind": "instance", "name": "occurrences.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_repr.{0} occurrences"},
{"kind": "instance", "name": "occurrences.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_format.{0} occurrences"},
{"kind": "dep", "name": "tactic.apply_cfg", "uparams": [], "type": "Type"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_sizeof.{1} tactic.apply_cfg"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_sizeof.{1} occurrences"},
{"kind": "dep", "name": "simp_lemmas", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "simp_lemmas.has_to_tactic_format", "class": "has_to_tactic_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_tactic_format.{0} simp_lemmas"},
{"kind": "dep", "name": "tactic.dsimp_config", "uparams": [], "type": "Type"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_sizeof.{1} tactic.dsimp_config"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_app_of e c) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name (name.get_prefix (expr.const_name bool.tt (expr.get_app_fn bool.tt e))) c)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (_private.477865211.is_delta_target e cs) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_local_constant h) bool.ff)"},
{"kind": "dep", "name": "tactic.simp_config", "uparams": [], "type": "Type"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_sizeof.{1} tactic.simp_config"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_napp_of t (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (has_one.one.{0} nat nat.has_one)) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_arrow t) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool use_hyps bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (bor (expr.is_pi t) (expr.is_let t)) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_pi new_t) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 134, "uparams": [], "type": "decidable (and (eq.{1} bool use_ns bool.tt) (not (eq.{1} bool (list.empty.{0} name ns) bool.tt)))"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type (user_attribute simp_lemmas punit.{1})"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 2, "steps": 8, "uparams": [], "type": "reflected.{1} (user_attribute simp_lemmas punit.{1}) (user_attribute.mk simp_lemmas punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.none.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (option.none.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (user_attribute_cache_cfg.mk simp_lemmas (fun (ns : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) simp_lemmas simp_lemmas (tactic.to_simp_lemmas simp_lemmas.mk ns) (fun (s : simp_lemmas), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) simp_lemmas simp_lemmas (list.mfoldl.{0 0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state) simp_lemmas name (fun (s : simp_lemmas) (attr_name : name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (list.{0} name) simp_lemmas (attribute.get_instances attr_name) (tactic.to_simp_lemmas s))) s attr_deps) (has_pure.pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (applicative.to_has_pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_applicative.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state))) simp_lemmas))))) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) attr_deps)) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{2} Type (user_attribute simp_lemmas punit.{1})) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{1} (user_attribute simp_lemmas punit.{1}) (user_attribute.mk simp_lemmas punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.none.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (option.none.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (user_attribute_cache_cfg.mk simp_lemmas (fun (ns : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) simp_lemmas simp_lemmas (tactic.to_simp_lemmas simp_lemmas.mk ns) (fun (s : simp_lemmas), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) simp_lemmas simp_lemmas (list.mfoldl.{0 0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state) simp_lemmas name (fun (s : simp_lemmas) (attr_name : name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (list.{0} name) simp_lemmas (attribute.get_instances attr_name) (tactic.to_simp_lemmas s))) s attr_deps) (has_pure.pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (applicative.to_has_pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_applicative.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state))) simp_lemmas))))) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) attr_deps)) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name attr_name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type simp_lemmas"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool no_dflt bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool (expr.alpha_eqv new_e e) bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool (expr.alpha_eqv new_e e) bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (name_set.empty s) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_local_constant e) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.alpha_eqv h_val h) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "Pi (a : expr bool.tt), (decidable (eq.{1} bool (name_set.contains (_private.3046988405.remove_deps s t) (expr.local_uniq_name a)) bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 40, "uparams": [], "type": "decidable (not (eq.{1} (option.{0} (expr bool.tt)) (tactic.simp_all_entry.pr e) (option.none.{0} (expr bool.tt))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool m bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 40, "uparams": [], "type": "decidable (not (eq.{1} (option.{0} (expr bool.tt)) (tactic.simp_all_entry.pr e) (option.none.{0} (expr bool.tt))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 171, "uparams": [], "type": "decidable (or (eq.{1} bool (tactic.simp_config.fail_if_unchanged cfg) bool.ff) (or (eq.{1} bool target_changed bool.tt) (eq.{1} bool (list.any.{0} tactic.simp_all_entry r (fun (e : tactic.simp_all_entry), (decidable.to_bool (not (eq.{1} (option.{0} (expr bool.tt)) (tactic.simp_all_entry.pr e) (option.none.{0} (expr bool.tt)))) (ne.decidable.{1} (option.{0} (expr bool.tt)) (option.decidable_eq.{0} (expr bool.tt) expr.has_decidable_eq) (tactic.simp_all_entry.pr e) (option.none.{0} (expr bool.tt)))))) bool.tt)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.alpha_eqv h_type new_h_type) bool.tt)"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} Prop false"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{1} Prop false) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable (eq.{1} (expr bool.tt) new_h_type (lift_t.{1 1} (reflected.{1} Prop false) (expr bool.tt) (coe_to_lift.{1 1} (reflected.{1} Prop false) (expr bool.tt) (coe_base.{1 1} (reflected.{1} Prop false) (expr bool.tt) (expr.has_coe.{1} Prop false))) `(false)))"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_coe_t.{1 1} (expr bool.tt) (option.{0} (expr bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 78, "uparams": [], "type": "decidable (and (eq.{1} bool (expr.is_constant bool.tt e) bool.tt) (eq.{1} name (list.ilast.{0} name name.inhabited (name.components (expr.const_name bool.tt e))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 6, "uparams": [], "type": "reflected.{1} string acc"},
{"kind": "ignored_problem", "class": "has_to_pexpr", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_pexpr.{1} (reflected.{1} string acc)"},
{"kind": "problem", "class": "has_bind", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_bind.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 6, "uparams": [], "type": "reflected.{1} string acc"},
{"kind": "ignored_problem", "class": "has_to_pexpr", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_pexpr.{1} (reflected.{1} string acc)"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 6, "uparams": [], "type": "reflected.{1} string acc"},
{"kind": "ignored_problem", "class": "has_to_pexpr", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_pexpr.{1} (reflected.{1} string acc)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 16, "uparams": [], "type": "decidable (eq.{1} char hd (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))"},
{"kind": "problem", "class": "monad_fail", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad_fail.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 16, "uparams": [], "type": "decidable (eq.{1} char a_hd (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 16, "uparams": [], "type": "decidable (eq.{1} char a_hd (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 16, "uparams": [], "type": "decidable (eq.{1} char a_tl_hd (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 6, "uparams": [], "type": "reflected.{1} string acc"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{1} string acc) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 6, "uparams": [], "type": "reflected.{1} string acc"},
{"kind": "ignored_problem", "class": "has_to_pexpr", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_pexpr.{1} (reflected.{1} string acc)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 16, "uparams": [], "type": "decidable (eq.{1} char hd (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 16, "uparams": [], "type": "decidable (eq.{1} char a_hd (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 16, "uparams": [], "type": "decidable (eq.{1} char a_tl_hd (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 2, "steps": 127, "uparams": [], "type": "has_sizeof.{1} (option.{0} (list.{0} name))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 39, "uparams": [], "type": "decidable (not (eq.{1} name n (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "dep", "name": "cc_state", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "cc_state.has_to_tactic_format", "class": "has_to_tactic_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_tactic_format.{0} cc_state"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable (eq.{1} (expr bool.tt) (cc_state.next s e) f)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable (eq.{1} (expr bool.tt) (cc_state.next s e) e)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.alpha_eqv (cc_state.next s c) first) bool.tt)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad.{0 0} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_bind.{0 0} m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_app e) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (cc_state.inconsistent s) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool b bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool dbg bool.tt)"},
{"kind": "problem", "class": "has_to_tactic_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_tactic_format.{0} cc_state"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 26, "uparams": [], "type": "decidable (eq.{1} nat (list.length.{0} name (environment.constructors_of env I)) (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "problem", "class": "has_to_tactic_format", "max_depth": 1, "steps": 26, "uparams": [], "type": "has_to_tactic_format.{0} nat"},
{"kind": "problem", "class": "has_to_tactic_format", "max_depth": 2, "steps": 18, "uparams": [], "type": "has_to_tactic_format.{0} (list.{0} level)"},
{"kind": "problem", "class": "has_to_tactic_format", "max_depth": 1, "steps": 9, "uparams": [], "type": "has_to_tactic_format.{0} (list.{0} (expr bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool b bool.tt)"},
{"kind": "dep", "name": "tactic.pattern", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "tactic.has_to_tactic_format", "class": "has_to_tactic_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_tactic_format.{0} tactic.pattern"},
{"kind": "problem", "class": "has_to_format", "max_depth": 0, "steps": 3, "uparams": [], "type": "has_to_format.{0} (expr bool.ff)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool success bool.tt))"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type (list.{0} (expr bool.ff))"},
{"kind": "dep", "name": "derive_handler", "uparams": [], "type": "Type"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type derive_handler"},
{"kind": "problem", "class": "reflected", "max_depth": 1, "steps": 9, "uparams": [], "type": "Pi (a : list.{0} (expr bool.ff)), (reflected.{1} (list.{0} (expr bool.ff)) a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_constant_of bool.ff p cls) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (environment.is_inductive env n) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool univ_poly bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 24, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt i (environment.inductive_num_params env n))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 102, "uparams": [], "type": "decidable (and (eq.{1} bool (declaration.is_trusted decl) bool.tt) (eq.{1} bool (declaration.is_trusted cls_decl) bool.tt))"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} bool bool.ff"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} bool bool.tt"},
{"kind": "instance", "name": "bool.has_reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "bool"}], "coercion_like": 0, "type": "@reflected.{1} bool a"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 4, "uparams": [], "type": "reflected.{1} α _p.1"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 3, "uparams": [], "type": "reflected.{1} β _p.2"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 3, "uparams": [], "type": "reflected.{1} (α -> β -> (prod.{0 0} α β)) (prod.mk.{0 0} α β)"},
{"kind": "instance", "name": "prod.has_reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "α", "type": "Type"},{"name": "a", "class": "reflected", "type": "Π (a : α), @reflected.{1} α a"},{"name": "β", "type": "Type"},{"name": "a", "class": "reflected", "type": "Π (a : β), @reflected.{1} β a"},{"name": "a", "class": "reflected", "type": "@reflected.{2} Type α"},{"name": "a", "class": "reflected", "type": "@reflected.{2} Type β"},{"name": "a", "type": "prod.{0 0} α β"}], "coercion_like": 0, "type": "@reflected.{1} (prod.{0 0} α β) a"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 4, "uparams": [], "type": "reflected.{1} α _p.1"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 3, "uparams": [], "type": "reflected.{1} (α -> (sum.{0 0} α β)) (sum.inl.{0 0} α β)"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 3, "uparams": [], "type": "reflected.{1} β _p.2"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 3, "uparams": [], "type": "reflected.{1} (β -> (sum.{0 0} α β)) (sum.inr.{0 0} α β)"},
{"kind": "instance", "name": "sum.has_reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "α", "type": "Type"},{"name": "a", "class": "reflected", "type": "Π (a : α), @reflected.{1} α a"},{"name": "β", "type": "Type"},{"name": "a", "class": "reflected", "type": "Π (a : β), @reflected.{1} β a"},{"name": "a", "class": "reflected", "type": "@reflected.{2} Type α"},{"name": "a", "class": "reflected", "type": "@reflected.{2} Type β"},{"name": "a", "type": "sum.{0 0} α β"}], "coercion_like": 0, "type": "@reflected.{1} (sum.{0 0} α β) a"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 1, "uparams": [], "type": "reflected.{1} (option.{0} α) (option.none.{0} α)"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 2, "uparams": [], "type": "reflected.{1} α _p.1"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 1, "uparams": [], "type": "reflected.{1} (α -> (option.{0} α)) (option.some.{0} α)"},
{"kind": "instance", "name": "option.has_reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "α", "type": "Type"},{"name": "a", "class": "reflected", "type": "Π (a : α), @reflected.{1} α a"},{"name": "a", "class": "reflected", "type": "@reflected.{2} Type α"},{"name": "a", "type": "option.{0} α"}], "coercion_like": 0, "type": "@reflected.{1} (option.{0} α) a"},
{"kind": "dep", "name": "interactive.loc", "uparams": [], "type": "Type"},
{"kind": "dep", "name": "interactive.loc.wildcard", "uparams": [], "type": "interactive.loc"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} interactive.loc interactive.loc.wildcard"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 2, "steps": 14, "uparams": [], "type": "reflected.{1} (list.{0} (option.{0} name)) _p.1"},
{"kind": "dep", "name": "interactive.loc.ns", "uparams": [], "type": "list.{0} (option.{0} name) → interactive.loc"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} ((list.{0} (option.{0} name)) -> interactive.loc) interactive.loc.ns"},
{"kind": "instance", "name": "interactive.loc.has_reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "interactive.loc"}], "coercion_like": 0, "type": "@reflected.{1} interactive.loc a"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 10, "uparams": [], "type": "reflected.{1} nat _p.1"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 10, "uparams": [], "type": "reflected.{1} nat _p.2"},
{"kind": "dep", "name": "pos.mk", "uparams": [], "type": "nat → nat → pos"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} (nat -> nat -> pos) pos.mk"},
{"kind": "instance", "name": "pos.has_reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "pos"}], "coercion_like": 0, "type": "@reflected.{1} pos a"},
{"kind": "dep", "name": "hinst_lemma", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "hinst_lemma.has_to_tactic_format", "class": "has_to_tactic_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_tactic_format.{0} hinst_lemma"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (format.is_nil r) bool.tt)"},
{"kind": "dep", "name": "hinst_lemmas", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "hinst_lemmas.has_to_tactic_format", "class": "has_to_tactic_format", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_tactic_format.{0} hinst_lemmas"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool p bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 29, "uparams": [], "type": "decidable (eq.{1} tactic.tag tag (list.nil.{0} name))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (bnot (list.empty.{0} (expr bool.tt) gs)) bool.tt)"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type (user_attribute hinst_lemmas punit.{1})"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (list.empty.{0} name new_tag) bool.tt)"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 15, "uparams": [], "type": "reflected.{1} (user_attribute hinst_lemmas punit.{1}) (user_attribute.mk hinst_lemmas punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.some.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (n : name) (_x : nat) (_x : bool), (has_orelse.orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (alternative.to_has_orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) tactic.alternative.{0}) punit.{1} (has_bind.and_then.{0 0} hinst_lemmas punit.{1} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (to_hinst_lemmas_core tactic.transparency.reducible as_simp (list.cons.{0} name n (list.nil.{0} name)) hinst_lemmas.mk) tactic.skip) (tactic.fail.{0 0} punit.{1} format format.has_to_format (has_append.append.{0} format format.has_append (has_append.append.{0} format format.has_append (to_fmt.{0} string string.has_to_format (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (to_fmt.{0} name name.has_to_format n)) (to_fmt.{0} string string.has_to_format (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))) (option.some.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (_x : name) (_x : bool), tactic.skip)) (user_attribute_cache_cfg.mk hinst_lemmas (fun (ns : list.{0} name), (to_hinst_lemmas_core tactic.transparency.reducible as_simp ns hinst_lemmas.mk)) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (list.nil.{0} name))) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{2} Type (user_attribute hinst_lemmas punit.{1})) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{1} (user_attribute hinst_lemmas punit.{1}) (user_attribute.mk hinst_lemmas punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.some.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (n : name) (_x : nat) (_x : bool), (has_orelse.orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (alternative.to_has_orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) tactic.alternative.{0}) punit.{1} (has_bind.and_then.{0 0} hinst_lemmas punit.{1} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (to_hinst_lemmas_core tactic.transparency.reducible as_simp (list.cons.{0} name n (list.nil.{0} name)) hinst_lemmas.mk) tactic.skip) (tactic.fail.{0 0} punit.{1} format format.has_to_format (has_append.append.{0} format format.has_append (has_append.append.{0} format format.has_append (to_fmt.{0} string string.has_to_format (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (to_fmt.{0} name name.has_to_format n)) (to_fmt.{0} string string.has_to_format (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))) (option.some.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (_x : name) (_x : bool), tactic.skip)) (user_attribute_cache_cfg.mk hinst_lemmas (fun (ns : list.{0} name), (to_hinst_lemmas_core tactic.transparency.reducible as_simp ns hinst_lemmas.mk)) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (list.nil.{0} name))) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))) (expr bool.tt)"},
{"kind": "problem", "class": "reflected", "max_depth": 1, "steps": 12, "uparams": [], "type": "Pi (a : option.{0} name), (reflected.{1} (option.{0} name) a)"},
{"kind": "problem", "class": "reflected", "max_depth": 1, "steps": 17, "uparams": [], "type": "Pi (a : list.{0} name), (reflected.{1} (list.{0} name) a)"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type (user_attribute punit.{1} punit.{1})"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{2} Type (user_attribute punit.{1} punit.{1})) (expr bool.tt)"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 9, "uparams": [], "type": "Pi (a : name), (reflected.{1} name a)"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 13, "uparams": [], "type": "Pi (a : expr bool.ff), (reflected.{1} (expr bool.ff) a)"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 2, "steps": 43, "uparams": [], "type": "reflected.{1} (user_attribute hinst_lemmas punit.{1}) (user_attribute.mk hinst_lemmas punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.some.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (n : name) (_x : nat) (_x : bool), (has_orelse.orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (alternative.to_has_orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) tactic.alternative.{0}) punit.{1} (has_bind.and_then.{0 0} hinst_lemmas punit.{1} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (to_hinst_lemmas_core tactic.transparency.reducible bool.ff (list.cons.{0} name n (list.nil.{0} name)) hinst_lemmas.mk) tactic.skip) (tactic.fail.{0 0} punit.{1} format format.has_to_format (has_append.append.{0} format format.has_append (has_append.append.{0} format format.has_append (to_fmt.{0} string string.has_to_format (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (to_fmt.{0} name name.has_to_format n)) (to_fmt.{0} string string.has_to_format (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))) (option.some.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (_x : name) (_x : bool), tactic.skip)) (user_attribute_cache_cfg.mk hinst_lemmas (fun (ns : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) hinst_lemmas hinst_lemmas (to_hinst_lemmas_core tactic.transparency.reducible bool.ff ns hinst_lemmas.mk) (fun (hs₁ : hinst_lemmas), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) hinst_lemmas hinst_lemmas (merge_hinst_lemma_attrs tactic.transparency.reducible bool.ff attr_names hs₁) (merge_hinst_lemma_attrs tactic.transparency.reducible bool.tt simp_attr_names))))) (has_append.append.{0} (list.{0} name) (list.has_append.{0} name) (has_append.append.{0} (list.{0} name) (list.has_append.{0} name) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (list.nil.{0} name)) attr_names) simp_attr_names)) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 1, "steps": 6, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{1} (user_attribute hinst_lemmas punit.{1}) (user_attribute.mk hinst_lemmas punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.some.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (n : name) (_x : nat) (_x : bool), (has_orelse.orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (alternative.to_has_orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) tactic.alternative.{0}) punit.{1} (has_bind.and_then.{0 0} hinst_lemmas punit.{1} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (to_hinst_lemmas_core tactic.transparency.reducible bool.ff (list.cons.{0} name n (list.nil.{0} name)) hinst_lemmas.mk) tactic.skip) (tactic.fail.{0 0} punit.{1} format format.has_to_format (has_append.append.{0} format format.has_append (has_append.append.{0} format format.has_append (to_fmt.{0} string string.has_to_format (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (to_fmt.{0} name name.has_to_format n)) (to_fmt.{0} string string.has_to_format (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))) (option.some.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (_x : name) (_x : bool), tactic.skip)) (user_attribute_cache_cfg.mk hinst_lemmas (fun (ns : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) hinst_lemmas hinst_lemmas (to_hinst_lemmas_core tactic.transparency.reducible bool.ff ns hinst_lemmas.mk) (fun (hs₁ : hinst_lemmas), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) hinst_lemmas hinst_lemmas (merge_hinst_lemma_attrs tactic.transparency.reducible bool.ff attr_names hs₁) (merge_hinst_lemma_attrs tactic.transparency.reducible bool.tt simp_attr_names))))) (has_append.append.{0} (list.{0} name) (list.has_append.{0} name) (has_append.append.{0} (list.{0} name) (list.has_append.{0} name) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (list.nil.{0} name)) attr_names) simp_attr_names)) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))) (expr bool.tt)"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 2, "uparams": [], "type": "Pi (a : interactive.loc), (reflected.{1} interactive.loc a)"},
{"kind": "problem", "class": "reflected", "max_depth": 1, "steps": 16, "uparams": [], "type": "Pi (a : option.{0} (expr bool.ff)), (reflected.{1} (option.{0} (expr bool.ff)) a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable (eq.{1} (expr bool.tt) a eq)"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type hinst_lemmas"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 1, "uparams": [], "type": "reflected.{1} pos _p.1"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 6, "uparams": [], "type": "reflected.{1} bool _p.2"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 13, "uparams": [], "type": "reflected.{1} (expr bool.ff) _p.3"},
{"kind": "dep", "name": "tactic.interactive.rw_rule", "uparams": [], "type": "Type"},
{"kind": "dep", "name": "tactic.interactive.rw_rule.mk", "uparams": [], "type": "pos → bool → expr bool.ff → tactic.interactive.rw_rule"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} (pos -> bool -> (expr bool.ff) -> tactic.interactive.rw_rule) tactic.interactive.rw_rule.mk"},
{"kind": "instance", "name": "tactic.interactive.rw_rule.has_reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "tactic.interactive.rw_rule"}], "coercion_like": 0, "type": "@reflected.{1} tactic.interactive.rw_rule a"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable (eq.{1} (expr bool.tt) t h)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool (_private.1110872373.uses_hyp e hyp) bool.tt))"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 1, "steps": 10, "uparams": [], "type": "reflected.{1} (list.{0} tactic.interactive.rw_rule) _p.1"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 1, "steps": 6, "uparams": [], "type": "reflected.{1} (option.{0} pos) _p.2"},
{"kind": "dep", "name": "tactic.interactive.rw_rules_t", "uparams": [], "type": "Type"},
{"kind": "dep", "name": "tactic.interactive.rw_rules_t.mk", "uparams": [], "type": "list.{0} tactic.interactive.rw_rule → option.{0} pos → tactic.interactive.rw_rules_t"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} ((list.{0} tactic.interactive.rw_rule) -> (option.{0} pos) -> tactic.interactive.rw_rules_t) tactic.interactive.rw_rules_t.mk"},
{"kind": "instance", "name": "tactic.interactive.rw_rules_t.has_reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "tactic.interactive.rw_rules_t"}], "coercion_like": 0, "type": "@reflected.{1} tactic.interactive.rw_rules_t a"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : tactic.interactive.rw_rules_t), (reflected.{1} tactic.interactive.rw_rules_t a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (name_set.contains input_hyp_uids (expr.local_uniq_name h)) bool.tt)"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state (prod.{0 0} (expr bool.ff) name))) (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state (prod.{0 0} (expr bool.ff) name)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_1_hd_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "problem", "class": "reflected", "max_depth": 1, "steps": 33, "uparams": [], "type": "Pi (a : prod.{0 0} (expr bool.ff) name), (reflected.{1} (prod.{0 0} (expr bool.ff) name) a)"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_coe_t.{1 1} name (option.{0} name)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool te bool.tt)"},
{"kind": "problem", "class": "reflected", "max_depth": 2, "steps": 38, "uparams": [], "type": "Pi (a : prod.{0 0} (option.{0} name) (expr bool.ff)), (reflected.{1} (prod.{0 0} (option.{0} name) (expr bool.ff)) a)"},
{"kind": "problem", "class": "reflected", "max_depth": 2, "steps": 26, "uparams": [], "type": "Pi (a : option.{0} (list.{0} name)), (reflected.{1} (option.{0} (list.{0} name)) a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_local_constant e) bool.tt)"},
{"kind": "dep", "name": "expr.is_local_constant", "uparams": [], "type": "expr bool.tt → bool"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "Pi (a : expr bool.tt), (decidable (eq.{1} bool (expr.is_local_constant a) bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_local_constant e) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_hd (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name a_hd_a_1 (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "Pi (a : name) (b : name), (decidable (eq.{1} name a b))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (_private.111772443.tag_match t pre) bool.tt)"},
{"kind": "problem", "class": "has_to_string", "max_depth": 1, "steps": 27, "uparams": [], "type": "has_to_string.{0} (list.{0} name)"},
{"kind": "problem", "class": "has_to_string", "max_depth": 2, "steps": 46, "uparams": [], "type": "has_to_string.{0} (list.{0} (list.{0} name))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (option.is_none.{0} name (environment.inductive_type_of env r_id)) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.has_meta_var e) bool.tt)"},
{"kind": "problem", "class": "has_bind", "max_depth": 1, "steps": 5, "uparams": [], "type": "has_bind.{0 0} option.{0}"},
{"kind": "problem", "class": "alternative", "max_depth": 0, "steps": 3, "uparams": [], "type": "alternative.{0 0} option.{0}"},
{"kind": "problem", "class": "has_pure", "max_depth": 2, "steps": 5, "uparams": [], "type": "has_pure.{0 0} option.{0}"},
{"kind": "problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_mem.{0 0} (expr bool.tt) (list.{0} (expr bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 23, "uparams": [], "type": "decidable (has_mem.mem.{0 0} (expr bool.tt) (list.{0} (expr bool.tt)) (list.has_mem.{0} (expr bool.tt)) e goals)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name ty' ty)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name _a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name _a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name _a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name _a (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "problem", "class": "has_orelse", "max_depth": 1, "steps": 4, "uparams": [], "type": "has_orelse.{0 0} option.{0}"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 58, "uparams": [], "type": "decidable (not (eq.{1} nat i idx))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 34, "uparams": [], "type": "Pi (a : expr bool.tt), (decidable (not (eq.{1} (expr bool.tt) a g)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 24, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt (list.length.{0} name (option.get_or_else.{0} (list.{0} name) ids (list.nil.{0} name))) n)"},
{"kind": "problem", "class": "has_to_string", "max_depth": 0, "steps": 8, "uparams": [], "type": "has_to_string.{0} name"},
{"kind": "problem", "class": "reflected", "max_depth": 1, "steps": 14, "uparams": [], "type": "Pi (a : option.{0} punit.{1}), (reflected.{1} (option.{0} punit.{1}) a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (option.is_none.{0} punit.{1} rec) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_constant bool.tt I) bool.tt)"},
{"kind": "problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_mem.{0 0} name (list.{0} name)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 28, "uparams": [], "type": "decidable (has_mem.mem.{0 0} name (list.{0} name) (list.has_mem.{0} name) (expr.const_name bool.tt I) type_names)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool at_most_one bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 25, "uparams": [], "type": "decidable (has_le.le.{0} nat nat.has_le n (has_one.one.{0} nat nat.has_one))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (option.is_none.{0} punit.{1} rec) bool.tt)"},
{"kind": "problem", "class": "reflected", "max_depth": 1, "steps": 18, "uparams": [], "type": "Pi (a : option.{0} nat), (reflected.{1} (option.{0} nat) a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 139, "uparams": [], "type": "decidable (not (or (eq.{1} bool (expr.is_pi t) bool.tt) (eq.{1} bool (expr.is_let t) bool.tt)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 139, "uparams": [], "type": "decidable (not (or (eq.{1} bool (expr.is_pi t) bool.tt) (eq.{1} bool (expr.is_let t) bool.tt)))"},
{"kind": "problem", "class": "reflected", "max_depth": 2, "steps": 46, "uparams": [], "type": "Pi (a : sum.{0 0} (expr bool.ff) (list.{0} (expr bool.ff))), (reflected.{1} (sum.{0 0} (expr bool.ff) (list.{0} (expr bool.ff))) a)"},
{"kind": "ignored_problem", "class": "has_to_tactic_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_tactic_format.{0} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (option.is_none.{0} punit.{1} rec) bool.tt)"},
{"kind": "dep", "name": "tactic.simp_arg_type", "uparams": [], "type": "Type"},
{"kind": "dep", "name": "tactic.simp_arg_type.all_hyps", "uparams": [], "type": "tactic.simp_arg_type"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} tactic.simp_arg_type tactic.simp_arg_type.all_hyps"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 11, "uparams": [], "type": "reflected.{1} name _p.1"},
{"kind": "dep", "name": "tactic.simp_arg_type.except", "uparams": [], "type": "name → tactic.simp_arg_type"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} (name -> tactic.simp_arg_type) tactic.simp_arg_type.except"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 15, "uparams": [], "type": "reflected.{1} (expr bool.ff) _p.2"},
{"kind": "dep", "name": "tactic.simp_arg_type.expr", "uparams": [], "type": "expr bool.ff → tactic.simp_arg_type"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{1} ((expr bool.ff) -> tactic.simp_arg_type) tactic.simp_arg_type.expr"},
{"kind": "instance", "name": "tactic.simp_arg_type.has_reflect", "class": "reflected", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "tactic.simp_arg_type"}], "coercion_like": 0, "type": "@reflected.{1} tactic.simp_arg_type a"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool all_hyps bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (pexpr.is_choice_macro p) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool b bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 24, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) (list.length.{0} name eqns))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (option.is_some.{0} environment.projection_info (environment.is_projection env n)) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool b bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 3, "steps": 205, "uparams": [], "type": "decidable (and (eq.{1} bool all_hyps bool.tt) (and (eq.{1} bool at_star bool.tt) (not (eq.{1} bool (list.empty.{0} name hex) bool.tt))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 134, "uparams": [], "type": "decidable (and (not (eq.{1} bool at_star bool.tt)) (eq.{1} bool all_hyps bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 66, "uparams": [], "type": "Pi (a : expr bool.tt), (decidable (not (has_mem.mem.{0 0} name (list.{0} name) (list.has_mem.{0} name) (expr.local_uniq_name a) hex)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool tgt bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 164, "uparams": [], "type": "decidable (or (eq.{1} bool (tactic.simp_config.fail_if_unchanged cfg) bool.ff) (or (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) (list.length.{0} (expr bool.tt) to_remove)) (eq.{1} bool goal_simplified bool.tt)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool all_hyps bool.tt)"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 9, "uparams": [], "type": "Pi (a : bool), (reflected.{1} bool a)"},
{"kind": "problem", "class": "reflected", "max_depth": 1, "steps": 12, "uparams": [], "type": "Pi (a : list.{0} tactic.simp_arg_type), (reflected.{1} (list.{0} tactic.simp_arg_type) a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (option.is_none.{0} punit.{1} use_iota_eqn) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool (list.empty.{0} name u) bool.tt))"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_coe_t.{1 1} simp_lemmas (option.{0} simp_lemmas)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (environment.contains env curr) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (environment.contains env n) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 166, "uparams": [], "type": "decidable (and (not (eq.{1} bool b₁ bool.tt)) (not (eq.{1} bool b₂ bool.tt)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 102, "uparams": [], "type": "decidable (and (eq.{1} bool (list.empty.{0} name hs) bool.tt) (eq.{1} bool (option.is_none.{0} environment.projection_info (environment.is_projection env (expr.const_name bool.ff n))) bool.tt))"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 9, "uparams": [], "type": "has_coe_t.{1 1} string name"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.alpha_eqv t e) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_local_constant (expr.get_app_fn bool.tt e)) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool r bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (name_set.contains s (expr.local_pp_name bool.tt h)) bool.tt)"},
{"kind": "problem", "class": "has_andthen", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_andthen.{0 0 0} (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 39, "uparams": [], "type": "decidable (not (eq.{1} name n (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.has_meta_var tgt) bool.tt)"},
{"kind": "dep", "name": "conv", "uparams": ["u"], "type": "Type u → Type u"},
{"kind": "instance", "name": "conv.monad", "class": "monad", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "monad.{u_1 u_1} conv.{u_1}"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.has_meta_var proof) bool.tt)"},
{"kind": "problem", "class": "monad_fail", "max_depth": 0, "steps": 1, "uparams": ["u_1"], "type": "monad_fail.{u_1 u_1} (fun (α : Type.{u_1}), (tactic_state -> (interaction_monad.result.{u_1} tactic_state α)))"},
{"kind": "instance", "name": "conv.monad_fail", "class": "monad_fail", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "monad_fail.{u_1 u_1} conv.{u_1}"},
{"kind": "problem", "class": "alternative", "max_depth": 0, "steps": 2, "uparams": ["u_1"], "type": "alternative.{u_1 u_1} (fun (α : Type.{u_1}), (tactic_state -> (interaction_monad.result.{u_1} tactic_state α)))"},
{"kind": "instance", "name": "conv.alternative", "class": "alternative", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "alternative.{u_1 u_1} conv.{u_1}"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable (eq.{1} (expr bool.tt) t r)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 58, "uparams": [], "type": "decidable (not (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero)))"},
{"kind": "problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_bind.{0 0} conv.{0}"},
{"kind": "problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad.{0 0} conv.{0}"},
{"kind": "problem", "class": "monad_fail", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad_fail.{0 0} conv.{0}"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "functor.{u v} f"},
{"kind": "class", "name": "is_lawful_functor", "uparams": ["u","v"], "params": [{"name": "f", "is_out": 0, "type": "Type.{u} -> Type.{v}"},{"name": "_inst_1", "is_out": 0, "type": "functor.{u v} f"}]},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 58, "uparams": [], "type": "decidable (not (eq.{1} nat (list.length.{0} (expr bool.tt) (expr.get_app_args lhs)) (list.length.{0} (expr bool.tt) (expr.get_app_args rhs))))"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "functor.{u v} f"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool rec bool.tt)"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "functor.{u v} f"},
{"kind": "ignored_problem", "class": "has_seq", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_seq.{u v} f"},
{"kind": "ignored_problem", "class": "has_seq_left", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_seq_left.{u v} f"},
{"kind": "ignored_problem", "class": "has_seq_right", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_seq_right.{u v} f"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_pure.{u v} f"},
{"kind": "problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": [], "type": "alternative.{0 0} conv.{0}"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name r (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable (eq.{1} (expr bool.tt) (expr.get_app_fn bool.tt lhs) (expr.get_app_fn bool.tt rhs))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 7, "uparams": [], "type": "decidable (eq.{1} name r (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (environment.is_recursive env I_name) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 134, "uparams": [], "type": "decidable (and (eq.{1} bool (environment.is_ginductive env I_name) bool.tt) (not (eq.{1} bool (environment.is_inductive env I_name) bool.tt)))"},
{"kind": "class", "name": "is_lawful_applicative", "uparams": ["u","v"], "params": [{"name": "f", "is_out": 0, "type": "Type.{u} -> Type.{v}"},{"name": "_inst_1", "is_out": 0, "type": "applicative.{u v} f"}]},
{"kind": "instance", "name": "is_lawful_applicative.to_is_lawful_functor", "class": "is_lawful_functor", "from_extends": 1, "uparams": ["u","v"], "params": [{"name": "f", "type": "Type u → Type v"},{"name": "_inst_1", "class": "applicative", "type": "applicative.{u v} f"},{"name": "c", "class": "is_lawful_applicative", "type": "@is_lawful_applicative.{u v} f _inst_1"}], "coercion_like": 0, "type": "@is_lawful_functor.{u v} f (@applicative.to_functor.{u v} f _inst_1)"},
{"kind": "ignored_problem", "class": "applicative", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "applicative.{u v} f"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_pure.{u v} f"},
{"kind": "ignored_problem", "class": "has_seq", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_seq.{u v} f"},
{"kind": "ignored_problem", "class": "applicative", "max_depth": 1, "steps": 9, "uparams": ["u","v"], "type": "applicative.{u v} m"},
{"kind": "problem", "class": "has_orelse", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_orelse.{0 0} conv.{0}"},
{"kind": "ignored_problem", "class": "is_lawful_applicative", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "is_lawful_applicative.{u v} f _inst_1"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool found bool.tt))"},
{"kind": "ignored_problem", "class": "is_lawful_functor", "max_depth": 1, "steps": 3, "uparams": ["u","v"], "type": "is_lawful_functor.{u v} f (applicative.to_functor.{u v} f _inst_1)"},
{"kind": "ignored_problem", "class": "applicative", "max_depth": 1, "steps": 9, "uparams": ["u","v"], "type": "applicative.{u v} m"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "functor.{u v} m"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool matched bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool found bool.tt))"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_seq", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "has_seq.{u v} m"},
{"kind": "instance", "name": "tactic.binder_info.has_decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "binder_info"},{"name": "b", "type": "binder_info"}], "coercion_like": 0, "type": "decidable (@eq.{1} binder_info a b)"},
{"kind": "problem", "class": "reflected", "max_depth": 1, "steps": 25, "uparams": [], "type": "Pi (a : list.{0} nat), (reflected.{1} (list.{0} nat) a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool matched bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 47, "uparams": [], "type": "decidable (has_mem.mem.{0 0} nat (list.{0} nat) (list.has_mem.{0} nat) i occs)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (a : α) (b : α), (decidable (eq.{u+1} α a b))"},
{"kind": "instance", "name": "subtype.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "p", "type": "α → Prop"},{"name": "_inst_1", "class": "decidable", "type": "Π (a b : α), decidable (@eq.{u+1} α a b)"},{"name": "a", "type": "@subtype.{u+1} α p"},{"name": "b", "type": "@subtype.{u+1} α p"}], "coercion_like": 0, "type": "decidable (@eq.{(max 1 (u+1))} (@subtype.{u+1} α p) a b)"},
{"kind": "dep", "name": "vm_obj_kind", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "vm_obj_kind.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "vm_obj_kind"},{"name": "b", "type": "vm_obj_kind"}], "coercion_like": 0, "type": "decidable (@eq.{1} vm_obj_kind a b)"},
{"kind": "dep", "name": "vm_core", "uparams": [], "type": "Type → Type"},
{"kind": "instance", "name": "vm_core.monad", "class": "monad", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "monad.{0 0} vm_core"},
{"kind": "problem", "class": "has_bind", "max_depth": 2, "steps": 4, "uparams": [], "type": "has_bind.{0 0} (option_t.{0 0} vm_core)"},
{"kind": "problem", "class": "monad", "max_depth": 1, "steps": 3, "uparams": [], "type": "monad.{0 0} (option_t.{0 0} vm_core)"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_format.{0} α"},
{"kind": "class", "name": "is_lawful_monad", "uparams": ["u","v"], "params": [{"name": "m", "is_out": 0, "type": "Type.{u} -> Type.{v}"},{"name": "_inst_1", "is_out": 0, "type": "monad.{u v} m"}]},
{"kind": "instance", "name": "is_lawful_monad.to_is_lawful_applicative", "class": "is_lawful_applicative", "from_extends": 1, "uparams": ["u","v"], "params": [{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"},{"name": "c", "class": "is_lawful_monad", "type": "@is_lawful_monad.{u v} m _inst_1"}], "coercion_like": 0, "type": "@is_lawful_applicative.{u v} m (@monad.to_applicative.{u v} m _inst_1)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "is_lawful_monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "is_lawful_monad.{u v} m _inst_1"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "functor.{u v} m"},
{"kind": "problem", "class": "functor", "max_depth": 2, "steps": 15, "uparams": [], "type": "functor.{0 0} (id.{2} Type)"},
{"kind": "problem", "class": "has_bind", "max_depth": 1, "steps": 7, "uparams": [], "type": "has_bind.{0 0} (id.{2} Type)"},
{"kind": "problem", "class": "has_pure", "max_depth": 2, "steps": 15, "uparams": [], "type": "has_pure.{0 0} (id.{2} Type)"},
{"kind": "problem", "class": "monad", "max_depth": 0, "steps": 6, "uparams": ["u_1"], "type": "monad.{u_1 u_1} (id.{(u_1+1)+1} Type.{u_1})"},
{"kind": "ignored_problem", "class": "applicative", "max_depth": 1, "steps": 9, "uparams": ["u","v"], "type": "applicative.{u v} m"},
{"kind": "ignored_problem", "class": "is_lawful_functor", "max_depth": 2, "steps": 13, "uparams": ["u","v"], "type": "is_lawful_functor.{u v} m (applicative.to_functor.{u v} m (monad.to_applicative.{u v} m _inst_1))"},
{"kind": "problem", "class": "applicative", "max_depth": 1, "steps": 14, "uparams": ["u_1"], "type": "applicative.{u_1 u_1} (id.{(u_1+1)+1} Type.{u_1})"},
{"kind": "instance", "name": "id.is_lawful_monad", "class": "is_lawful_monad", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "@is_lawful_monad.{u_1 u_1} (@id.{u_1+2} (Type u_1)) id.monad.{u_1}"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 3, "steps": 31, "uparams": ["u","v"], "type": "has_pure.{u (max u v)} (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 2, "steps": 6, "uparams": ["u","v"], "type": "has_bind.{u (max u v)} (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "functor.{u v} m"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 3, "steps": 31, "uparams": ["u","v"], "type": "functor.{u (max u v)} (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 2, "steps": 8, "uparams": ["u","u_1","v"], "type": "has_monad_lift_t.{u u_1 (max u v)} n (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 0, "steps": 1, "uparams": ["u","u_1","v"], "type": "has_monad_lift_t.{u u_1 v} n m"},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 0, "steps": 1, "uparams": ["u","u_1","v"], "type": "monad_functor_t.{u u_1 v} n n' m m'"},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 2, "steps": 10, "uparams": ["u","u_1","v"], "type": "monad_functor_t.{u u_1 (max u v)} n n' (state_t.{u v} σ m) (state_t.{u v} σ m')"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "is_lawful_monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "is_lawful_monad.{u v} m _inst_1"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 3, "steps": 31, "uparams": ["u","v"], "type": "has_pure.{u (max u v)} (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 2, "steps": 6, "uparams": ["u","v"], "type": "has_bind.{u (max u v)} (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 1, "steps": 5, "uparams": ["u","v"], "type": "monad.{u (max u v)} (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 1, "steps": 5, "uparams": ["u","v"], "type": "monad.{u (max u v)} (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "applicative", "max_depth": 2, "steps": 30, "uparams": ["u","v"], "type": "applicative.{u (max u v)} (state_t.{u v} σ m)"},
{"kind": "ignored_problem", "class": "is_lawful_monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "is_lawful_monad.{u v} m _inst_1"},
{"kind": "ignored_problem", "class": "applicative", "max_depth": 1, "steps": 9, "uparams": ["u","v"], "type": "applicative.{u v} m"},
{"kind": "ignored_problem", "class": "is_lawful_functor", "max_depth": 2, "steps": 13, "uparams": ["u","v"], "type": "is_lawful_functor.{u v} m (applicative.to_functor.{u v} m (monad.to_applicative.{u v} m _inst_1))"},
{"kind": "instance", "name": "state_t.is_lawful_monad", "class": "is_lawful_monad", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"},{"name": "_inst_2", "class": "is_lawful_monad", "type": "@is_lawful_monad.{u v} m _inst_1"},{"name": "σ", "type": "Type u"}], "coercion_like": 0, "type": "@is_lawful_monad.{u (max u v)} (state_t.{u v} σ m) (@state_t.monad.{u v} σ m _inst_1)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 3, "steps": 15, "uparams": ["u","v"], "type": "has_pure.{u v} (except_t.{u v} ε m)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 2, "steps": 7, "uparams": ["u","v"], "type": "has_bind.{u v} (except_t.{u v} ε m)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "functor.{u v} m"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 3, "steps": 15, "uparams": ["u","v"], "type": "functor.{u v} (except_t.{u v} ε m)"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "functor.{u v} m"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 2, "steps": 9, "uparams": ["u","u_1","v"], "type": "has_monad_lift_t.{u u_1 v} n (except_t.{u v} ε m)"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 0, "steps": 1, "uparams": ["u","u_1","v"], "type": "has_monad_lift_t.{u u_1 v} n m"},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 0, "steps": 1, "uparams": ["u","u_1","v"], "type": "monad_functor_t.{u u_1 v} n n' m m'"},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 2, "steps": 11, "uparams": ["u","u_1","v"], "type": "monad_functor_t.{u u_1 v} n n' (except_t.{u v} ε m) (except_t.{u v} ε m')"},
{"kind": "ignored_problem", "class": "is_lawful_monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "is_lawful_monad.{u v} m _inst_1"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 3, "steps": 15, "uparams": ["u","v"], "type": "has_pure.{u v} (except_t.{u v} ε m)"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 1, "steps": 6, "uparams": ["u","v"], "type": "monad.{u v} (except_t.{u v} ε m)"},
{"kind": "ignored_problem", "class": "applicative", "max_depth": 2, "steps": 14, "uparams": ["u","v"], "type": "applicative.{u v} (except_t.{u v} ε m)"},
{"kind": "ignored_problem", "class": "is_lawful_monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "is_lawful_monad.{u v} m _inst_1"},
{"kind": "ignored_problem", "class": "applicative", "max_depth": 1, "steps": 9, "uparams": ["u","v"], "type": "applicative.{u v} m"},
{"kind": "ignored_problem", "class": "is_lawful_functor", "max_depth": 2, "steps": 13, "uparams": ["u","v"], "type": "is_lawful_functor.{u v} m (applicative.to_functor.{u v} m (monad.to_applicative.{u v} m _inst_1))"},
{"kind": "instance", "name": "except_t.is_lawful_monad", "class": "is_lawful_monad", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"},{"name": "_inst_2", "class": "is_lawful_monad", "type": "@is_lawful_monad.{u v} m _inst_1"},{"name": "ε", "type": "Type u"}], "coercion_like": 0, "type": "@is_lawful_monad.{u v} (except_t.{u v} ε m) (@except_t.monad.{u v} ε m _inst_1)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 3, "steps": 30, "uparams": ["u","v"], "type": "has_pure.{u (max u v)} (reader_t.{u v} ρ m)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 2, "steps": 5, "uparams": ["u","v"], "type": "has_bind.{u (max u v)} (reader_t.{u v} ρ m)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "functor.{u v} m"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 3, "steps": 30, "uparams": ["u","v"], "type": "functor.{u (max u v)} (reader_t.{u v} ρ m)"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 2, "steps": 7, "uparams": ["u","u_1","v"], "type": "has_monad_lift_t.{u u_1 (max u v)} n (reader_t.{u v} ρ m)"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 0, "steps": 1, "uparams": ["u","u_1","v"], "type": "has_monad_lift_t.{u u_1 v} n m"},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 0, "steps": 1, "uparams": ["u","u_1","v"], "type": "monad_functor_t.{u u_1 v} n n' m m'"},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 2, "steps": 9, "uparams": ["u","u_1","v"], "type": "monad_functor_t.{u u_1 (max u v)} n n' (reader_t.{u v} ρ m) (reader_t.{u v} ρ m')"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "is_lawful_monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "is_lawful_monad.{u v} m _inst_1"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 1, "steps": 4, "uparams": ["u","v"], "type": "monad.{u (max u v)} (reader_t.{u v} ρ m)"},
{"kind": "ignored_problem", "class": "applicative", "max_depth": 2, "steps": 29, "uparams": ["u","v"], "type": "applicative.{u (max u v)} (reader_t.{u v} ρ m)"},
{"kind": "ignored_problem", "class": "is_lawful_monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "is_lawful_monad.{u v} m _inst_1"},
{"kind": "ignored_problem", "class": "applicative", "max_depth": 1, "steps": 9, "uparams": ["u","v"], "type": "applicative.{u v} m"},
{"kind": "ignored_problem", "class": "is_lawful_functor", "max_depth": 2, "steps": 13, "uparams": ["u","v"], "type": "is_lawful_functor.{u v} m (applicative.to_functor.{u v} m (monad.to_applicative.{u v} m _inst_1))"},
{"kind": "instance", "name": "reader_t.is_lawful_monad", "class": "is_lawful_monad", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "ρ", "type": "Type u"},{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"},{"name": "_inst_2", "class": "is_lawful_monad", "type": "@is_lawful_monad.{u v} m _inst_1"}], "coercion_like": 0, "type": "@is_lawful_monad.{u (max u v)} (reader_t.{u v} ρ m) (@reader_t.monad.{u v} ρ m _inst_1)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 3, "steps": 4, "uparams": ["u","v"], "type": "has_pure.{u v} (option_t.{u v} m)"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "has_pure.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 2, "steps": 4, "uparams": ["u","v"], "type": "has_bind.{u v} (option_t.{u v} m)"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "functor.{u v} m"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 3, "steps": 4, "uparams": ["u","v"], "type": "functor.{u v} (option_t.{u v} m)"},
{"kind": "ignored_problem", "class": "functor", "max_depth": 2, "steps": 10, "uparams": ["u","v"], "type": "functor.{u v} m"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 2, "steps": 6, "uparams": ["u","u_1","v"], "type": "has_monad_lift_t.{u u_1 v} n (option_t.{u v} m)"},
{"kind": "ignored_problem", "class": "has_monad_lift_t", "max_depth": 0, "steps": 1, "uparams": ["u","u_1","v"], "type": "has_monad_lift_t.{u u_1 v} n m"},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 0, "steps": 1, "uparams": ["u","u_1","v"], "type": "monad_functor_t.{u u_1 v} n n' m m'"},
{"kind": "ignored_problem", "class": "monad_functor_t", "max_depth": 2, "steps": 8, "uparams": ["u","u_1","v"], "type": "monad_functor_t.{u u_1 v} n n' (option_t.{u v} m) (option_t.{u v} m')"},
{"kind": "ignored_problem", "class": "is_lawful_monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "is_lawful_monad.{u v} m _inst_1"},
{"kind": "ignored_problem", "class": "has_pure", "max_depth": 3, "steps": 4, "uparams": ["u","v"], "type": "has_pure.{u v} (option_t.{u v} m)"},
{"kind": "ignored_problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": ["u","v"], "type": "has_bind.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "monad.{u v} m"},
{"kind": "ignored_problem", "class": "monad", "max_depth": 1, "steps": 3, "uparams": ["u","v"], "type": "monad.{u v} (option_t.{u v} m)"},
{"kind": "ignored_problem", "class": "applicative", "max_depth": 2, "steps": 3, "uparams": ["u","v"], "type": "applicative.{u v} (option_t.{u v} m)"},
{"kind": "ignored_problem", "class": "is_lawful_monad", "max_depth": 0, "steps": 1, "uparams": ["u","v"], "type": "is_lawful_monad.{u v} m _inst_1"},
{"kind": "ignored_problem", "class": "applicative", "max_depth": 1, "steps": 9, "uparams": ["u","v"], "type": "applicative.{u v} m"},
{"kind": "ignored_problem", "class": "is_lawful_functor", "max_depth": 2, "steps": 13, "uparams": ["u","v"], "type": "is_lawful_functor.{u v} m (applicative.to_functor.{u v} m (monad.to_applicative.{u v} m _inst_1))"},
{"kind": "instance", "name": "option_t.is_lawful_monad", "class": "is_lawful_monad", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "m", "type": "Type u → Type v"},{"name": "_inst_1", "class": "monad", "type": "monad.{u v} m"},{"name": "_inst_2", "class": "is_lawful_monad", "type": "@is_lawful_monad.{u v} m _inst_1"}], "coercion_like": 0, "type": "@is_lawful_monad.{u v} (option_t.{u v} m) (@option_t.monad.{u v} m _inst_1)"},
{"kind": "dep", "name": "set", "uparams": ["u"], "type": "Type u → Type u"},
{"kind": "instance", "name": "set.has_mem", "class": "has_mem", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_mem.{u u} α (set.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (set.{u} α)"},
{"kind": "instance", "name": "set.has_subset", "class": "has_subset", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_subset.{u} (set.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (set.{u} α)"},
{"kind": "instance", "name": "set.has_sep", "class": "has_sep", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_sep.{u u} α (set.{u} α)"},
{"kind": "instance", "name": "set.has_emptyc", "class": "has_emptyc", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_emptyc.{u} (set.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (set.{u} α)"},
{"kind": "instance", "name": "set.has_insert", "class": "has_insert", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_insert.{u u} α (set.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (set.{u} α)"},
{"kind": "instance", "name": "set.has_union", "class": "has_union", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_union.{u} (set.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (set.{u} α)"},
{"kind": "instance", "name": "set.has_inter", "class": "has_inter", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_inter.{u} (set.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (set.{u} α)"},
{"kind": "instance", "name": "set.has_neg", "class": "has_neg", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_neg.{u} (set.{u} α)"},
{"kind": "ignored_problem", "class": "has_sep", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sep.{u u} α (set.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (set.{u} α)"},
{"kind": "instance", "name": "set.has_sdiff", "class": "has_sdiff", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_sdiff.{u} (set.{u} α)"},
{"kind": "ignored_problem", "class": "has_subset", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_subset.{u} (set.{u} α)"},
{"kind": "problem", "class": "monad", "max_depth": 0, "steps": 10, "uparams": ["u_1"], "type": "monad.{u_1 u_1} option.{u_1}"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} (set.{u} α) (set.{u} (set.{u} α))"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (set.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (set.{u} α)"},
{"kind": "instance", "name": "set.functor", "class": "functor", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "functor.{u_1 u_1} set.{u_1}"},
{"kind": "problem", "class": "applicative", "max_depth": 1, "steps": 7, "uparams": ["u_1"], "type": "applicative.{u_1 u_1} option.{u_1}"},
{"kind": "problem", "class": "functor", "max_depth": 0, "steps": 1, "uparams": ["u_1"], "type": "functor.{u_1 u_1} set.{u_1}"},
{"kind": "instance", "name": "option.is_lawful_monad", "class": "is_lawful_monad", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "@is_lawful_monad.{u_1 u_1} option.{u_1} option.monad.{u_1}"},
{"kind": "instance", "name": "set.is_lawful_functor", "class": "is_lawful_functor", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "@is_lawful_functor.{u_1 u_1} set.{u_1} set.functor.{u_1}"},
{"kind": "dep", "name": "cc_config", "uparams": [], "type": "Type"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 16, "uparams": [], "type": "has_sizeof.{1} cc_config"},
{"kind": "dep", "name": "ematch_config", "uparams": [], "type": "Type"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_sizeof.{1} ematch_config"},
{"kind": "dep", "name": "smt_pre_config", "uparams": [], "type": "Type"},
{"kind": "problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_sizeof.{1} smt_pre_config"},
{"kind": "dep", "name": "smt_state", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "smt_state.has_append", "class": "has_append", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_append.{0} smt_state"},
{"kind": "problem", "class": "monad", "max_depth": 1, "steps": 11, "uparams": [], "type": "monad.{0 0} (state_t.{0 0} smt_state (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))))"},
{"kind": "instance", "name": "smt_tactic.monad", "class": "monad", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "monad.{0 0} (state_t.{0 0} smt_state (λ (α : Type), tactic_state → interaction_monad.result.{0} tactic_state α))"},
{"kind": "problem", "class": "alternative", "max_depth": 1, "steps": 17, "uparams": [], "type": "alternative.{0 0} (state_t.{0 0} smt_state (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))))"},
{"kind": "instance", "name": "smt_tactic.alternative", "class": "alternative", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "alternative.{0 0} (state_t.{0 0} smt_state (λ (α : Type), tactic_state → interaction_monad.result.{0} tactic_state α))"},
{"kind": "problem", "class": "monad_state", "max_depth": 1, "steps": 10, "uparams": [], "type": "monad_state.{0 0} smt_state (state_t.{0 0} smt_state (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))))"},
{"kind": "instance", "name": "smt_tactic.monad_state", "class": "monad_state", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "monad_state.{0 0} smt_state (state_t.{0 0} smt_state (λ (α : Type), tactic_state → interaction_monad.result.{0} tactic_state α))"},
{"kind": "dep", "name": "smt_tactic", "uparams": [], "type": "Type → Type"},
{"kind": "instance", "name": "smt_tactic.has_monad_lift", "class": "has_monad_lift", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_monad_lift.{0 0 0} (λ (α : Type), tactic_state → interaction_monad.result.{0} tactic_state α) smt_tactic"},
{"kind": "problem", "class": "has_monad_lift_t", "max_depth": 1, "steps": 4, "uparams": [], "type": "has_monad_lift_t.{0 0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) smt_tactic"},
{"kind": "instance", "name": "smt_tactic.has_coe", "class": "has_coe", "from_extends": 0, "uparams": [], "params": [{"name": "α", "type": "Type"}], "coercion_like": 0, "type": "has_coe.{1 1} (tactic_state → interaction_monad.result.{0} tactic_state α) (smt_tactic α)"},
{"kind": "problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad.{0 0} smt_tactic"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state α)) (smt_tactic α)"},
{"kind": "instance", "name": "smt_tactic.monad_fail", "class": "monad_fail", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "monad_fail.{0 0} smt_tactic"},
{"kind": "problem", "class": "has_bind", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_bind.{0 0} smt_tactic"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state hinst_lemma)) (smt_tactic hinst_lemma)"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state α)) (smt_tactic α)"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_to_format.{u} β"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state α)) (smt_tactic α)"},
{"kind": "problem", "class": "has_orelse", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_orelse.{0 0} smt_tactic"},
{"kind": "problem", "class": "monad_state", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad_state.{0 0} smt_state smt_tactic"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state tactic_state)) (smt_tactic tactic_state)"},
{"kind": "problem", "class": "has_append", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_append.{0} smt_state"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (smt_tactic punit.{1})"},
{"kind": "problem", "class": "monad_fail", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad_fail.{0 0} smt_tactic"},
{"kind": "ignored_problem", "class": "has_to_tactic_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_tactic_format.{0} α"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state (expr bool.tt))) (smt_tactic (expr bool.tt))"},
{"kind": "problem", "class": "functor", "max_depth": 2, "steps": 3, "uparams": [], "type": "functor.{0 0} smt_tactic"},
{"kind": "dep", "name": "smt_goal", "uparams": [], "type": "Type"},
{"kind": "problem", "class": "monad_state", "max_depth": 0, "steps": 1, "uparams": [], "type": "monad_state.{0 0} (list.{0} smt_goal) smt_tactic"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state (list.{0} (expr bool.tt)))) (smt_tactic (list.{0} (expr bool.tt)))"},
{"kind": "problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": [], "type": "has_append.{0} (list.{0} smt_goal)"},
{"kind": "instance", "name": "smt_tactic.has_andthen", "class": "has_andthen", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_andthen.{0 0 0} (smt_tactic punit.{1}) (smt_tactic punit.{1}) (smt_tactic punit.{1})"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool c bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_false t) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool c bool.tt)"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state (list.{0} (prod.{0 0} name (expr bool.tt))))) (smt_tactic (list.{0} (prod.{0 0} name (expr bool.tt))))"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state bool)) (smt_tactic bool)"},
{"kind": "problem", "class": "alternative", "max_depth": 0, "steps": 1, "uparams": [], "type": "alternative.{0 0} smt_tactic"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (band (expr.is_pi f) (bnot (expr.is_arrow f))) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (tactic.is_trace_enabled_for n) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (name_set.contains ex n) bool.tt)"},
{"kind": "ignored_problem", "class": "reflected", "max_depth": 0, "steps": 36, "uparams": [], "type": "reflected.{1} (user_attribute hinst_lemmas punit.{1}) (user_attribute.mk hinst_lemmas punit.{1} attr_name (has_append.append.{0} string string.has_append (has_append.append.{0} string string.has_append (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (to_string.{0} name name.has_to_string simp_attr_name)) (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.none.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (option.none.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (user_attribute_cache_cfg.mk hinst_lemmas (fun (ns : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) hinst_lemmas hinst_lemmas (_private.787519257.to_hinst_lemmas tactic.transparency.reducible mk_name_set ns hinst_lemmas.mk) (fun (hs : hinst_lemmas), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (list.{0} name) hinst_lemmas (attribute.get_instances simp_attr_name) (fun (ss : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) name_set hinst_lemmas (get_name_set_for_attr ex_attr_name) (fun (ex : name_set), (_private.787519257.to_hinst_lemmas tactic.transparency.reducible ex ss hs)))))))) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (list.cons.{0} name simp_attr_name (list.nil.{0} name)))) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))"},
{"kind": "ignored_problem", "class": "has_coe_t", "max_depth": 1, "steps": 7, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{1} (user_attribute hinst_lemmas punit.{1}) (user_attribute.mk hinst_lemmas punit.{1} attr_name (has_append.append.{0} string string.has_append (has_append.append.{0} string string.has_append (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (to_string.{0} name name.has_to_string simp_attr_name)) (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.none.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (option.none.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (user_attribute_cache_cfg.mk hinst_lemmas (fun (ns : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) hinst_lemmas hinst_lemmas (_private.787519257.to_hinst_lemmas tactic.transparency.reducible mk_name_set ns hinst_lemmas.mk) (fun (hs : hinst_lemmas), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (list.{0} name) hinst_lemmas (attribute.get_instances simp_attr_name) (fun (ss : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) name_set hinst_lemmas (get_name_set_for_attr ex_attr_name) (fun (ex : name_set), (_private.787519257.to_hinst_lemmas tactic.transparency.reducible ex ss hs)))))))) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (list.cons.{0} name simp_attr_name (list.nil.{0} name)))) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool (expr.is_app e) bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool (expr.is_constant bool.tt (expr.get_app_fn bool.tt e)) bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 73, "uparams": [], "type": "decidable (and (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt e)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))) (eq.{1} nat (expr.get_app_num_args e) (has_one.one.{0} nat nat.has_one)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 73, "uparams": [], "type": "decidable (and (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt e)) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))) name.anonymous)) (eq.{1} nat (expr.get_app_num_args e) (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 73, "uparams": [], "type": "decidable (and (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt e)) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))) name.anonymous)) (eq.{1} nat (expr.get_app_num_args e) (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 73, "uparams": [], "type": "decidable (and (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt e)) (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))) (eq.{1} nat (expr.get_app_num_args e) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 73, "uparams": [], "type": "decidable (and (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt e)) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))) (eq.{1} nat (expr.get_app_num_args e) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool (expr.is_app e) bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (rsimp.is_value_like e) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 24, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt sz' (prod.snd.{0 0} (expr bool.tt) nat p))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 26, "uparams": [], "type": "decidable (eq.{1} nat (prod.snd.{0 0} (expr bool.tt) nat p) (has_one.one.{0} nat nat.has_one))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 63, "uparams": [], "type": "decidable (not (eq.{1} bool (expr.alpha_eqv new_t t) bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_local_constant h) bool.ff)"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state level)) (smt_tactic level)"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state name)) (smt_tactic name)"},
{"kind": "ignored_problem", "class": "has_to_tactic_format", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_to_tactic_format.{0} α"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state (expr bool.ff))) (smt_tactic (expr bool.ff))"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state hinst_lemmas)) (smt_tactic hinst_lemmas)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 31, "uparams": [], "type": "decidable (eq.{1} bool (expr.alpha_eqv t e) bool.tt)"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 93, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 93, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 94, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "class", "name": "semigroup", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "semigroup.to_has_mul", "class": "has_mul", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "semigroup", "type": "semigroup.{u} α"}], "coercion_like": 1, "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 94, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 94, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 94, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 95, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 95, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "class", "name": "comm_semigroup", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "comm_semigroup.to_semigroup", "class": "semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "comm_semigroup", "type": "comm_semigroup.{u} α"}], "coercion_like": 1, "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 95, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 95, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 95, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 96, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 96, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "class", "name": "left_cancel_semigroup", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "left_cancel_semigroup.to_semigroup", "class": "semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "left_cancel_semigroup", "type": "left_cancel_semigroup.{u} α"}], "coercion_like": 1, "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 96, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 96, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 96, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 97, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 97, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "class", "name": "right_cancel_semigroup", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "right_cancel_semigroup.to_semigroup", "class": "semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "right_cancel_semigroup", "type": "right_cancel_semigroup.{u} α"}], "coercion_like": 1, "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 97, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 97, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 97, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 97, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "dep", "name": "psigma", "uparams": ["u","v"], "type": "Π (α : Sort u), (α → Sort v) → Sort (max 1 u v)"},
{"kind": "instance", "name": "psigma.has_well_founded", "class": "has_well_founded", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "α → Type v"},{"name": "s₁", "class": "has_well_founded", "type": "has_well_founded.{u+1} α"},{"name": "s₂", "class": "has_well_founded", "type": "Π (a : α), has_well_founded.{v+1} (β a)"}], "coercion_like": 0, "type": "has_well_founded.{(max 1 (u+1) (v+1))} (@psigma.{u+1 v+1} α β)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 98, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 98, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 98, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "class", "name": "monoid", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "monoid.to_semigroup", "class": "semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "monoid", "type": "monoid.{u} α"}], "coercion_like": 1, "type": "semigroup.{u} α"},
{"kind": "instance", "name": "monoid.to_has_one", "class": "has_one", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "monoid", "type": "monoid.{u} α"}], "coercion_like": 1, "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 98, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 98, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 98, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 98, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 98, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 99, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 99, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 99, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 99, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "class", "name": "comm_monoid", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "comm_monoid.to_monoid", "class": "monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "comm_monoid", "type": "comm_monoid.{u} α"}], "coercion_like": 1, "type": "monoid.{u} α"},
{"kind": "instance", "name": "comm_monoid.to_comm_semigroup", "class": "comm_semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "comm_monoid", "type": "comm_monoid.{u} α"}], "coercion_like": 1, "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 99, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 99, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 99, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 99, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 99, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 99, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (monoid.to_semigroup.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one))) (inv a) a) (has_one.one.{u} α (monoid.to_has_one.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 100, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 100, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 100, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 100, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (monoid.to_semigroup.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one))) (inv a) a) (has_one.one.{u} α (monoid.to_has_one.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one)))))"},
{"kind": "class", "name": "group", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "group.to_monoid", "class": "monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "group", "type": "group.{u} α"}], "coercion_like": 1, "type": "monoid.{u} α"},
{"kind": "instance", "name": "group.to_has_inv", "class": "has_inv", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "group", "type": "group.{u} α"}], "coercion_like": 1, "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 100, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 100, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 100, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 100, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 100, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 100, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (monoid.to_semigroup.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one))) (inv a) a) (has_one.one.{u} α (monoid.to_has_one.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 100, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable q"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 138, "uparams": [], "type": "decidable (iff (not (eq.{1} bool bool.ff bool.tt)) (eq.{1} bool bool.ff bool.ff))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 101, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 101, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 101, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 138, "uparams": [], "type": "decidable (iff (not (eq.{1} bool bool.tt bool.tt)) (eq.{1} bool bool.tt bool.ff))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 101, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (monoid.to_semigroup.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one))) (inv a) a) (has_one.one.{u} α (monoid.to_has_one.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 101, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "dep", "name": "bor", "uparams": [], "type": "bool → bool → bool"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 178, "uparams": [], "type": "decidable (iff (eq.{1} bool (bor bool.ff bool.ff) bool.tt) (or (eq.{1} bool bool.ff bool.tt) (eq.{1} bool bool.ff bool.tt)))"},
{"kind": "dep", "name": "band", "uparams": [], "type": "bool → bool → bool"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 179, "uparams": [], "type": "decidable (iff (eq.{1} bool (band bool.ff bool.ff) bool.tt) (and (eq.{1} bool bool.ff bool.tt) (eq.{1} bool bool.ff bool.tt)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "dep", "name": "bxor", "uparams": [], "type": "bool → bool → bool"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 174, "uparams": [], "type": "decidable (iff (eq.{1} bool (bxor bool.ff bool.ff) bool.tt) (xor (eq.{1} bool bool.ff bool.tt) (eq.{1} bool bool.ff bool.tt)))"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 178, "uparams": [], "type": "decidable (iff (eq.{1} bool (bor bool.ff bool.tt) bool.tt) (or (eq.{1} bool bool.ff bool.tt) (eq.{1} bool bool.tt bool.tt)))"},
{"kind": "class", "name": "comm_group", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "comm_group.to_group", "class": "group", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "comm_group", "type": "comm_group.{u} α"}], "coercion_like": 1, "type": "group.{u} α"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 179, "uparams": [], "type": "decidable (iff (eq.{1} bool (band bool.ff bool.tt) bool.tt) (and (eq.{1} bool bool.ff bool.tt) (eq.{1} bool bool.tt bool.tt)))"},
{"kind": "instance", "name": "comm_group.to_comm_monoid", "class": "comm_monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "comm_group", "type": "comm_group.{u} α"}], "coercion_like": 1, "type": "comm_monoid.{u} α"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 174, "uparams": [], "type": "decidable (iff (eq.{1} bool (bxor bool.ff bool.tt) bool.tt) (xor (eq.{1} bool bool.ff bool.tt) (eq.{1} bool bool.tt bool.tt)))"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 178, "uparams": [], "type": "decidable (iff (eq.{1} bool (bor bool.tt bool.ff) bool.tt) (or (eq.{1} bool bool.tt bool.tt) (eq.{1} bool bool.ff bool.tt)))"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 179, "uparams": [], "type": "decidable (iff (eq.{1} bool (band bool.tt bool.ff) bool.tt) (and (eq.{1} bool bool.tt bool.tt) (eq.{1} bool bool.ff bool.tt)))"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 174, "uparams": [], "type": "decidable (iff (eq.{1} bool (bxor bool.tt bool.ff) bool.tt) (xor (eq.{1} bool bool.tt bool.tt) (eq.{1} bool bool.ff bool.tt)))"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 178, "uparams": [], "type": "decidable (iff (eq.{1} bool (bor bool.tt bool.tt) bool.tt) (or (eq.{1} bool bool.tt bool.tt) (eq.{1} bool bool.tt bool.tt)))"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 179, "uparams": [], "type": "decidable (iff (eq.{1} bool (band bool.tt bool.tt) bool.tt) (and (eq.{1} bool bool.tt bool.tt) (eq.{1} bool bool.tt bool.tt)))"},
{"kind": "dep", "name": "has_mul.mul", "uparams": ["u"], "type": "Π (α : Type u), has_mul.{u} α → α → α → α"},
{"kind": "instance", "name": "semigroup_to_is_associative", "class": "is_associative", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "semigroup", "type": "semigroup.{u} α"}], "coercion_like": 0, "type": "is_associative.{u} α (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α _inst_1))"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "problem", "class": "decidable", "max_depth": 2, "steps": 174, "uparams": [], "type": "decidable (iff (eq.{1} bool (bxor bool.tt bool.tt) bool.tt) (xor (eq.{1} bool bool.tt bool.tt) (eq.{1} bool bool.tt bool.tt)))"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "instance", "name": "comm_semigroup_to_is_commutative", "class": "is_commutative", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "comm_semigroup", "type": "comm_semigroup.{u} α"}], "coercion_like": 0, "type": "is_commutative.{u} α (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@comm_semigroup.to_semigroup.{u} α _inst_1)))"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "left_cancel_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "left_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "right_cancel_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "right_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "left_cancel_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "left_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "right_cancel_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "right_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "instance", "name": "group.to_left_cancel_semigroup", "class": "left_cancel_semigroup", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "group", "type": "group.{u} α"}], "coercion_like": 1, "type": "left_cancel_semigroup.{u} α"},
{"kind": "instance", "name": "group.to_right_cancel_semigroup", "class": "right_cancel_semigroup", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "group", "type": "group.{u} α"}], "coercion_like": 1, "type": "right_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 101, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 101, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 102, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "class", "name": "add_semigroup", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "group.{u} α"},
{"kind": "instance", "name": "add_semigroup.to_has_add", "class": "has_add", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_semigroup", "type": "add_semigroup.{u} α"}], "coercion_like": 1, "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 102, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 102, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 102, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 103, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 103, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "class", "name": "add_comm_semigroup", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "add_comm_semigroup.to_add_semigroup", "class": "add_semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_comm_semigroup", "type": "add_comm_semigroup.{u} α"}], "coercion_like": 1, "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 103, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 103, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 103, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 104, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 104, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "class", "name": "add_left_cancel_semigroup", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "add_left_cancel_semigroup.to_add_semigroup", "class": "add_semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_left_cancel_semigroup", "type": "add_left_cancel_semigroup.{u} α"}], "coercion_like": 1, "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 104, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 104, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 104, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 105, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 105, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "class", "name": "add_right_cancel_semigroup", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "add_right_cancel_semigroup.to_add_semigroup", "class": "add_semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_right_cancel_semigroup", "type": "add_right_cancel_semigroup.{u} α"}], "coercion_like": 1, "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 105, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 105, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 105, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 105, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 106, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 106, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 106, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "class", "name": "add_monoid", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "add_monoid.to_add_semigroup", "class": "add_semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_monoid", "type": "add_monoid.{u} α"}], "coercion_like": 1, "type": "add_semigroup.{u} α"},
{"kind": "instance", "name": "add_monoid.to_has_zero", "class": "has_zero", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_monoid", "type": "add_monoid.{u} α"}], "coercion_like": 1, "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 106, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 106, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 106, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 106, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 106, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 107, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 107, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 107, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 107, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "class", "name": "add_comm_monoid", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "add_comm_monoid.to_add_monoid", "class": "add_monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_comm_monoid", "type": "add_comm_monoid.{u} α"}], "coercion_like": 1, "type": "add_monoid.{u} α"},
{"kind": "instance", "name": "add_comm_monoid.to_add_comm_semigroup", "class": "add_comm_semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_comm_monoid", "type": "add_comm_monoid.{u} α"}], "coercion_like": 1, "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 107, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 107, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 107, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 107, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 107, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 107, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 108, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 108, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 108, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 108, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "class", "name": "add_group", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "add_group.to_add_monoid", "class": "add_monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_group", "type": "add_group.{u} α"}], "coercion_like": 1, "type": "add_monoid.{u} α"},
{"kind": "instance", "name": "add_group.to_has_neg", "class": "has_neg", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_group", "type": "add_group.{u} α"}], "coercion_like": 1, "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 108, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 108, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 108, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 108, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 108, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 108, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 108, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 109, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 109, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 109, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 109, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 109, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "class", "name": "add_comm_group", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "instance", "name": "add_comm_group.to_add_group", "class": "add_group", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_comm_group", "type": "add_comm_group.{u} α"}], "coercion_like": 1, "type": "add_group.{u} α"},
{"kind": "instance", "name": "add_comm_group.to_add_comm_monoid", "class": "add_comm_monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_comm_group", "type": "add_comm_group.{u} α"}], "coercion_like": 1, "type": "add_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable p"},
{"kind": "problem", "class": "has_lt", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_lt.{0} name"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 11, "uparams": [], "type": "Pi (a : name) (b : name), (decidable (has_lt.lt.{0} name name.has_lt a b))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 33, "uparams": [], "type": "decidable (eq.{1} bool (exceptional.to_bool declaration (environment.get env tgt)) bool.ff)"},
{"kind": "instance", "name": "add_group.to_left_cancel_add_semigroup", "class": "add_left_cancel_semigroup", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_group", "type": "add_group.{u} α"}], "coercion_like": 1, "type": "add_left_cancel_semigroup.{u} α"},
{"kind": "instance", "name": "add_group.to_right_cancel_add_semigroup", "class": "add_right_cancel_semigroup", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "add_group", "type": "add_group.{u} α"}], "coercion_like": 1, "type": "add_right_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_semigroup.{u} α"},
{"kind": "dep", "name": "has_add.add", "uparams": ["u"], "type": "Π (α : Type u), has_add.{u} α → α → α → α"},
{"kind": "instance", "name": "add_semigroup_to_is_eq_associative", "class": "is_associative", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "add_semigroup", "type": "add_semigroup.{u} α"}], "coercion_like": 0, "type": "is_associative.{u} α (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α _inst_1))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 16, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "instance", "name": "add_comm_semigroup_to_is_eq_commutative", "class": "is_commutative", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "add_comm_semigroup", "type": "add_comm_semigroup.{u} α"}], "coercion_like": 0, "type": "is_commutative.{u} α (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_comm_semigroup.to_add_semigroup.{u} α _inst_1)))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "instance", "name": "add_group_has_sub", "class": "has_sub", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "add_group", "type": "add_group.{u} α"}], "coercion_like": 1, "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "add_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "add_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable c"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "is_irrefl", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "is_irrefl.{u} α lt"},
{"kind": "ignored_problem", "class": "is_trans", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "is_trans.{u} α lt"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 2, "steps": 7, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 109, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 109, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 109, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 110, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 110, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "class", "name": "distrib", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "distrib.to_has_mul", "class": "has_mul", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "distrib", "type": "distrib.{u} α"}], "coercion_like": 1, "type": "has_mul.{u} α"},
{"kind": "instance", "name": "distrib.to_has_add", "class": "has_add", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "distrib", "type": "distrib.{u} α"}], "coercion_like": 1, "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 110, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 110, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 110, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 111, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 111, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))"},
{"kind": "class", "name": "mul_zero_class", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "mul_zero_class.to_has_mul", "class": "has_mul", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "mul_zero_class", "type": "mul_zero_class.{u} α"}], "coercion_like": 1, "type": "has_mul.{u} α"},
{"kind": "instance", "name": "mul_zero_class.to_has_zero", "class": "has_zero", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "mul_zero_class", "type": "mul_zero_class.{u} α"}], "coercion_like": 1, "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 111, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "class", "name": "ordered_cancel_comm_monoid", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "ordered_cancel_comm_monoid.to_add_comm_monoid", "class": "add_comm_monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_cancel_comm_monoid", "type": "ordered_cancel_comm_monoid.{u} α"}], "coercion_like": 1, "type": "add_comm_monoid.{u} α"},
{"kind": "class", "name": "zero_ne_one_class", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "zero_ne_one_class.to_has_zero", "class": "has_zero", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "zero_ne_one_class", "type": "zero_ne_one_class.{u} α"}], "coercion_like": 1, "type": "has_zero.{u} α"},
{"kind": "instance", "name": "ordered_cancel_comm_monoid.to_add_left_cancel_semigroup", "class": "add_left_cancel_semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_cancel_comm_monoid", "type": "ordered_cancel_comm_monoid.{u} α"}], "coercion_like": 1, "type": "add_left_cancel_semigroup.{u} α"},
{"kind": "instance", "name": "zero_ne_one_class.to_has_one", "class": "has_one", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "zero_ne_one_class", "type": "zero_ne_one_class.{u} α"}], "coercion_like": 1, "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "instance", "name": "ordered_cancel_comm_monoid.to_add_right_cancel_semigroup", "class": "add_right_cancel_semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_cancel_comm_monoid", "type": "ordered_cancel_comm_monoid.{u} α"}], "coercion_like": 1, "type": "add_right_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "instance", "name": "ordered_cancel_comm_monoid.to_partial_order", "class": "partial_order", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_cancel_comm_monoid", "type": "ordered_cancel_comm_monoid.{u} α"}], "coercion_like": 1, "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sizeof.{u+1} (rbnode.{u} α)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "dep", "name": "rbnode.color", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "rbnode.color.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "rbnode.color"},{"name": "b", "type": "rbnode.color"}], "coercion_like": 0, "type": "decidable (@eq.{1} rbnode.color a b)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 112, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "class", "name": "semiring", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "instance", "name": "semiring.to_add_comm_monoid", "class": "add_comm_monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "semiring", "type": "semiring.{u} α"}], "coercion_like": 1, "type": "add_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "instance", "name": "semiring.to_monoid", "class": "monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "semiring", "type": "semiring.{u} α"}], "coercion_like": 1, "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "instance", "name": "semiring.to_distrib", "class": "distrib", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "semiring", "type": "semiring.{u} α"}], "coercion_like": 1, "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "instance", "name": "semiring.to_mul_zero_class", "class": "mul_zero_class", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "semiring", "type": "semiring.{u} α"}], "coercion_like": 1, "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 2, "steps": 7, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 2, "steps": 11, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 113, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "decidable (eq.{1} rbnode.color (rbnode.get_color.{u} α a) rbnode.color.red)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 2, "uparams": ["u"], "type": "decidable (eq.{1} rbnode.color (rbnode.get_color.{u} α b) rbnode.color.red)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "class", "name": "comm_semiring", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "comm_semiring.to_semiring", "class": "semiring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "comm_semiring", "type": "comm_semiring.{u} α"}], "coercion_like": 1, "type": "semiring.{u} α"},
{"kind": "instance", "name": "comm_semiring.to_comm_monoid", "class": "comm_monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "comm_semiring", "type": "comm_semiring.{u} α"}], "coercion_like": 1, "type": "comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "instance", "name": "comm_semiring_has_dvd", "class": "has_dvd", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "comm_semiring", "type": "comm_semiring.{u} α"}], "coercion_like": 1, "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "class", "name": "ordered_comm_group", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "instance", "name": "ordered_comm_group.to_add_comm_group", "class": "add_comm_group", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_comm_group", "type": "ordered_comm_group.{u} α"}], "coercion_like": 1, "type": "add_comm_group.{u} α"},
{"kind": "instance", "name": "ordered_comm_group.to_partial_order", "class": "partial_order", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_comm_group", "type": "ordered_comm_group.{u} α"}], "coercion_like": 1, "type": "partial_order.{u} α"},
{"kind": "dep", "name": "rbtree", "uparams": ["u"], "type": "Π (α : Type u), (α → α → Prop) → Type u"},
{"kind": "instance", "name": "rbtree.has_mem", "class": "has_mem", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "lt", "type": "α → α → Prop"}], "coercion_like": 0, "type": "has_mem.{u u} α (rbtree.{u} α lt)"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "add_left_cancel_semigroup", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "add_left_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_right_cancel_semigroup", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "add_right_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "instance", "name": "ordered_comm_group.to_ordered_cancel_comm_monoid", "class": "ordered_cancel_comm_monoid", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_comm_group", "type": "ordered_comm_group.{u} α"}], "coercion_like": 1, "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 1, "steps": 18, "uparams": ["u"], "type": "has_repr.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "instance", "name": "rbtree.has_repr", "class": "has_repr", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "lt", "type": "α → α → Prop"},{"name": "_inst_1", "class": "has_repr", "type": "has_repr.{u} α"}], "coercion_like": 0, "type": "has_repr.{u} (rbtree.{u} α lt)"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 114, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "dep", "name": "rbmap", "uparams": ["u","v"], "type": "Π (α : Type u), Type v → (α → α → Prop) → Type (max u v)"},
{"kind": "instance", "name": "rbmap.has_mem", "class": "has_mem", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "lt", "type": "α → α → Prop"}], "coercion_like": 0, "type": "has_mem.{u (max u v)} α (rbmap.{u v} α β lt)"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 2, "steps": 37, "uparams": ["u","v"], "type": "has_repr.{(max u v)} (list.{(max u v)} (prod.{u v} α β))"},
{"kind": "instance", "name": "rbmap.has_repr", "class": "has_repr", "from_extends": 0, "uparams": ["u","v"], "params": [{"name": "α", "type": "Type u"},{"name": "β", "type": "Type v"},{"name": "lt", "type": "α → α → Prop"},{"name": "_inst_1", "class": "has_repr", "type": "has_repr.{u} α"},{"name": "_inst_2", "class": "has_repr", "type": "has_repr.{v} β"}], "coercion_like": 0, "type": "has_repr.{(max u v)} (rbmap.{u v} α β lt)"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "class", "name": "ring", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "instance", "name": "ring.to_add_comm_group", "class": "add_comm_group", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ring", "type": "ring.{u} α"}], "coercion_like": 1, "type": "add_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "instance", "name": "ring.to_monoid", "class": "monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ring", "type": "ring.{u} α"}], "coercion_like": 1, "type": "monoid.{u} α"},
{"kind": "instance", "name": "ring.to_distrib", "class": "distrib", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ring", "type": "ring.{u} α"}], "coercion_like": 1, "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α) (b : α), (decidable (lt a b))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "instance", "name": "ring.to_semiring", "class": "semiring", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ring", "type": "ring.{u} α"}], "coercion_like": 1, "type": "semiring.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_left_cancel_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_left_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "add_left_cancel_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_left_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "class", "name": "comm_ring", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "instance", "name": "comm_ring.to_ring", "class": "ring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "comm_ring", "type": "comm_ring.{u} α"}], "coercion_like": 1, "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "instance", "name": "comm_ring.to_comm_semigroup", "class": "comm_semigroup", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "comm_ring", "type": "comm_ring.{u} α"}], "coercion_like": 1, "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "instance", "name": "comm_ring.to_comm_semiring", "class": "comm_semiring", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "comm_ring", "type": "comm_ring.{u} α"}], "coercion_like": 1, "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "comm_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "comm_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "comm_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "comm_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "comm_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "semiring.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "comm_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "comm_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_dvd", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_dvd.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "comm_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : eq.{u+1} α (mul a b) zero), (or (eq.{u+1} α a zero) (eq.{u+1} α b zero)))"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "comm_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : eq.{u+1} α (mul a b) zero), (or (eq.{u+1} α a zero) (eq.{u+1} α b zero)))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "class", "name": "no_zero_divisors", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "no_zero_divisors.to_has_mul", "class": "has_mul", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "no_zero_divisors", "type": "no_zero_divisors.{u} α"}], "coercion_like": 1, "type": "has_mul.{u} α"},
{"kind": "instance", "name": "no_zero_divisors.to_has_zero", "class": "has_zero", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "no_zero_divisors", "type": "no_zero_divisors.{u} α"}], "coercion_like": 1, "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "no_zero_divisors", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "no_zero_divisors.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "no_zero_divisors", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "no_zero_divisors.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : eq.{u+1} α (mul a b) zero), (or (eq.{u+1} α a zero) (eq.{u+1} α b zero)))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : eq.{u+1} α (mul a b) zero), (or (eq.{u+1} α a zero) (eq.{u+1} α b zero)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "class", "name": "integral_domain", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "integral_domain.to_comm_ring", "class": "comm_ring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "integral_domain", "type": "integral_domain.{u} α"}], "coercion_like": 1, "type": "comm_ring.{u} α"},
{"kind": "instance", "name": "integral_domain.to_no_zero_divisors", "class": "no_zero_divisors", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "integral_domain", "type": "integral_domain.{u} α"}], "coercion_like": 1, "type": "no_zero_divisors.{u} α"},
{"kind": "instance", "name": "integral_domain.to_zero_ne_one_class", "class": "zero_ne_one_class", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "integral_domain", "type": "integral_domain.{u} α"}], "coercion_like": 1, "type": "zero_ne_one_class.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "no_zero_divisors", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "no_zero_divisors.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "no_zero_divisors", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "no_zero_divisors.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 5, "steps": 7, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 5, "steps": 7, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 5, "steps": 7, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "no_zero_divisors", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "no_zero_divisors.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "integral_domain", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "integral_domain.{u} α"},
{"kind": "ignored_problem", "class": "no_zero_divisors", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "no_zero_divisors.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 5, "steps": 7, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "integral_domain", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "integral_domain.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "comm_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "no_zero_divisors", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "no_zero_divisors.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "no_zero_divisors", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "no_zero_divisors.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 118, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 115, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "class", "name": "division_ring", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "instance", "name": "division_ring.to_ring", "class": "ring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "division_ring", "type": "division_ring.{u} α"}], "coercion_like": 1, "type": "ring.{u} α"},
{"kind": "instance", "name": "division_ring.to_has_inv", "class": "has_inv", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "division_ring", "type": "division_ring.{u} α"}], "coercion_like": 1, "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "instance", "name": "division_ring.to_zero_ne_one_class", "class": "zero_ne_one_class", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "division_ring", "type": "division_ring.{u} α"}], "coercion_like": 1, "type": "zero_ne_one_class.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "instance", "name": "division_ring_has_div", "class": "has_div", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "division_ring", "type": "division_ring.{u} α"},{"name": "_inst_2", "class": "division_ring", "type": "division_ring.{u} α"}], "coercion_like": 0, "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "zero_ne_one_class", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "zero_ne_one_class.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "zero_ne_one_class", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "zero_ne_one_class.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "class", "name": "decidable_linear_ordered_comm_group", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "instance", "name": "decidable_linear_ordered_comm_group.to_add_comm_group", "class": "add_comm_group", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "decidable_linear_ordered_comm_group", "type": "decidable_linear_ordered_comm_group.{u} α"}], "coercion_like": 1, "type": "add_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "instance", "name": "decidable_linear_ordered_comm_group.to_decidable_linear_order", "class": "decidable_linear_order", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "decidable_linear_ordered_comm_group", "type": "decidable_linear_ordered_comm_group.{u} α"}], "coercion_like": 1, "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "semiring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "instance", "name": "decidable_linear_ordered_comm_group.to_ordered_comm_group", "class": "ordered_comm_group", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "decidable_linear_ordered_comm_group", "type": "decidable_linear_ordered_comm_group.{u} α"}], "coercion_like": 1, "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "zero_ne_one_class", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "zero_ne_one_class.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "zero_ne_one_class", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "zero_ne_one_class.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "zero_ne_one_class", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "zero_ne_one_class.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "zero_ne_one_class", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "zero_ne_one_class.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 116, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 2, "steps": 4, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 117, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "class", "name": "decidable_linear_ordered_cancel_comm_monoid", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "instance", "name": "decidable_linear_ordered_cancel_comm_monoid.to_ordered_cancel_comm_monoid", "class": "ordered_cancel_comm_monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "decidable_linear_ordered_cancel_comm_monoid", "type": "decidable_linear_ordered_cancel_comm_monoid.{u} α"}], "coercion_like": 1, "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 119, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "instance", "name": "decidable_linear_ordered_cancel_comm_monoid.to_decidable_linear_order", "class": "decidable_linear_order", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "decidable_linear_ordered_cancel_comm_monoid", "type": "decidable_linear_ordered_cancel_comm_monoid.{u} α"}], "coercion_like": 1, "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "class", "name": "field", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "field.to_division_ring", "class": "division_ring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "field", "type": "field.{u} α"}], "coercion_like": 1, "type": "division_ring.{u} α"},
{"kind": "instance", "name": "field.to_comm_ring", "class": "comm_ring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "field", "type": "field.{u} α"}], "coercion_like": 1, "type": "comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "zero_ne_one_class", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "zero_ne_one_class.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 5, "steps": 7, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 8, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 14, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 120, "uparams": ["u"], "type": "has_sizeof.{0} (eq.{u+1} α (inv zero) zero)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 126, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 121, "uparams": ["u"], "type": "has_sizeof.{0} (eq.{u+1} α (inv zero) zero)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "class", "name": "discrete_field", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))"},
{"kind": "instance", "name": "discrete_field.to_field", "class": "field", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "discrete_field", "type": "discrete_field.{u} α"}], "coercion_like": 1, "type": "field.{u} α"},
{"kind": "instance", "name": "discrete_field.has_decidable_eq", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "c", "class": "discrete_field", "type": "discrete_field.{u} α"},{"name": "a", "type": "α"},{"name": "b", "type": "α"}], "coercion_like": 0, "type": "decidable (@eq.{u+1} α a b)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 10, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (division_ring.to_zero_ne_one_class.{u} α (field.to_division_ring.{u} α (discrete_field.to_field.{u} α _inst_1))))))"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "instance", "name": "discrete_field.to_integral_domain", "class": "integral_domain", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "discrete_field", "type": "discrete_field.{u} α"},{"name": "s", "class": "discrete_field", "type": "discrete_field.{u} α"}], "coercion_like": 0, "type": "integral_domain.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "integral_domain", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "integral_domain.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α d (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α c (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 46, "uparams": ["u"], "type": "decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "class", "name": "ordered_semiring", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "ordered_semiring.to_semiring", "class": "semiring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_semiring", "type": "ordered_semiring.{u} α"}], "coercion_like": 1, "type": "semiring.{u} α"},
{"kind": "instance", "name": "ordered_semiring.to_ordered_cancel_comm_monoid", "class": "ordered_cancel_comm_monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_semiring", "type": "ordered_semiring.{u} α"}], "coercion_like": 1, "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 9, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 127, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_semiring.to_ordered_cancel_comm_monoid.{u} α (ordered_semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left mul_le_mul_of_nonneg_left mul_le_mul_of_nonneg_right mul_lt_mul_of_pos_left mul_lt_mul_of_pos_right))))) zero one)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_semiring.to_ordered_cancel_comm_monoid.{u} α (ordered_semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left mul_le_mul_of_nonneg_left mul_le_mul_of_nonneg_right mul_lt_mul_of_pos_left mul_lt_mul_of_pos_right))))) zero one)"},
{"kind": "class", "name": "linear_ordered_semiring", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "linear_ordered_semiring.to_ordered_semiring", "class": "ordered_semiring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "linear_ordered_semiring", "type": "linear_ordered_semiring.{u} α"}], "coercion_like": 1, "type": "ordered_semiring.{u} α"},
{"kind": "instance", "name": "linear_ordered_semiring.to_linear_order", "class": "linear_order", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "linear_ordered_semiring", "type": "linear_ordered_semiring.{u} α"}], "coercion_like": 1, "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_semiring.to_ordered_cancel_comm_monoid.{u} α (ordered_semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left mul_le_mul_of_nonneg_left mul_le_mul_of_nonneg_right mul_lt_mul_of_pos_left mul_lt_mul_of_pos_right))))) zero one)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 128, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_semiring.to_ordered_cancel_comm_monoid.{u} α (ordered_semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left mul_le_mul_of_nonneg_left mul_le_mul_of_nonneg_right mul_lt_mul_of_pos_left mul_lt_mul_of_pos_right))))) zero one)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "class", "name": "decidable_linear_ordered_semiring", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "decidable_linear_ordered_semiring.to_linear_ordered_semiring", "class": "linear_ordered_semiring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "decidable_linear_ordered_semiring", "type": "decidable_linear_ordered_semiring.{u} α"}], "coercion_like": 1, "type": "linear_ordered_semiring.{u} α"},
{"kind": "instance", "name": "decidable_linear_ordered_semiring.to_decidable_linear_order", "class": "decidable_linear_order", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "decidable_linear_ordered_semiring", "type": "decidable_linear_ordered_semiring.{u} α"}], "coercion_like": 1, "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 10, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 3, "steps": 12, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 129, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "class", "name": "ordered_ring", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "ordered_ring.to_ring", "class": "ring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_ring", "type": "ordered_ring.{u} α"}], "coercion_like": 1, "type": "ring.{u} α"},
{"kind": "instance", "name": "ordered_ring.to_ordered_comm_group", "class": "ordered_comm_group", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_ring", "type": "ordered_ring.{u} α"}], "coercion_like": 1, "type": "ordered_comm_group.{u} α"},
{"kind": "instance", "name": "ordered_ring.to_zero_ne_one_class", "class": "zero_ne_one_class", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_ring", "type": "ordered_ring.{u} α"}], "coercion_like": 1, "type": "zero_ne_one_class.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 11, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 11, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 13, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 11, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 13, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 11, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "add_left_cancel_semigroup", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "add_left_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_right_cancel_semigroup", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "add_right_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "instance", "name": "ordered_ring.to_ordered_semiring", "class": "ordered_semiring", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "ordered_ring", "type": "ordered_ring.{u} α"}], "coercion_like": 1, "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 4, "steps": 9, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 13, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 13, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 13, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 4, "steps": 13, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 130, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)"},
{"kind": "class", "name": "linear_ordered_ring", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "linear_ordered_ring.to_ordered_ring", "class": "ordered_ring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "linear_ordered_ring", "type": "linear_ordered_ring.{u} α"}], "coercion_like": 1, "type": "ordered_ring.{u} α"},
{"kind": "instance", "name": "linear_ordered_ring.to_linear_order", "class": "linear_order", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "linear_ordered_ring", "type": "linear_ordered_ring.{u} α"}], "coercion_like": 1, "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "add_left_cancel_semigroup", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_left_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_right_cancel_semigroup", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_right_cancel_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_ring.{u} α"},
{"kind": "instance", "name": "linear_ordered_ring.to_linear_ordered_semiring", "class": "linear_ordered_semiring", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "linear_ordered_ring", "type": "linear_ordered_ring.{u} α"}], "coercion_like": 1, "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 10, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 14, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 14, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 10, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 14, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 10, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 10, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 10, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 5, "steps": 10, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 14, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 3, "steps": 7, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 5, "steps": 14, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 131, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "class", "name": "linear_ordered_comm_ring", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "linear_ordered_comm_ring.to_linear_ordered_ring", "class": "linear_ordered_ring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "linear_ordered_comm_ring", "type": "linear_ordered_comm_ring.{u} α"}], "coercion_like": 1, "type": "linear_ordered_ring.{u} α"},
{"kind": "instance", "name": "linear_ordered_comm_ring.to_comm_monoid", "class": "comm_monoid", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "linear_ordered_comm_ring", "type": "linear_ordered_comm_ring.{u} α"}], "coercion_like": 1, "type": "comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_ordered_ring.{u} α"},
{"kind": "instance", "name": "linear_ordered_comm_ring.to_integral_domain", "class": "integral_domain", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "linear_ordered_comm_ring", "type": "linear_ordered_comm_ring.{u} α"}], "coercion_like": 1, "type": "integral_domain.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 132, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 133, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "class", "name": "decidable_linear_ordered_comm_ring", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring", "class": "linear_ordered_comm_ring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "decidable_linear_ordered_comm_ring", "type": "decidable_linear_ordered_comm_ring.{u} α"}], "coercion_like": 1, "type": "linear_ordered_comm_ring.{u} α"},
{"kind": "instance", "name": "decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_comm_group", "class": "decidable_linear_ordered_comm_group", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "decidable_linear_ordered_comm_ring", "type": "decidable_linear_ordered_comm_ring.{u} α"}], "coercion_like": 1, "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_ordered_ring.{u} α"},
{"kind": "instance", "name": "decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring", "class": "decidable_linear_ordered_semiring", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "d", "class": "decidable_linear_ordered_comm_ring", "type": "decidable_linear_ordered_comm_ring.{u} α"}], "coercion_like": 1, "type": "decidable_linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 136, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "class", "name": "linear_ordered_field", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "linear_ordered_field.to_linear_ordered_ring", "class": "linear_ordered_ring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "linear_ordered_field", "type": "linear_ordered_field.{u} α"}], "coercion_like": 1, "type": "linear_ordered_ring.{u} α"},
{"kind": "instance", "name": "linear_ordered_field.to_field", "class": "field", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "linear_ordered_field", "type": "linear_ordered_field.{u} α"}], "coercion_like": 1, "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_inv", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "has_inv.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 6, "steps": 8, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 6, "steps": 8, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 6, "steps": 8, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 6, "steps": 8, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 6, "steps": 8, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 6, "steps": 8, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 6, "steps": 8, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "semiring", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "semiring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "add_semigroup", "max_depth": 7, "steps": 8, "uparams": ["u"], "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_group", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "add_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "semiring", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "semiring.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 6, "steps": 13, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 6, "steps": 8, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 6, "steps": 8, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 5, "steps": 6, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 4, "steps": 6, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "semiring", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 11, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 3, "steps": 8, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_sizeof.{u+1} α"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{u+1} (α -> α)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 137, "uparams": ["u"], "type": "has_sizeof.{0} (eq.{u+1} α (inv zero) zero)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α), (le a a))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": [], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (not (eq.{u+1} α zero one))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{0} (eq.{u+1} α (inv zero) zero)"},
{"kind": "class", "name": "discrete_linear_ordered_field", "uparams": ["u"], "params": [{"name": "α", "is_out": 0, "type": "Type.{u}"}]},
{"kind": "instance", "name": "discrete_linear_ordered_field.to_linear_ordered_field", "class": "linear_ordered_field", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "discrete_linear_ordered_field", "type": "discrete_linear_ordered_field.{u} α"}], "coercion_like": 1, "type": "linear_ordered_field.{u} α"},
{"kind": "instance", "name": "discrete_linear_ordered_field.to_decidable_linear_ordered_comm_ring", "class": "decidable_linear_ordered_comm_ring", "from_extends": 1, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "discrete_linear_ordered_field", "type": "discrete_linear_ordered_field.{u} α"}], "coercion_like": 1, "type": "decidable_linear_ordered_comm_ring.{u} α"},
{"kind": "instance", "name": "discrete_linear_ordered_field.to_discrete_field", "class": "discrete_field", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "s", "class": "discrete_linear_ordered_field", "type": "discrete_linear_ordered_field.{u} α"}], "coercion_like": 1, "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 5, "steps": 7, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 7, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 5, "steps": 7, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 7, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 7, "steps": 8, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 7, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 7, "steps": 16, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "discrete_linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 4, "steps": 5, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 6, "steps": 7, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 48, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 48, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 48, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 48, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 48, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 48, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 48, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 7, "steps": 61, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 48, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 62, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 62, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 18, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 62, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 48, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a a)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 18, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 62, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 62, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 62, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 7, "steps": 61, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 9, "steps": 71, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 62, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 9, "steps": 71, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 62, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 9, "steps": 71, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 48, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a a)"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 62, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 9, "steps": 71, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 62, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 62, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 9, "steps": 71, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 18, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 9, "steps": 71, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 18, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 67, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 62, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 48, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) b c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 211, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 48, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 38, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 6, "steps": 20, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 211, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 4, "steps": 52, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (decidable_linear_ordered_cancel_comm_monoid.to_ordered_cancel_comm_monoid.{u} α _inst_1)))) b c)"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 22, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 33, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 211, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 8, "steps": 80, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 6, "steps": 20, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 38, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 211, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 4, "steps": 52, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (decidable_linear_ordered_cancel_comm_monoid.to_ordered_cancel_comm_monoid.{u} α _inst_1)))) b c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 22, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 33, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 8, "steps": 80, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_cancel_comm_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 7, "steps": 29, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 7, "steps": 29, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 7, "steps": 11, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 8, "steps": 20, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 7, "steps": 11, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 7, "steps": 29, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 7, "steps": 11, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 8, "steps": 20, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 7, "steps": 11, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 7, "steps": 11, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 8, "steps": 20, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 8, "steps": 20, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 7, "steps": 29, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 8, "steps": 31, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 7, "steps": 29, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 23, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 8, "steps": 20, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 23, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 7, "steps": 11, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 23, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 7, "steps": 11, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 6, "steps": 10, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 8, "steps": 31, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 7, "steps": 29, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 8, "steps": 20, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 23, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 23, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 8, "steps": 20, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 119, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 4, "steps": 53, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (decidable_linear_ordered_comm_group.to_ordered_comm_group.{u} α _inst_1)))) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (decidable_linear_ordered_comm_group.to_add_comm_group.{u} α _inst_1))))) b)"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 7, "steps": 11, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 119, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 23, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 23, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 8, "steps": 20, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 119, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 6, "steps": 29, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 23, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 6, "steps": 29, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 8, "steps": 31, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 9, "steps": 118, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 119, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 30, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 7, "steps": 11, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 119, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 8, "steps": 31, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_group", "max_depth": 6, "steps": 28, "uparams": ["u"], "type": "add_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 119, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 7, "steps": 29, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 7, "steps": 29, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 8, "steps": 89, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_semigroup", "max_depth": 9, "steps": 31, "uparams": ["u"], "type": "add_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 8, "steps": 20, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 6, "steps": 29, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 8, "steps": 16, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 8, "steps": 31, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 7, "steps": 11, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 6, "steps": 29, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 4, "steps": 53, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (decidable_linear_ordered_comm_group.to_ordered_comm_group.{u} α _inst_1)))) b a)"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 4, "steps": 13, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 7, "steps": 17, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 7, "steps": 14, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 7, "steps": 14, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 7, "steps": 17, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 7, "steps": 14, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 6, "steps": 9, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 7, "steps": 17, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 7, "steps": 18, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 7, "steps": 17, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 7, "steps": 18, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 6, "steps": 9, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 3, "steps": 50, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (linear_ordered_ring.to_ordered_ring.{u} α (linear_ordered_comm_ring.to_linear_ordered_ring.{u} α (decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{u} α _inst_1))))))) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (ordered_comm_group.to_add_comm_group.{u} α (ordered_ring.to_ordered_comm_group.{u} α (linear_ordered_ring.to_ordered_ring.{u} α (linear_ordered_comm_ring.to_linear_ordered_ring.{u} α (decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{u} α _inst_1))))))))) (has_sub.sub.{u} α (add_group_has_sub.{u} α (add_comm_group.to_add_group.{u} α (ordered_comm_group.to_add_comm_group.{u} α (ordered_ring.to_ordered_comm_group.{u} α (linear_ordered_ring.to_ordered_ring.{u} α (linear_ordered_comm_ring.to_linear_ordered_ring.{u} α (decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{u} α _inst_1))))))) a b))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 5, "steps": 23, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 7, "steps": 17, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 7, "steps": 14, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 7, "steps": 16, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 6, "steps": 17, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 5, "steps": 15, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_order", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "decidable_linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 7, "steps": 29, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 6, "steps": 17, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 3, "steps": 50, "uparams": ["u"], "type": "decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (linear_ordered_ring.to_ordered_ring.{u} α (linear_ordered_comm_ring.to_linear_ordered_ring.{u} α (decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{u} α _inst_1))))))) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (ordered_comm_group.to_add_comm_group.{u} α (ordered_ring.to_ordered_comm_group.{u} α (linear_ordered_ring.to_ordered_ring.{u} α (linear_ordered_comm_ring.to_linear_ordered_ring.{u} α (decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{u} α _inst_1))))))))) (has_sub.sub.{u} α (add_group_has_sub.{u} α (add_comm_group.to_add_group.{u} α (ordered_comm_group.to_add_comm_group.{u} α (ordered_ring.to_ordered_comm_group.{u} α (linear_ordered_ring.to_ordered_ring.{u} α (linear_ordered_comm_ring.to_linear_ordered_ring.{u} α (decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{u} α _inst_1))))))) a b))"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 7, "steps": 14, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 4, "steps": 13, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_ring", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "linear_ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "no_zero_divisors", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "no_zero_divisors.{u} α"},
{"kind": "ignored_problem", "class": "partial_order", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "partial_order.{u} α"},
{"kind": "ignored_problem", "class": "linear_order", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "linear_order.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 6, "steps": 17, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 7, "steps": 17, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 7, "steps": 14, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 6, "steps": 17, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 47, "uparams": ["u"], "type": "decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α (discrete_linear_ordered_field.to_discrete_field.{u} α _inst_1) (discrete_linear_ordered_field.to_discrete_field.{u} α _inst_1))))))"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 4, "steps": 10, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "decidable_linear_ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 5, "steps": 7, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "discrete_linear_ordered_field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "discrete_linear_ordered_field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "discrete_field", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "discrete_field.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 7, "steps": 12, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 7, "steps": 10, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "comm_semigroup", "max_depth": 4, "steps": 12, "uparams": ["u"], "type": "comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 5, "steps": 14, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_ring", "max_depth": 2, "steps": 5, "uparams": ["u"], "type": "linear_ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 3, "steps": 4, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 4, "steps": 13, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable_linear_ordered_comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "decidable_linear_ordered_comm_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "decidable_linear_ordered_comm_ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_ring", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "ordered_ring.{u} α"},
{"kind": "ignored_problem", "class": "ordered_comm_group", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "ordered_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "semigroup", "max_depth": 6, "steps": 15, "uparams": ["u"], "type": "semigroup.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 5, "steps": 14, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "ordered_semiring", "max_depth": 4, "steps": 7, "uparams": ["u"], "type": "ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 6, "steps": 9, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 5, "steps": 8, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 3, "steps": 6, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "instance", "name": "nat.zero_ne_one_class", "class": "zero_ne_one_class", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "zero_ne_one_class.{0} nat"},
{"kind": "instance", "name": "nat.comm_semiring", "class": "comm_semiring", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "comm_semiring.{0} nat"},
{"kind": "instance", "name": "nat.linear_order", "class": "linear_order", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "linear_order.{0} nat"},
{"kind": "problem", "class": "partial_order", "max_depth": 7, "steps": 44, "uparams": [], "type": "partial_order.{0} nat"},
{"kind": "problem", "class": "comm_semigroup", "max_depth": 5, "steps": 18, "uparams": [], "type": "comm_semigroup.{0} nat"},
{"kind": "problem", "class": "add_comm_semigroup", "max_depth": 8, "steps": 48, "uparams": [], "type": "add_comm_semigroup.{0} nat"},
{"kind": "problem", "class": "distrib", "max_depth": 7, "steps": 73, "uparams": [], "type": "distrib.{0} nat"},
{"kind": "problem", "class": "preorder", "max_depth": 8, "steps": 45, "uparams": [], "type": "preorder.{0} nat"},
{"kind": "instance", "name": "nat.decidable_linear_ordered_semiring", "class": "decidable_linear_ordered_semiring", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "decidable_linear_ordered_semiring.{0} nat"},
{"kind": "instance", "name": "nat.decidable_linear_ordered_cancel_comm_monoid", "class": "decidable_linear_ordered_cancel_comm_monoid", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "decidable_linear_ordered_cancel_comm_monoid.{0} nat"},
{"kind": "problem", "class": "linear_ordered_semiring", "max_depth": 4, "steps": 8, "uparams": [], "type": "linear_ordered_semiring.{0} nat"},
{"kind": "problem", "class": "ordered_cancel_comm_monoid", "max_depth": 6, "steps": 17, "uparams": [], "type": "ordered_cancel_comm_monoid.{0} nat"},
{"kind": "problem", "class": "add_comm_monoid", "max_depth": 7, "steps": 18, "uparams": [], "type": "add_comm_monoid.{0} nat"},
{"kind": "instance", "name": "nat.add_comm_monoid", "class": "add_comm_monoid", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "add_comm_monoid.{0} nat"},
{"kind": "problem", "class": "add_monoid", "max_depth": 8, "steps": 44, "uparams": [], "type": "add_monoid.{0} nat"},
{"kind": "instance", "name": "nat.add_monoid", "class": "add_monoid", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "add_monoid.{0} nat"},
{"kind": "problem", "class": "monoid", "max_depth": 7, "steps": 44, "uparams": [], "type": "monoid.{0} nat"},
{"kind": "instance", "name": "nat.monoid", "class": "monoid", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "monoid.{0} nat"},
{"kind": "problem", "class": "comm_monoid", "max_depth": 3, "steps": 5, "uparams": [], "type": "comm_monoid.{0} nat"},
{"kind": "instance", "name": "nat.comm_monoid", "class": "comm_monoid", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "comm_monoid.{0} nat"},
{"kind": "instance", "name": "nat.comm_semigroup", "class": "comm_semigroup", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "comm_semigroup.{0} nat"},
{"kind": "problem", "class": "semigroup", "max_depth": 1, "steps": 2, "uparams": [], "type": "semigroup.{0} nat"},
{"kind": "instance", "name": "nat.semigroup", "class": "semigroup", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "semigroup.{0} nat"},
{"kind": "instance", "name": "nat.add_comm_semigroup", "class": "add_comm_semigroup", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "add_comm_semigroup.{0} nat"},
{"kind": "problem", "class": "add_semigroup", "max_depth": 1, "steps": 2, "uparams": [], "type": "add_semigroup.{0} nat"},
{"kind": "instance", "name": "nat.add_semigroup", "class": "add_semigroup", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "add_semigroup.{0} nat"},
{"kind": "instance", "name": "nat.distrib", "class": "distrib", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "distrib.{0} nat"},
{"kind": "problem", "class": "semiring", "max_depth": 6, "steps": 17, "uparams": [], "type": "semiring.{0} nat"},
{"kind": "instance", "name": "nat.semiring", "class": "semiring", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "semiring.{0} nat"},
{"kind": "problem", "class": "ordered_semiring", "max_depth": 5, "steps": 16, "uparams": [], "type": "ordered_semiring.{0} nat"},
{"kind": "instance", "name": "nat.ordered_semiring", "class": "ordered_semiring", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "ordered_semiring.{0} nat"},
{"kind": "problem", "class": "linear_order", "max_depth": 0, "steps": 1, "uparams": [], "type": "linear_order.{0} nat"},
{"kind": "problem", "class": "decidable_linear_order", "max_depth": 1, "steps": 2, "uparams": [], "type": "decidable_linear_order.{0} nat"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 28, "uparams": [], "type": "decidable (has_le.le.{0} nat (preorder.to_has_le.{0} nat (partial_order.to_preorder.{0} nat (linear_order.to_partial_order.{0} nat (linear_order.mk.{0} nat (decidable_linear_order.le.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.lt.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_refl.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_trans.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.lt_iff_le_not_le.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_antisymm.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_total.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)))))) (nat.succ x) (nat.succ y))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 29, "uparams": [], "type": "decidable (has_le.le.{0} nat nat.has_le m n)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 29, "uparams": [], "type": "decidable (has_le.le.{0} nat (preorder.to_has_le.{0} nat (partial_order.to_preorder.{0} nat (linear_order.to_partial_order.{0} nat (linear_order.mk.{0} nat (decidable_linear_order.le.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.lt.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_refl.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_trans.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.lt_iff_le_not_le.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_antisymm.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_total.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)))))) x y)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 29, "uparams": [], "type": "decidable (has_le.le.{0} nat nat.has_le x y)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 30, "uparams": [], "type": "decidable (eq.{1} nat m n)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 28, "uparams": [], "type": "decidable (has_lt.lt.{0} nat (preorder.to_has_lt.{0} nat (partial_order.to_preorder.{0} nat (ordered_cancel_comm_monoid.to_partial_order.{0} nat (ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) m n)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 99, "uparams": [], "type": "decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) y) (has_le.le.{0} nat nat.has_le y x))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 99, "uparams": [], "type": "decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) b) (has_le.le.{0} nat nat.has_le b a))"},
{"kind": "dep", "name": "bit0", "uparams": ["u"], "type": "Π (α : Type u), has_add.{u} α → α → α"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 28, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 68, "uparams": [], "type": "decidable (not (has_lt.lt.{0} nat nat.has_lt (has_add.add.{0} nat nat.has_add k (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 99, "uparams": [], "type": "decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) y) (has_le.le.{0} nat nat.has_le y x))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 28, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt (nat.succ x) y)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 99, "uparams": [], "type": "decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) b) (has_le.le.{0} nat nat.has_le b (has_zero.zero.{0} nat nat.has_zero)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 99, "uparams": [], "type": "decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) k) (has_le.le.{0} nat nat.has_le k m))"},
{"kind": "problem", "class": "mul_zero_class", "max_depth": 1, "steps": 2, "uparams": [], "type": "mul_zero_class.{0} nat"},
{"kind": "problem", "class": "zero_ne_one_class", "max_depth": 0, "steps": 1, "uparams": [], "type": "zero_ne_one_class.{0} nat"},
{"kind": "problem", "class": "has_andthen", "max_depth": 0, "steps": 2, "uparams": [], "type": "has_andthen.{0 0 0} (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (list.{0} (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 28, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt a b)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 29, "uparams": [], "type": "decidable (has_le.le.{0} nat nat.has_le n m)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p m)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 30, "uparams": [], "type": "decidable (eq.{1} nat y (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 30, "uparams": [], "type": "decidable (eq.{1} nat z (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (eq.{1} nat (has_mod.mod.{0} nat nat.has_mod x (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))) (has_one.one.{0} nat nat.has_one))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable p)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable p)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable p)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable p)"},
{"kind": "problem", "class": "has_dvd", "max_depth": 1, "steps": 2, "uparams": [], "type": "has_dvd.{0} nat"},
{"kind": "problem", "class": "comm_semiring", "max_depth": 0, "steps": 1, "uparams": [], "type": "comm_semiring.{0} nat"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 28, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) (has_one.one.{0} nat nat.has_one))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 30, "uparams": [], "type": "decidable (eq.{1} nat (has_mod.mod.{0} nat nat.has_mod n m) (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "dep", "name": "has_dvd.dvd", "uparams": ["u"], "type": "Π (α : Type u), has_dvd.{u} α → α → α → Prop"},
{"kind": "instance", "name": "nat.decidable_dvd", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "nat"},{"name": "b", "type": "nat"}], "coercion_like": 0, "type": "decidable (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) a b)"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 6, "steps": 31, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 10, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 6, "steps": 31, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 10, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 6, "steps": 24, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 165, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 73, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable (or (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) n) (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))))))))))))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable (or (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) n) (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))))))))))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 172, "uparams": [], "type": "decidable (or (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) n) (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))))))))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 172, "uparams": [], "type": "decidable (or (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) n) (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))))))))))"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 73, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 1, "steps": 4, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 7, "steps": 52, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 7, "steps": 32, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 11, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 5, "steps": 11, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 7, "steps": 32, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 7, "steps": 52, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 6, "steps": 29, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 8, "steps": 39, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 6, "steps": 29, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 8, "steps": 97, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 6, "steps": 29, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 8, "steps": 39, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 99, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "monoid", "max_depth": 6, "steps": 29, "uparams": ["u"], "type": "monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 99, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 8, "steps": 101, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 99, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 8, "steps": 101, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 99, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 8, "steps": 101, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 99, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 2, "steps": 3, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 99, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 8, "steps": 101, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 98, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "has_sub.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 33, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 18, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 33, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 18, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 7, "steps": 17, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 33, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 8, "steps": 18, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 6, "steps": 20, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 42, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 7, "steps": 15, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 6, "steps": 20, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 42, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 7, "steps": 15, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 6, "steps": 20, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 42, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 6, "steps": 12, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 6, "steps": 20, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 42, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "distrib", "max_depth": 6, "steps": 12, "uparams": ["u"], "type": "distrib.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 7, "steps": 17, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 6, "steps": 20, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 6, "steps": 20, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 42, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 7, "steps": 17, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "ring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "ring.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 42, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 6, "steps": 20, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 2, "steps": 6, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 8, "steps": 42, "uparams": ["u"], "type": "has_mul.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "mul_zero_class", "max_depth": 7, "steps": 33, "uparams": ["u"], "type": "mul_zero_class.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_div.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "division_ring", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "division_ring.{u} α"},
{"kind": "ignored_problem", "class": "field", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "field.{u} α"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["v"], "type": "has_append.{v} (list.{v} β)"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["v"], "type": "has_append.{v} (list.{v} β)"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["v"], "type": "has_append.{v} (list.{v} β)"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "instance", "name": "list.has_subset", "class": "has_subset", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_subset.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_subset", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_subset.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_subset", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_subset.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_subset", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_subset.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_subset", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_subset.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_subset", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_subset.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_subset", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_subset.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_subset", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_subset.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_subset", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_subset.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_subset", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_subset.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α), (decidable (p a))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 43, "uparams": [], "type": "Pi (a : α), (decidable (not (p a)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α), (decidable (p a))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α), (decidable (p a))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α), (decidable (p a))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p a)"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α), (decidable (p a))"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u"], "type": "has_append.{u} (list.{u} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "Pi (a : α), (decidable (p a))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p a)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "instance", "name": "list.monad", "class": "monad", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "monad.{u_1 u_1} list.{u_1}"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 8, "steps": 94, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 96, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 8, "steps": 94, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 96, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "problem", "class": "monad", "max_depth": 0, "steps": 1, "uparams": ["u_1"], "type": "monad.{u_1 u_1} list.{u_1}"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "problem", "class": "applicative", "max_depth": 1, "steps": 11, "uparams": ["u_1"], "type": "applicative.{u_1 u_1} list.{u_1}"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 34, "uparams": [], "type": "Pi (a : α), (decidable (eq.{1} bool (lt h a) bool.tt))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 69, "uparams": [], "type": "Pi (a : α), (decidable (not (eq.{1} bool (lt h a) bool.tt)))"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u_1"], "type": "has_append.{u_1} (list.{u_1} α)"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 34, "uparams": [], "type": "Pi (a : α), (decidable (eq.{1} bool (lt h a) bool.tt))"},
{"kind": "ignored_problem", "class": "has_append", "max_depth": 0, "steps": 5, "uparams": ["u_1"], "type": "has_append.{u_1} (list.{u_1} α)"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 10, "steps": 433, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 8, "steps": 94, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u_1"], "type": "subsingleton.{(max (u_1+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u_1"], "type": "subsingleton.{(max (u_1+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 96, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 1, "steps": 3, "uparams": ["u_1"], "type": "subsingleton.{(max (u_1+1) 1)} (Pi (a : α), (decidable (p a)))"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "add_comm_semigroup", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_comm_semigroup.{u} α"},
{"kind": "ignored_problem", "class": "add_monoid", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 8, "steps": 96, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 1, "steps": 2, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 8, "steps": 43, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 9, "steps": 33, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 43, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 8, "steps": 43, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 29, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 43, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 8, "steps": 43, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 29, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 43, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 8, "steps": 63, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 9, "steps": 33, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 8, "steps": 43, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 9, "steps": 29, "uparams": ["u"], "type": "has_le.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 8, "steps": 43, "uparams": ["u"], "type": "has_add.{u} α"},
{"kind": "ignored_problem", "class": "has_one", "max_depth": 8, "steps": 63, "uparams": ["u"], "type": "has_one.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 8, "steps": 43, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 9, "steps": 33, "uparams": ["u"], "type": "has_lt.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 24, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "ordered_cancel_comm_monoid", "max_depth": 6, "steps": 11, "uparams": ["u"], "type": "ordered_cancel_comm_monoid.{u} α"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 5, "steps": 13, "uparams": ["u"], "type": "has_zero.{u} α"},
{"kind": "ignored_problem", "class": "preorder", "max_depth": 8, "steps": 24, "uparams": ["u"], "type": "preorder.{u} α"},
{"kind": "ignored_problem", "class": "has_neg", "max_depth": 5, "steps": 9, "uparams": ["u"], "type": "has_neg.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "linear_ordered_semiring", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "linear_ordered_semiring.{u} α"},
{"kind": "ignored_problem", "class": "add_group", "max_depth": 4, "steps": 8, "uparams": ["u"], "type": "add_group.{u} α"},
{"kind": "instance", "name": "list.is_lawful_monad", "class": "is_lawful_monad", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "@is_lawful_monad.{u_1 u_1} list.{u_1} list.monad.{u_1}"},
{"kind": "instance", "name": "list.alternative", "class": "alternative", "from_extends": 0, "uparams": ["u_1"], "params": [], "coercion_like": 0, "type": "alternative.{u_1 u_1} list.{u_1}"},
{"kind": "dep", "name": "bin_tree", "uparams": ["u"], "type": "Type u → Type u"},
{"kind": "instance", "name": "list.bin_tree_to_list", "class": "has_coe", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_coe.{u+1 u+1} (bin_tree.{u} α) (list.{u} α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p x)"},
{"kind": "instance", "name": "list.decidable_bex", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "p", "type": "α → Prop"},{"name": "_inst_1", "class": "decidable", "type": "Π (a : α), decidable (p a)"},{"name": "l", "type": "list.{u} α"}], "coercion_like": 0, "type": "decidable (@Exists.{u+1} α (λ (x : α), @Exists.{0} (@has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l) (λ (H : @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l), p x)))"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (list.{u} α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 2, "steps": 46, "uparams": ["u"], "type": "decidable (Exists.{u+1} α (fun (x : α), (Exists.{0} (has_mem.mem.{u u} α (list.{u} α) (list.has_mem.{u} α) x l) (fun (H : has_mem.mem.{u u} α (list.{u} α) (list.has_mem.{u} α) x l), (not (p x))))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (p x)"},
{"kind": "instance", "name": "list.decidable_ball", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "α", "type": "Type u"},{"name": "p", "type": "α → Prop"},{"name": "_inst_1", "class": "decidable", "type": "Π (a : α), decidable (p a)"},{"name": "l", "type": "list.{u} α"}], "coercion_like": 0, "type": "decidable (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l → p x)"},
{"kind": "problem", "class": "decidable", "max_depth": 1, "steps": 51, "uparams": [], "type": "Pi (a : list.{0} char) (b : list.{0} char), (decidable (eq.{1} (list.{0} char) a b))"},
{"kind": "instance", "name": "string.has_decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "string"},{"name": "b", "type": "string"}], "coercion_like": 0, "type": "decidable (@eq.{1} string a b)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 37, "uparams": [], "type": "decidable (eq.{1} bool (bor (name.is_internal (expr.local_pp_name bool.tt h)) (expr.is_aux_decl h)) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 14, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 37, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_napp_of t (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)) (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 37, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_constant bool.tt c) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": [], "type": "decidable (eq.{1} string a (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 14, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 37, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_napp_of e (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)) (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))) bool.tt)"},
{"kind": "dep", "name": "nat.add_assoc", "uparams": [], "type": "∀ (n m k : nat), @eq.{1} nat (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n m) k) (@has_add.add.{0} nat nat.has_add n (@has_add.add.{0} nat nat.has_add m k))"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{0} (Pi (n : nat) (m : nat) (k : nat), (eq.{1} nat (has_add.add.{0} nat nat.has_add (has_add.add.{0} nat nat.has_add n m) k) (has_add.add.{0} nat nat.has_add n (has_add.add.{0} nat nat.has_add m k)))) nat.add_assoc"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 8, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{0} (Pi (n : nat) (m : nat) (k : nat), (eq.{1} nat (has_add.add.{0} nat nat.has_add (has_add.add.{0} nat nat.has_add n m) k) (has_add.add.{0} nat nat.has_add n (has_add.add.{0} nat nat.has_add m k)))) nat.add_assoc) (expr bool.tt)"},
{"kind": "dep", "name": "nat.add_comm", "uparams": [], "type": "∀ (n m : nat), @eq.{1} nat (@has_add.add.{0} nat nat.has_add n m) (@has_add.add.{0} nat nat.has_add m n)"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{0} (Pi (n : nat) (m : nat), (eq.{1} nat (has_add.add.{0} nat nat.has_add n m) (has_add.add.{0} nat nat.has_add m n))) nat.add_comm"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 8, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{0} (Pi (n : nat) (m : nat), (eq.{1} nat (has_add.add.{0} nat nat.has_add n m) (has_add.add.{0} nat nat.has_add m n))) nat.add_comm) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 9, "uparams": [], "type": "decidable (eq.{1} (expr bool.tt) a b)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 37, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_napp_of a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 37, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_napp_of b (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))) bool.tt)"},
{"kind": "problem", "class": "reflected", "max_depth": 0, "steps": 0, "uparams": [], "type": "reflected.{2} Type nat"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 8, "uparams": [], "type": "has_coe_t.{1 1} (reflected.{2} Type nat) (expr bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 9, "uparams": [], "type": "decidable (eq.{1} (expr bool.tt) ty (lift_t.{1 1} (reflected.{2} Type nat) (expr bool.tt) (coe_to_lift.{1 1} (reflected.{2} Type nat) (expr bool.tt) (coe_base.{1 1} (reflected.{2} Type nat) (expr bool.tt) (expr.has_coe.{2} Type nat))) `(nat)))"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 9, "uparams": [], "type": "Pi (a : expr bool.tt) (b : expr bool.tt), (decidable (eq.{1} (expr bool.tt) a b))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 40, "uparams": [], "type": "decidable (eq.{1} (list.{0} (expr bool.tt)) (list.bag_inter.{0} (expr bool.tt) expr.has_decidable_eq (_private.4211256083.collect_add_args lhs) (_private.4211256083.collect_add_args rhs)) (list.nil.{0} (expr bool.tt)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 14, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 37, "uparams": [], "type": "decidable (eq.{1} bool (expr.is_numeral lhs) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 14, "uparams": [], "type": "decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))"},
{"kind": "problem", "class": "has_well_founded", "max_depth": 2, "steps": 279, "uparams": [], "type": "has_well_founded.{1} (psigma.{1 1} nat (fun (a : nat), nat))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 34, "uparams": [], "type": "decidable (eq.{1} nat x (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 37, "uparams": [], "type": "decidable (eq.{1} bool (string.iterator.has_next stop) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 37, "uparams": [], "type": "decidable (eq.{1} bool (p (string.iterator.curr stop)) bool.tt)"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 34, "uparams": [], "type": "Pi (a : nat) (b : nat), (decidable (eq.{1} nat a b))"},
{"kind": "dep", "name": "int", "uparams": [], "type": "Type"},
{"kind": "instance", "name": "int.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "int"},{"name": "b", "type": "int"}], "coercion_like": 0, "type": "decidable (@eq.{1} int a b)"},
{"kind": "instance", "name": "int.has_coe", "class": "has_coe", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_coe.{1 1} nat int"},
{"kind": "instance", "name": "int.has_repr", "class": "has_repr", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_repr.{0} int"},
{"kind": "instance", "name": "int.has_to_string", "class": "has_to_string", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_to_string.{0} int"},
{"kind": "problem", "class": "has_lift_t", "max_depth": 2, "steps": 4, "uparams": [], "type": "has_lift_t.{1 1} nat int"},
{"kind": "instance", "name": "int.has_zero", "class": "has_zero", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_zero.{0} int"},
{"kind": "instance", "name": "int.has_one", "class": "has_one", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_one.{0} int"},
{"kind": "problem", "class": "has_zero", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_zero.{0} int"},
{"kind": "problem", "class": "has_one", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_one.{0} int"},
{"kind": "problem", "class": "has_coe_t", "max_depth": 1, "steps": 3, "uparams": [], "type": "has_coe_t.{1 1} nat int"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 34, "uparams": [], "type": "decidable (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "instance", "name": "int.has_neg", "class": "has_neg", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_neg.{0} int"},
{"kind": "instance", "name": "int.has_add", "class": "has_add", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_add.{0} int"},
{"kind": "instance", "name": "int.has_mul", "class": "has_mul", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_mul.{0} int"},
{"kind": "problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_add.{0} int"},
{"kind": "problem", "class": "has_mul", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_mul.{0} int"},
{"kind": "problem", "class": "has_neg", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_neg.{0} int"},
{"kind": "problem", "class": "has_well_founded", "max_depth": 1, "steps": 139, "uparams": [], "type": "has_well_founded.{1} nat"},
{"kind": "dep", "name": "cond", "uparams": ["u"], "type": "Π (a : Type u), bool → a → a → a"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 32, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt (cond.{0} nat bool.ff (has_one.one.{0} nat nat.has_one) (has_zero.zero.{0} nat nat.has_zero)) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))"},
{"kind": "problem", "class": "decidable", "max_depth": 0, "steps": 32, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt (cond.{0} nat bool.tt (has_one.one.{0} nat nat.has_one) (has_zero.zero.{0} nat nat.has_zero)) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))"},
{"kind": "instance", "name": "int.has_div", "class": "has_div", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_div.{0} int"},
{"kind": "instance", "name": "int.has_mod", "class": "has_mod", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_mod.{0} int"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 34, "uparams": [], "type": "decidable (eq.{1} nat (nat.bit b n) (has_zero.zero.{0} nat nat.has_zero))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable (eq.{1} nat (nat.bit b n) (has_zero.zero.{0} nat nat.has_zero)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "instance", "name": "int.comm_ring", "class": "comm_ring", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "comm_ring.{0} int"},
{"kind": "problem", "class": "has_sub", "max_depth": 8, "steps": 19, "uparams": [], "type": "has_sub.{0} int"},
{"kind": "instance", "name": "int.has_sub", "class": "has_sub", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_sub.{0} int"},
{"kind": "problem", "class": "add_comm_monoid", "max_depth": 7, "steps": 39, "uparams": [], "type": "add_comm_monoid.{0} int"},
{"kind": "instance", "name": "int.add_comm_monoid", "class": "add_comm_monoid", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "add_comm_monoid.{0} int"},
{"kind": "problem", "class": "add_monoid", "max_depth": 8, "steps": 19, "uparams": [], "type": "add_monoid.{0} int"},
{"kind": "instance", "name": "int.add_monoid", "class": "add_monoid", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "add_monoid.{0} int"},
{"kind": "problem", "class": "monoid", "max_depth": 6, "steps": 17, "uparams": [], "type": "monoid.{0} int"},
{"kind": "instance", "name": "int.monoid", "class": "monoid", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "monoid.{0} int"},
{"kind": "problem", "class": "comm_monoid", "max_depth": 3, "steps": 8, "uparams": [], "type": "comm_monoid.{0} int"},
{"kind": "instance", "name": "int.comm_monoid", "class": "comm_monoid", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "comm_monoid.{0} int"},
{"kind": "problem", "class": "comm_semigroup", "max_depth": 1, "steps": 3, "uparams": [], "type": "comm_semigroup.{0} int"},
{"kind": "instance", "name": "int.comm_semigroup", "class": "comm_semigroup", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "comm_semigroup.{0} int"},
{"kind": "problem", "class": "semigroup", "max_depth": 1, "steps": 3, "uparams": [], "type": "semigroup.{0} int"},
{"kind": "instance", "name": "int.semigroup", "class": "semigroup", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "semigroup.{0} int"},
{"kind": "problem", "class": "add_comm_semigroup", "max_depth": 1, "steps": 3, "uparams": [], "type": "add_comm_semigroup.{0} int"},
{"kind": "instance", "name": "int.add_comm_semigroup", "class": "add_comm_semigroup", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "add_comm_semigroup.{0} int"},
{"kind": "problem", "class": "add_semigroup", "max_depth": 1, "steps": 3, "uparams": [], "type": "add_semigroup.{0} int"},
{"kind": "instance", "name": "int.add_semigroup", "class": "add_semigroup", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "add_semigroup.{0} int"},
{"kind": "problem", "class": "comm_semiring", "max_depth": 1, "steps": 3, "uparams": [], "type": "comm_semiring.{0} int"},
{"kind": "instance", "name": "int.comm_semiring", "class": "comm_semiring", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "comm_semiring.{0} int"},
{"kind": "problem", "class": "semiring", "max_depth": 6, "steps": 37, "uparams": [], "type": "semiring.{0} int"},
{"kind": "instance", "name": "int.semiring", "class": "semiring", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "semiring.{0} int"},
{"kind": "problem", "class": "ring", "max_depth": 5, "steps": 15, "uparams": [], "type": "ring.{0} int"},
{"kind": "instance", "name": "int.ring", "class": "ring", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "ring.{0} int"},
{"kind": "problem", "class": "distrib", "max_depth": 1, "steps": 3, "uparams": [], "type": "distrib.{0} int"},
{"kind": "instance", "name": "int.distrib", "class": "distrib", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "distrib.{0} int"},
{"kind": "instance", "name": "int.zero_ne_one_class", "class": "zero_ne_one_class", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "zero_ne_one_class.{0} int"},
{"kind": "problem", "class": "add_group", "max_depth": 2, "steps": 3, "uparams": [], "type": "add_group.{0} int"},
{"kind": "problem", "class": "add_comm_group", "max_depth": 1, "steps": 2, "uparams": [], "type": "add_comm_group.{0} int"},
{"kind": "problem", "class": "has_mod", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_mod.{0} int"},
{"kind": "instance", "name": "int.has_le", "class": "has_le", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_le.{0} int"},
{"kind": "problem", "class": "has_le", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_le.{0} int"},
{"kind": "instance", "name": "int.has_lt", "class": "has_lt", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_lt.{0} int"},
{"kind": "instance", "name": "int.decidable_le", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "int"},{"name": "b", "type": "int"}], "coercion_like": 0, "type": "decidable (@has_le.le.{0} int int.has_le a b)"},
{"kind": "problem", "class": "has_lt", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_lt.{0} int"},
{"kind": "instance", "name": "int.decidable_lt", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "int"},{"name": "b", "type": "int"}], "coercion_like": 0, "type": "decidable (@has_lt.lt.{0} int int.has_lt a b)"},
{"kind": "problem", "class": "add_left_cancel_semigroup", "max_depth": 7, "steps": 38, "uparams": [], "type": "add_left_cancel_semigroup.{0} int"},
{"kind": "instance", "name": "int.decidable_linear_ordered_comm_ring", "class": "decidable_linear_ordered_comm_ring", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "decidable_linear_ordered_comm_ring.{0} int"},
{"kind": "problem", "class": "decidable_linear_ordered_comm_group", "max_depth": 1, "steps": 2, "uparams": [], "type": "decidable_linear_ordered_comm_group.{0} int"},
{"kind": "instance", "name": "int.decidable_linear_ordered_comm_group", "class": "decidable_linear_ordered_comm_group", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "decidable_linear_ordered_comm_group.{0} int"},
{"kind": "ignored_problem", "class": "has_sizeof", "max_depth": 0, "steps": 138, "uparams": ["u"], "type": "has_sizeof.{(max 1 (u+1))} (Pi (i : fin n), (α i))"},
{"kind": "problem", "class": "linear_order", "max_depth": 3, "steps": 7, "uparams": [], "type": "linear_order.{0} int"},
{"kind": "problem", "class": "preorder", "max_depth": 6, "steps": 9, "uparams": [], "type": "preorder.{0} int"},
{"kind": "problem", "class": "ordered_comm_group", "max_depth": 4, "steps": 7, "uparams": [], "type": "ordered_comm_group.{0} int"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 19, "uparams": [], "type": "decidable (eq.{1} (fin n) i j)"},
{"kind": "problem", "class": "ordered_cancel_comm_monoid", "max_depth": 5, "steps": 9, "uparams": [], "type": "ordered_cancel_comm_monoid.{0} int"},
{"kind": "problem", "class": "integral_domain", "max_depth": 2, "steps": 5, "uparams": [], "type": "integral_domain.{0} int"},
{"kind": "dep", "name": "nat.succ", "uparams": [], "type": "nat → nat"},
{"kind": "instance", "name": "fin.has_zero", "class": "has_zero", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"}], "coercion_like": 0, "type": "has_zero.{0} (fin (nat.succ n))"},
{"kind": "instance", "name": "fin.has_one", "class": "has_one", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"}], "coercion_like": 0, "type": "has_one.{0} (fin (nat.succ n))"},
{"kind": "instance", "name": "fin.has_add", "class": "has_add", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"}], "coercion_like": 0, "type": "has_add.{0} (fin n)"},
{"kind": "instance", "name": "fin.has_sub", "class": "has_sub", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"}], "coercion_like": 0, "type": "has_sub.{0} (fin n)"},
{"kind": "instance", "name": "fin.has_mul", "class": "has_mul", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"}], "coercion_like": 0, "type": "has_mul.{0} (fin n)"},
{"kind": "instance", "name": "fin.has_mod", "class": "has_mod", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"}], "coercion_like": 0, "type": "has_mod.{0} (fin n)"},
{"kind": "instance", "name": "fin.has_div", "class": "has_div", "from_extends": 0, "uparams": [], "params": [{"name": "n", "type": "nat"}], "coercion_like": 0, "type": "has_div.{0} (fin n)"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_zero.{0} (fin (nat.succ n))"},
{"kind": "ignored_problem", "class": "has_add", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_add.{0} (fin n)"},
{"kind": "problem", "class": "linear_ordered_semiring", "max_depth": 3, "steps": 6, "uparams": [], "type": "linear_ordered_semiring.{0} int"},
{"kind": "ignored_problem", "class": "has_mul", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_mul.{0} (fin n)"},
{"kind": "ignored_problem", "class": "has_sub", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_sub.{0} (fin n)"},
{"kind": "ignored_problem", "class": "has_mod", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_mod.{0} (fin n)"},
{"kind": "ignored_problem", "class": "has_div", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_div.{0} (fin n)"},
{"kind": "ignored_problem", "class": "has_lt", "max_depth": 0, "steps": 3, "uparams": [], "type": "has_lt.{0} (fin n)"},
{"kind": "ignored_problem", "class": "has_le", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_le.{0} (fin n)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable (eq.{1} (fin n) i j))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable (eq.{1} (fin n) i i))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_zero.{0} (fin (nat.succ n))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "decidable (eq.{u+1} (α (fin.mk n i h)) (d_array.read.{u} n α a (fin.mk n i h)) (d_array.read.{u} n α b (fin.mk n i h)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable (eq.{1} (fin n) i j))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable (eq.{1} (fin n) i j))"},
{"kind": "ignored_problem", "class": "has_zero", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_zero.{0} (fin (nat.succ n))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 38, "uparams": ["u"], "type": "decidable (eq.{1} bool (d_array.beq.{u} n α _inst_1 a b) bool.tt)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 35, "uparams": [], "type": "decidable (eq.{1} nat j i)"},
{"kind": "dep", "name": "d_array", "uparams": ["u"], "type": "Π (n : nat), (fin n → Type u) → Type u"},
{"kind": "instance", "name": "d_array.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "n", "type": "nat"},{"name": "α", "type": "fin n → Type u"},{"name": "_inst_1", "class": "decidable", "type": "Π (i : fin n) (a b : α i), decidable (@eq.{u+1} (α i) a b)"},{"name": "a", "type": "d_array.{u} n α"},{"name": "b", "type": "d_array.{u} n α"}], "coercion_like": 0, "type": "decidable (@eq.{u+1} (d_array.{u} n α) a b)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 35, "uparams": [], "type": "decidable (eq.{1} nat j n)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))"},
{"kind": "dep", "name": "array", "uparams": ["u"], "type": "nat → Type u → Type u"},
{"kind": "instance", "name": "array.has_mem", "class": "has_mem", "from_extends": 0, "uparams": ["u"], "params": [{"name": "n", "type": "nat"},{"name": "α", "type": "Type u"}], "coercion_like": 0, "type": "has_mem.{u u} α (array.{u} n α)"},
{"kind": "ignored_problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "has_mem.{u u} α (array.{u} n α)"},
{"kind": "ignored_problem", "class": "has_repr", "max_depth": 1, "steps": 18, "uparams": ["u"], "type": "has_repr.{u} (list.{u} α)"},
{"kind": "instance", "name": "array.has_repr", "class": "has_repr", "from_extends": 0, "uparams": ["u"], "params": [{"name": "n", "type": "nat"},{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_repr", "type": "has_repr.{u} α"}], "coercion_like": 0, "type": "has_repr.{u} (array.{u} n α)"},
{"kind": "ignored_problem", "class": "has_to_format", "max_depth": 1, "steps": 23, "uparams": ["u"], "type": "has_to_format.{u} (list.{u} α)"},
{"kind": "instance", "name": "array.has_to_format", "class": "has_to_format", "from_extends": 0, "uparams": ["u"], "params": [{"name": "n", "type": "nat"},{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_to_format", "type": "has_to_format.{u} α"}], "coercion_like": 0, "type": "has_to_format.{u} (array.{u} n α)"},
{"kind": "ignored_problem", "class": "has_to_tactic_format", "max_depth": 1, "steps": 11, "uparams": ["u"], "type": "has_to_tactic_format.{u} (list.{u} α)"},
{"kind": "instance", "name": "array.has_to_tactic_format", "class": "has_to_tactic_format", "from_extends": 0, "uparams": ["u"], "params": [{"name": "n", "type": "nat"},{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "has_to_tactic_format", "type": "has_to_tactic_format.{u} α"}], "coercion_like": 0, "type": "has_to_tactic_format.{u} (array.{u} n α)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 33, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt i n)"},
{"kind": "ignored_problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": ["v"], "type": "inhabited.{v+1} β"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 0, "steps": 33, "uparams": [], "type": "decidable (has_lt.lt.{0} nat nat.has_lt i n)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 3, "steps": 5, "uparams": ["u"], "type": "subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "inhabited", "max_depth": 0, "steps": 1, "uparams": ["u"], "type": "inhabited.{u+1} α"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 3, "uparams": ["u"], "type": "Pi (a : d_array.{u} n (fun (_x : fin n), α)) (b : d_array.{u} n (fun (_x : fin n), α)), (decidable (eq.{u+1} (d_array.{u} n (fun (_x : fin n), α)) a b))"},
{"kind": "instance", "name": "array.decidable_eq", "class": "decidable", "from_extends": 0, "uparams": ["u"], "params": [{"name": "n", "type": "nat"},{"name": "α", "type": "Type u"},{"name": "_inst_1", "class": "decidable", "type": "Π (a b : α), decidable (@eq.{u+1} α a b)"},{"name": "a", "type": "array.{u} n α"},{"name": "b", "type": "array.{u} n α"}], "coercion_like": 0, "type": "decidable (@eq.{u+1} (array.{u} n α) a b)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable (has_lt.lt.{0} nat nat.has_lt i n))"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable c)"},
{"kind": "ignored_problem", "class": "subsingleton", "max_depth": 0, "steps": 2, "uparams": [], "type": "subsingleton.{1} (decidable (has_lt.lt.{0} nat nat.has_lt i n))"},
{"kind": "problem", "class": "has_mem", "max_depth": 0, "steps": 1, "uparams": [], "type": "has_mem.{0 0} char (list.{0} char)"},
{"kind": "instance", "name": "unsigned.has_zero", "class": "has_zero", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_zero.{0} unsigned"},
{"kind": "instance", "name": "unsigned.has_one", "class": "has_one", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_one.{0} unsigned"},
{"kind": "instance", "name": "unsigned.has_add", "class": "has_add", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_add.{0} unsigned"},
{"kind": "instance", "name": "unsigned.has_sub", "class": "has_sub", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_sub.{0} unsigned"},
{"kind": "instance", "name": "unsigned.has_mul", "class": "has_mul", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_mul.{0} unsigned"},
{"kind": "instance", "name": "unsigned.has_mod", "class": "has_mod", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_mod.{0} unsigned"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 120, "uparams": [], "type": "decidable (and (has_le.le.{0} nat nat.has_le (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (char.to_nat c)) (has_le.le.{0} nat nat.has_le (char.to_nat c) (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))"},
{"kind": "instance", "name": "unsigned.has_div", "class": "has_div", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_div.{0} unsigned"},
{"kind": "instance", "name": "unsigned.has_lt", "class": "has_lt", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_lt.{0} unsigned"},
{"kind": "instance", "name": "unsigned.has_le", "class": "has_le", "from_extends": 0, "uparams": [], "params": [], "coercion_like": 0, "type": "has_le.{0} unsigned"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 62, "uparams": [], "type": "decidable (has_mem.mem.{0 0} char (list.{0} char) (list.has_mem.{0} char) c (list.cons.{0} char (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))) (list.cons.{0} char (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))) (list.nil.{0} char)))))"},
{"kind": "dep", "name": "char.is_whitespace", "uparams": [], "type": "char → Prop"},
{"kind": "instance", "name": "char.decidable_is_whitespace", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "char"}], "coercion_like": 0, "type": "decidable (char.is_whitespace a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 123, "uparams": [], "type": "decidable (and (has_le.le.{0} nat nat.has_le (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (char.val c)) (has_le.le.{0} nat nat.has_le (char.val c) (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))"},
{"kind": "dep", "name": "char.is_upper", "uparams": [], "type": "char → Prop"},
{"kind": "instance", "name": "char.decidable_is_upper", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "char"}], "coercion_like": 0, "type": "decidable (char.is_upper a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 126, "uparams": [], "type": "decidable (and (has_le.le.{0} nat nat.has_le (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))) (char.val c)) (has_le.le.{0} nat nat.has_le (char.val c) (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))"},
{"kind": "dep", "name": "char.is_lower", "uparams": [], "type": "char → Prop"},
{"kind": "instance", "name": "char.decidable_is_lower", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "char"}], "coercion_like": 0, "type": "decidable (char.is_lower a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 54, "uparams": [], "type": "decidable (or (char.is_upper c) (char.is_lower c))"},
{"kind": "dep", "name": "char.is_alpha", "uparams": [], "type": "char → Prop"},
{"kind": "instance", "name": "char.decidable_is_alpha", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "char"}], "coercion_like": 0, "type": "decidable (char.is_alpha a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 132, "uparams": [], "type": "decidable (and (has_le.le.{0} nat nat.has_le (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))) (char.val c)) (has_le.le.{0} nat nat.has_le (char.val c) (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))"},
{"kind": "dep", "name": "char.is_digit", "uparams": [], "type": "char → Prop"},
{"kind": "instance", "name": "char.decidable_is_digit", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "char"}], "coercion_like": 0, "type": "decidable (char.is_digit a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 56, "uparams": [], "type": "decidable (or (char.is_alpha c) (char.is_digit c))"},
{"kind": "dep", "name": "char.is_alphanum", "uparams": [], "type": "char → Prop"},
{"kind": "instance", "name": "char.decidable_is_alphanum", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "char"}], "coercion_like": 0, "type": "decidable (char.is_alphanum a)"},
{"kind": "ignored_problem", "class": "decidable", "max_depth": 1, "steps": 74, "uparams": [], "type": "decidable (has_mem.mem.{0 0} char (list.{0} char) (list.has_mem.{0} char) c (list.cons.{0} char (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.nil.{0} char))))))))))"},
{"kind": "dep", "name": "char.is_punctuation", "uparams": [], "type": "char → Prop"},
{"kind": "instance", "name": "char.decidable_is_punctuation", "class": "decidable", "from_extends": 0, "uparams": [], "params": [{"name": "a", "type": "char"}], "coercion_like": 0, "type": "decidable (char.is_punctuation a)"}], "problem_counts": {
"decidable (has_mem.mem.{0 0} char (list.{0} char) (list.has_mem.{0} char) c (list.cons.{0} char (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.nil.{0} char))))))))))": 1,
"decidable (or (char.is_alpha c) (char.is_digit c))": 1,
"decidable (or (char.is_upper c) (char.is_lower c))": 1,
"decidable (and (has_le.le.{0} nat nat.has_le (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))) (char.val c)) (has_le.le.{0} nat nat.has_le (char.val c) (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))": 1,
"has_mem.{0 0} char (list.{0} char)": 2,
"subsingleton.{1} (decidable (has_lt.lt.{0} nat nat.has_lt i n))": 1,
"subsingleton.{1} (decidable (has_lt.lt.{0} nat nat.has_lt i n))": 1,
"subsingleton.{1} (decidable c)": 1,
"Pi (a : d_array.{u} n (fun (_x : fin n), α)) (b : d_array.{u} n (fun (_x : fin n), α)), (decidable (eq.{u+1} (d_array.{u} n (fun (_x : fin n), α)) a b))": 1,
"inhabited.{u+1} α": 1,
"subsingleton.{1} (decidable c)": 1,
"subsingleton.{1} (decidable c)": 1,
"inhabited.{v+1} β": 1,
"decidable (has_lt.lt.{0} nat nat.has_lt i n)": 1,
"has_to_tactic_format.{u} (list.{u} α)": 1,
"has_repr.{u} (list.{u} α)": 1,
"subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))": 2,
"decidable (eq.{1} nat j i)": 1,
"Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b))": 2,
"subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))": 1,
"Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b))": 3,
"subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))": 1,
"has_zero.{0} (fin (nat.succ n))": 2,
"subsingleton.{1} (decidable (eq.{1} (fin n) i j))": 1,
"subsingleton.{1} (decidable c)": 1,
"decidable (eq.{u+1} (α (fin.mk n i h)) (d_array.read.{u} n α a (fin.mk n i h)) (d_array.read.{u} n α b (fin.mk n i h)))": 1,
"has_zero.{0} (fin (nat.succ n))": 1,
"subsingleton.{1} (decidable (eq.{1} (fin n) i i))": 1,
"has_div.{0} (fin n)": 1,
"has_mod.{0} (fin n)": 1,
"has_sub.{0} (fin n)": 1,
"linear_ordered_semiring.{0} int": 8,
"has_zero.{0} (fin (nat.succ n))": 1,
"ordered_cancel_comm_monoid.{0} int": 12,
"preorder.{0} int": 15,
"has_sizeof.{(max 1 (u+1))} (Pi (i : fin n), (α i))": 2,
"decidable_linear_ordered_comm_group.{0} int": 7,
"add_left_cancel_semigroup.{0} int": 4,
"has_mod.{0} int": 1,
"add_comm_group.{0} int": 1,
"add_group.{0} int": 101,
"comm_semiring.{0} int": 1,
"monoid.{0} int": 5,
"add_comm_monoid.{0} int": 1,
"has_sub.{0} int": 20,
"subsingleton.{1} (decidable (eq.{1} nat (nat.bit b n) (has_zero.zero.{0} nat nat.has_zero)))": 2,
"decidable (has_lt.lt.{0} nat nat.has_lt (cond.{0} nat bool.tt (has_one.one.{0} nat nat.has_one) (has_zero.zero.{0} nat nat.has_zero)) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))": 1,
"decidable (has_lt.lt.{0} nat nat.has_lt (cond.{0} nat bool.ff (has_one.one.{0} nat nat.has_one) (has_zero.zero.{0} nat nat.has_zero)) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))": 1,
"has_neg.{0} int": 39,
"has_zero.{0} int": 126,
"has_lift_t.{1 1} nat int": 61,
"Pi (a : nat) (b : nat), (decidable (eq.{1} nat a b))": 2,
"decidable (eq.{1} bool (expr.is_numeral lhs) bool.tt)": 1,
"decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"Pi (a : expr bool.tt) (b : expr bool.tt), (decidable (eq.{1} (expr bool.tt) a b))": 3,
"decidable (eq.{1} bool (expr.is_napp_of b (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))) bool.tt)": 1,
"decidable (eq.{1} (expr bool.tt) a b)": 1,
"reflected.{0} (Pi (n : nat) (m : nat), (eq.{1} nat (has_add.add.{0} nat nat.has_add n m) (has_add.add.{0} nat nat.has_add m n))) nat.add_comm": 1,
"has_coe_t.{1 1} (reflected.{0} (Pi (n : nat) (m : nat) (k : nat), (eq.{1} nat (has_add.add.{0} nat nat.has_add (has_add.add.{0} nat nat.has_add n m) k) (has_add.add.{0} nat nat.has_add n (has_add.add.{0} nat nat.has_add m k)))) nat.add_assoc) (expr bool.tt)": 1,
"reflected.{0} (Pi (n : nat) (m : nat) (k : nat), (eq.{1} nat (has_add.add.{0} nat nat.has_add (has_add.add.{0} nat nat.has_add n m) k) (has_add.add.{0} nat nat.has_add n (has_add.add.{0} nat nat.has_add m k)))) nat.add_assoc": 1,
"decidable (eq.{1} string a (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))": 1,
"decidable (eq.{1} bool (bor (name.is_internal (expr.local_pp_name bool.tt h)) (expr.is_aux_decl h)) bool.tt)": 1,
"Pi (a : list.{0} char) (b : list.{0} char), (decidable (eq.{1} (list.{0} char) a b))": 1,
"decidable (p x)": 1,
"decidable (Exists.{u+1} α (fun (x : α), (Exists.{0} (has_mem.mem.{u u} α (list.{u} α) (list.has_mem.{u} α) x l) (fun (H : has_mem.mem.{u u} α (list.{u} α) (list.has_mem.{u} α) x l), (not (p x))))))": 1,
"has_mem.{u u} α (list.{u} α)": 4,
"linear_ordered_semiring.{u} α": 3,
"linear_ordered_semiring.{u} α": 2,
"preorder.{u} α": 1,
"has_lt.{u} α": 1,
"has_lt.{u} α": 1,
"has_one.{u} α": 1,
"has_add.{u} α": 1,
"has_zero.{u} α": 2,
"has_add.{u} α": 1,
"has_zero.{u} α": 2,
"has_zero.{u} α": 2,
"has_neg.{u} α": 1,
"add_monoid.{u} α": 1,
"has_one.{u} α": 3,
"has_add.{u} α": 1,
"subsingleton.{(max (u_1+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_one.{u} α": 2,
"has_zero.{u} α": 1,
"has_add.{u} α": 2,
"has_add.{u} α": 4,
"has_one.{u} α": 3,
"has_append.{u_1} (list.{u_1} α)": 1,
"has_add.{u} α": 3,
"has_add.{u} α": 4,
"has_append.{u_1} (list.{u_1} α)": 1,
"has_one.{u} α": 4,
"has_add.{u} α": 4,
"has_add.{u} α": 4,
"has_one.{u} α": 4,
"has_add.{u} α": 4,
"has_add.{u} α": 3,
"has_one.{u} α": 2,
"add_comm_semigroup.{u} α": 69,
"applicative.{u_1 u_1} list.{u_1}": 6,
"has_add.{u} α": 3,
"monad.{u_1 u_1} list.{u_1}": 17,
"add_monoid.{u} α": 1,
"has_one.{u} α": 2,
"has_add.{u} α": 1,
"has_add.{u} α": 6,
"add_comm_semigroup.{u} α": 56,
"has_add.{u} α": 6,
"has_one.{u} α": 3,
"add_comm_semigroup.{u} α": 56,
"has_one.{u} α": 2,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_le.{0} (fin n)": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"decidable (p a)": 1,
"Pi (a : α), (decidable (p a))": 2,
"Pi (a : α), (decidable (p a))": 6,
"decidable (p a)": 1,
"decidable (p a)": 1,
"Pi (a : α), (decidable (p a))": 2,
"Pi (a : α), (decidable (p a))": 2,
"Pi (a : α), (decidable (not (p a)))": 2,
"Pi (a : α), (decidable (p a))": 4,
"add_comm_semigroup.{u} α": 13,
"has_subset.{u} (list.{u} α)": 1,
"has_append.{u} (list.{u} α)": 1,
"has_subset.{u} (list.{u} α)": 2,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_subset.{u} (list.{u} α)": 2,
"has_subset.{u} (list.{u} α)": 1,
"has_subset.{u} (list.{u} α)": 1,
"has_mem.{u u} α (list.{u} α)": 2,
"has_mem.{u u} α (list.{u} α)": 2,
"has_mem.{u u} α (list.{u} α)": 2,
"has_mem.{u u} α (list.{u} α)": 1,
"has_mem.{u u} α (list.{u} α)": 1,
"has_mem.{u u} α (list.{u} α)": 2,
"has_append.{v} (list.{v} β)": 1,
"division_ring.{u} α": 2,
"has_add.{u} α": 6,
"has_div.{u} α": 2,
"division_ring.{u} α": 2,
"mul_zero_class.{u} α": 1,
"division_ring.{u} α": 2,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_mul.{u} α": 1,
"ring.{u} α": 1,
"add_group.{u} α": 3,
"has_zero.{u} α": 1,
"has_div.{u} α": 2,
"has_zero.{u} α": 4,
"division_ring.{u} α": 1,
"has_div.{u} α": 2,
"has_coe_t.{1 1} (reflected.{0} (Pi (n : nat) (m : nat), (eq.{1} nat (has_add.add.{0} nat nat.has_add n m) (has_add.add.{0} nat nat.has_add m n))) nat.add_comm) (expr bool.tt)": 1,
"has_zero.{u} α": 1,
"has_div.{u} α": 2,
"has_mul.{u} α": 2,
"has_zero.{u} α": 1,
"has_div.{u} α": 1,
"has_add.{u} α": 2,
"has_zero.{u} α": 1,
"has_append.{u} (list.{u} α)": 1,
"has_div.{u} α": 1,
"has_mul.{u} α": 2,
"has_neg.{u} α": 2,
"has_append.{u} (list.{u} α)": 1,
"add_group.{u} α": 4,
"has_neg.{u} α": 2,
"add_group.{u} α": 2,
"add_group.{u} α": 2,
"has_neg.{u} α": 2,
"add_comm_semigroup.{u} α": 1,
"add_group.{u} α": 1,
"add_group.{u} α": 3,
"has_add.{u} α": 2,
"add_comm_semigroup.{u} α": 2,
"has_add.{u} α": 2,
"add_comm_group.{u} α": 1,
"add_comm_semigroup.{u} α": 2,
"add_group.{u} α": 11,
"add_comm_semigroup.{u} α": 12,
"add_group.{u} α": 2,
"has_neg.{u} α": 3,
"has_add.{u} α": 2,
"has_neg.{u} α": 2,
"monoid.{u} α": 1,
"has_add.{u} α": 3,
"ordered_cancel_comm_monoid.{u} α": 2,
"add_comm_semigroup.{u} α": 8,
"has_zero.{u} α": 1,
"monoid.{u} α": 1,
"add_comm_semigroup.{u} α": 1,
"has_mul.{u} α": 2,
"has_mul.{u} α": 2,
"distrib.{u} α": 1,
"has_add.{u} α": 2,
"mul_zero_class.{u} α": 1,
"mul_zero_class.{u} α": 1,
"subsingleton.{1} (decidable (or (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) n) (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))))))))))))": 1,
"subsingleton.{1} (decidable c)": 1,
"has_mul.{u} α": 2,
"has_mul.{u} α": 1,
"has_one.{u} α": 1,
"has_add.{u} α": 1,
"comm_semiring.{0} nat": 21,
"subsingleton.{1} (decidable p)": 1,
"decidable (eq.{1} nat z (has_zero.zero.{0} nat nat.has_zero))": 1,
"decidable (eq.{1} nat y (has_zero.zero.{0} nat nat.has_zero))": 1,
"decidable (p m)": 1,
"decidable (has_le.le.{0} nat nat.has_le n m)": 1,
"decidable (has_lt.lt.{0} nat nat.has_lt a b)": 1,
"zero_ne_one_class.{0} nat": 2,
"mul_zero_class.{0} nat": 28,
"decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) k) (has_le.le.{0} nat nat.has_le k m))": 5,
"decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) b) (has_le.le.{0} nat nat.has_le b (has_zero.zero.{0} nat nat.has_zero)))": 1,
"decidable (has_lt.lt.{0} nat nat.has_lt (nat.succ x) y)": 1,
"decidable (not (has_lt.lt.{0} nat nat.has_lt (has_add.add.{0} nat nat.has_add k (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))": 1,
"decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) b) (has_le.le.{0} nat nat.has_le b a))": 1,
"decidable (has_lt.lt.{0} nat (preorder.to_has_lt.{0} nat (partial_order.to_preorder.{0} nat (ordered_cancel_comm_monoid.to_partial_order.{0} nat (ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) m n)": 1,
"decidable (eq.{1} nat m n)": 1,
"decidable (has_le.le.{0} nat nat.has_le x y)": 1,
"decidable (has_le.le.{0} nat (preorder.to_has_le.{0} nat (partial_order.to_preorder.{0} nat (linear_order.to_partial_order.{0} nat (linear_order.mk.{0} nat (decidable_linear_order.le.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.lt.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_refl.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_trans.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.lt_iff_le_not_le.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_antisymm.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_total.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)))))) x y)": 2,
"semiring.{0} nat": 3,
"semigroup.{0} nat": 5,
"add_comm_monoid.{0} nat": 1,
"preorder.{0} nat": 154,
"preorder.{u} α": 1,
"ordered_comm_group.{u} α": 1,
"ring.{u} α": 4,
"decidable_linear_ordered_comm_ring.{u} α": 1,
"has_mul.{u} α": 1,
"comm_semigroup.{u} α": 23,
"has_one.{u} α": 2,
"add_group.{u} α": 21,
"linear_ordered_semiring.{u} α": 2,
"discrete_field.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 4,
"decidable_linear_ordered_comm_group.{u} α": 9,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_div.{u} α": 3,
"has_add.{u} α": 1,
"has_le.{u} α": 1,
"add_group.{u} α": 1,
"decidable_linear_ordered_comm_group.{u} α": 4,
"no_zero_divisors.{u} α": 2,
"linear_ordered_ring.{u} α": 4,
"ring.{u} α": 3,
"linear_order.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_le.{u} α": 2,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (linear_ordered_ring.to_ordered_ring.{u} α (linear_ordered_comm_ring.to_linear_ordered_ring.{u} α (decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{u} α _inst_1))))))) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (ordered_comm_group.to_add_comm_group.{u} α (ordered_ring.to_ordered_comm_group.{u} α (linear_ordered_ring.to_ordered_ring.{u} α (linear_ordered_comm_ring.to_linear_ordered_ring.{u} α (decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{u} α _inst_1))))))))) (has_sub.sub.{u} α (add_group_has_sub.{u} α (add_comm_group.to_add_group.{u} α (ordered_comm_group.to_add_comm_group.{u} α (ordered_ring.to_ordered_comm_group.{u} α (linear_ordered_ring.to_ordered_ring.{u} α (linear_ordered_comm_ring.to_linear_ordered_ring.{u} α (decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{u} α _inst_1))))))) a b))": 1,
"has_zero.{u} α": 4,
"has_one.{u} α": 2,
"has_mul.{u} α": 5,
"has_neg.{u} α": 14,
"has_le.{u} α": 3,
"decidable_linear_ordered_comm_group.{u} α": 2,
"has_zero.{u} α": 3,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (linear_ordered_ring.to_ordered_ring.{u} α (linear_ordered_comm_ring.to_linear_ordered_ring.{u} α (decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{u} α _inst_1))))))) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (ordered_comm_group.to_add_comm_group.{u} α (ordered_ring.to_ordered_comm_group.{u} α (linear_ordered_ring.to_ordered_ring.{u} α (linear_ordered_comm_ring.to_linear_ordered_ring.{u} α (decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{u} α _inst_1))))))))) (has_sub.sub.{u} α (add_group_has_sub.{u} α (add_comm_group.to_add_group.{u} α (ordered_comm_group.to_add_comm_group.{u} α (ordered_ring.to_ordered_comm_group.{u} α (linear_ordered_ring.to_ordered_ring.{u} α (linear_ordered_comm_ring.to_linear_ordered_ring.{u} α (decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{u} α _inst_1))))))) a b))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))": 1,
"decidable_linear_order.{u} α": 1,
"decidable_linear_ordered_comm_ring.{u} α": 2,
"has_zero.{u} α": 3,
"ordered_comm_group.{u} α": 8,
"preorder.{u} α": 4,
"has_lt.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 2,
"has_lt.{u} α": 4,
"decidable_linear_ordered_comm_ring.{u} α": 2,
"ordered_comm_group.{u} α": 8,
"preorder.{u} α": 4,
"has_le.{u} α": 6,
"has_zero.{u} α": 9,
"has_mul.{u} α": 2,
"ordered_comm_group.{u} α": 4,
"decidable_linear_ordered_comm_group.{u} α": 1,
"has_mul.{u} α": 2,
"has_mul.{u} α": 35,
"decidable_linear_ordered_comm_group.{u} α": 5,
"has_le.{u} α": 6,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_lt.{u} α": 1,
"add_semigroup.{u} α": 1,
"add_group.{u} α": 4,
"has_le.{u} α": 1,
"has_mem.{u u} α (list.{u} α)": 2,
"add_group.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 4,
"has_add.{u} α": 4,
"has_sub.{u} α": 8,
"decidable_linear_ordered_comm_group.{u} α": 7,
"has_one.{u} α": 1,
"has_add.{u} α": 3,
"has_neg.{u} α": 12,
"has_add.{u} α": 7,
"has_le.{u} α": 3,
"ordered_cancel_comm_monoid.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 19,
"has_le.{u} α": 7,
"decidable_linear_ordered_comm_group.{u} α": 14,
"has_neg.{u} α": 2,
"linear_order.{u} α": 4,
"linear_order.{u} α": 2,
"has_le.{u} α": 5,
"has_add.{u} α": 6,
"has_zero.{u} α": 7,
"preorder.{u} α": 4,
"has_le.{u} α": 11,
"decidable_linear_ordered_comm_group.{u} α": 2,
"has_neg.{u} α": 1,
"has_le.{u} α": 2,
"has_zero.{u} α": 3,
"linear_order.{u} α": 2,
"has_lt.{u} α": 1,
"has_add.{u} α": 5,
"add_group.{u} α": 1,
"has_neg.{u} α": 1,
"ordered_comm_group.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 3,
"decidable_linear_ordered_comm_ring.{u} α": 2,
"has_sub.{u} α": 2,
"partial_order.{u} α": 1,
"has_zero.{u} α": 2,
"ordered_comm_group.{u} α": 1,
"has_le.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 4,
"has_le.{u} α": 1,
"linear_order.{u} α": 2,
"has_zero.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 3,
"decidable_linear_ordered_comm_group.{u} α": 5,
"linear_order.{u} α": 2,
"has_lt.{u} α": 2,
"add_group.{u} α": 1,
"has_zero.{u} α": 2,
"ordered_comm_group.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 3,
"add_group.{u} α": 1,
"has_lt.{u} α": 2,
"has_zero.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 3,
"has_zero.{u} α": 2,
"add_monoid.{0} int": 17,
"has_neg.{u} α": 1,
"has_zero.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 2,
"decidable_linear_order.{u} α": 1,
"preorder.{u} α": 2,
"has_neg.{u} α": 2,
"has_le.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 5,
"has_zero.{u} α": 1,
"add_group.{u} α": 1,
"decidable_linear_order.{u} α": 1,
"decidable_linear_ordered_comm_group.{u} α": 2,
"has_lt.{u} α": 1,
"decidable_linear_order.{u} α": 2,
"has_sub.{u} α": 2,
"add_group.{u} α": 1,
"has_neg.{u} α": 3,
"ordered_comm_group.{u} α": 10,
"has_le.{u} α": 6,
"preorder.{u} α": 1,
"linear_order.{u} α": 1,
"has_neg.{u} α": 11,
"subsingleton.{1} (decidable c)": 1,
"ordered_cancel_comm_monoid.{u} α": 4,
"decidable_linear_ordered_cancel_comm_monoid.{u} α": 1,
"decidable_linear_order.{u} α": 10,
"subsingleton.{1} (decidable c)": 1,
"has_zero.{u} α": 4,
"subsingleton.{1} (decidable c)": 1,
"subsingleton.{1} (decidable c)": 1,
"subsingleton.{1} (decidable c)": 1,
"subsingleton.{1} (decidable c)": 1,
"preorder.{u} α": 1,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (decidable_linear_ordered_cancel_comm_monoid.to_ordered_cancel_comm_monoid.{u} α _inst_1)))) b c)": 1,
"decidable_linear_order.{u} α": 2,
"subsingleton.{1} (decidable c)": 1,
"has_add.{u} α": 3,
"ordered_cancel_comm_monoid.{u} α": 4,
"has_le.{u} α": 6,
"subsingleton.{1} (decidable c)": 1,
"subsingleton.{1} (decidable c)": 1,
"decidable_linear_order.{u} α": 12,
"has_add.{u} α": 9,
"preorder.{u} α": 4,
"has_le.{u} α": 3,
"has_lt.{u} α": 4,
"has_le.{u} α": 3,
"preorder.{u} α": 2,
"subsingleton.{1} (decidable c)": 1,
"has_lt.{u} α": 1,
"preorder.{u} α": 2,
"has_lt.{u} α": 1,
"decidable_linear_order.{u} α": 2,
"decidable_linear_order.{u} α": 3,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_sub.{u} α": 2,
"has_le.{u} α": 1,
"decidable_linear_order.{u} α": 3,
"decidable_linear_order.{u} α": 2,
"decidable_linear_order.{u} α": 7,
"partial_order.{u} α": 1,
"decidable_linear_order.{u} α": 6,
"reflected.{2} Type nat": 1,
"preorder.{u} α": 6,
"has_le.{u} α": 5,
"decidable_linear_order.{u} α": 3,
"has_le.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"subsingleton.{1} (decidable c)": 1,
"has_le.{u} α": 1,
"preorder.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"has_coe_t.{1 1} nat int": 105,
"has_one.{u} α": 2,
"has_neg.{u} α": 1,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a a)": 1,
"subsingleton.{1} (decidable c)": 1,
"has_le.{u} α": 1,
"add_comm_semigroup.{u} α": 3,
"subsingleton.{1} (decidable c)": 1,
"preorder.{u} α": 1,
"decidable_linear_order.{u} α": 7,
"subsingleton.{1} (decidable c)": 1,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)": 1,
"partial_order.{u} α": 1,
"decidable_linear_order.{u} α": 5,
"subsingleton.{1} (decidable c)": 1,
"subsingleton.{1} (decidable c)": 1,
"subsingleton.{1} (decidable c)": 1,
"has_le.{u} α": 5,
"decidable_linear_order.{u} α": 2,
"has_le.{u} α": 4,
"subsingleton.{1} (decidable c)": 1,
"decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"has_le.{u} α": 2,
"subsingleton.{1} (decidable c)": 1,
"decidable_linear_order.{u} α": 2,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)": 1,
"decidable_linear_order.{u} α": 2,
"decidable_linear_order.{u} α": 2,
"decidable_linear_order.{u} α": 2,
"has_le.{u} α": 2,
"decidable_linear_order.{u} α": 2,
"has_neg.{u} α": 1,
"decidable_linear_order.{u} α": 1,
"decidable_linear_order.{u} α": 1,
"has_le.{u} α": 1,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)": 1,
"linear_ordered_field.{u} α": 2,
"preorder.{u} α": 1,
"decidable_linear_order.{u} α": 1,
"ordered_semiring.{u} α": 2,
"discrete_field.{u} α": 2,
"division_ring.{u} α": 2,
"discrete_linear_ordered_field.{u} α": 2,
"division_ring.{u} α": 2,
"has_lt.{u} α": 2,
"preorder.{u} α": 1,
"has_lt.{u} α": 1,
"discrete_field.{u} α": 2,
"has_zero.{u} α": 1,
"has_le.{u} α": 2,
"has_neg.{u} α": 3,
"linear_ordered_field.{u} α": 2,
"has_lt.{u} α": 5,
"has_lt.{u} α": 3,
"has_zero.{u} α": 6,
"has_one.{u} α": 8,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{0} (eq.{u+1} α (inv zero) zero)": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))": 2,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"decidable (eq.{1} (expr bool.tt) ty (lift_t.{1 1} (reflected.{2} Type nat) (expr bool.tt) (coe_to_lift.{1 1} (reflected.{2} Type nat) (expr bool.tt) (coe_base.{1 1} (reflected.{2} Type nat) (expr bool.tt) (expr.has_coe.{2} Type nat))) `(nat)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{u+1} (α -> α)": 4,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"linear_ordered_field.{u} α": 1,
"ordered_semiring.{u} α": 1,
"ordered_comm_group.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 2,
"linear_ordered_field.{u} α": 2,
"linear_ordered_field.{u} α": 2,
"has_div.{u} α": 2,
"has_lt.{u} α": 4,
"semiring.{u} α": 1,
"division_ring.{u} α": 2,
"has_le.{u} α": 3,
"has_one.{u} α": 6,
"has_div.{u} α": 3,
"has_one.{u} α": 6,
"has_zero.{u} α": 1,
"has_div.{u} α": 3,
"has_le.{u} α": 3,
"has_lt.{u} α": 1,
"has_one.{u} α": 6,
"has_lt.{u} α": 4,
"linear_order.{u} α": 2,
"has_le.{u} α": 2,
"has_lt.{u} α": 2,
"division_ring.{u} α": 2,
"preorder.{u} α": 2,
"division_ring.{u} α": 2,
"add_comm_semigroup.{u} α": 20,
"has_le.{u} α": 2,
"has_zero.{u} α": 5,
"has_div.{u} α": 2,
"has_one.{u} α": 2,
"ordered_comm_group.{u} α": 2,
"linear_ordered_field.{u} α": 2,
"preorder.{u} α": 2,
"linear_ordered_field.{u} α": 2,
"has_one.{u} α": 2,
"decidable (and (has_le.le.{0} nat nat.has_le (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (char.val c)) (has_le.le.{0} nat nat.has_le (char.val c) (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))": 1,
"monoid.{u} α": 1,
"linear_order.{u} α": 2,
"has_div.{u} α": 2,
"division_ring.{u} α": 1,
"preorder.{u} α": 2,
"comm_semigroup.{u} α": 1,
"has_le.{u} α": 2,
"linear_ordered_field.{u} α": 2,
"has_append.{u} (list.{u} α)": 1,
"has_one.{u} α": 2,
"monoid.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"preorder.{u} α": 2,
"linear_ordered_field.{u} α": 4,
"has_zero.{u} α": 1,
"preorder.{u} α": 1,
"linear_order.{u} α": 2,
"has_le.{u} α": 2,
"has_one.{u} α": 2,
"has_div.{u} α": 2,
"preorder.{u} α": 3,
"division_ring.{u} α": 1,
"partial_order.{u} α": 2,
"decidable_linear_order.{u} α": 2,
"has_div.{u} α": 2,
"decidable (has_lt.lt.{0} nat nat.has_lt i n)": 1,
"comm_semigroup.{u} α": 1,
"has_lt.{u} α": 1,
"has_zero.{u} α": 1,
"has_zero.{u} α": 2,
"linear_ordered_field.{u} α": 2,
"has_div.{u} α": 2,
"has_lt.{u} α": 3,
"decidable_linear_ordered_comm_group.{u} α": 2,
"linear_order.{u} α": 1,
"has_zero.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_append.{u} (list.{u} α)": 1,
"linear_ordered_field.{u} α": 2,
"preorder.{u} α": 3,
"partial_order.{u} α": 2,
"has_div.{u} α": 2,
"has_le.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 3,
"has_zero.{u} α": 1,
"has_one.{u} α": 4,
"has_one.{u} α": 2,
"has_lt.{u} α": 3,
"has_append.{u} (list.{u} α)": 1,
"has_zero.{u} α": 1,
"has_lt.{u} α": 1,
"has_le.{u} α": 2,
"ordered_semiring.{u} α": 2,
"has_lt.{u} α": 1,
"has_div.{u} α": 4,
"has_zero.{u} α": 3,
"linear_ordered_field.{u} α": 2,
"monoid.{u} α": 1,
"division_ring.{u} α": 1,
"has_div.{u} α": 6,
"has_one.{u} α": 7,
"has_add.{u} α": 7,
"add_monoid.{u} α": 2,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_zero.{u} α": 2,
"semiring.{u} α": 1,
"ordered_comm_group.{u} α": 1,
"has_lt.{u} α": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_mul.{u} α": 3,
"field.{u} α": 2,
"decidable (eq.{1} nat (has_mod.mod.{0} nat nat.has_mod x (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))) (has_one.one.{0} nat nat.has_one))": 1,
"linear_ordered_field.{u} α": 4,
"add_comm_semigroup.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"subsingleton.{1} (decidable c)": 1,
"has_add.{u} α": 1,
"has_one.{u} α": 1,
"preorder.{u} α": 2,
"semiring.{u} α": 2,
"linear_ordered_field.{u} α": 1,
"has_zero.{u} α": 2,
"has_zero.{u} α": 2,
"distrib.{u} α": 5,
"division_ring.{u} α": 1,
"has_add.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_lt.{u} α": 3,
"preorder.{u} α": 1,
"has_add.{u} α": 6,
"has_one.{u} α": 10,
"has_one.{u} α": 1,
"has_one.{u} α": 6,
"linear_ordered_field.{u} α": 1,
"has_add.{u} α": 3,
"has_add.{u} α": 2,
"has_sub.{u} α": 1,
"preorder.{u} α": 3,
"has_lt.{u} α": 2,
"linear_ordered_field.{u} α": 2,
"has_sub.{u} α": 2,
"has_one.{u} α": 6,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_div.{u} α": 6,
"preorder.{u} α": 2,
"has_mul.{u} α": 8,
"has_one.{u} α": 27,
"ordered_ring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_add.{u} α": 29,
"division_ring.{u} α": 2,
"ordered_ring.{u} α": 2,
"has_zero.{u} α": 1,
"has_one.{u} α": 1,
"preorder.{u} α": 2,
"has_zero.{u} α": 2,
"has_div.{u} α": 1,
"linear_ordered_field.{u} α": 1,
"has_one.{u} α": 1,
"linear_ordered_field.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_le.{u} α": 2,
"has_neg.{u} α": 1,
"division_ring.{u} α": 2,
"linear_ordered_field.{u} α": 1,
"has_div.{u} α": 2,
"linear_ordered_field.{u} α": 1,
"has_div.{u} α": 2,
"has_lt.{u} α": 1,
"preorder.{u} α": 1,
"has_le.{u} α": 2,
"division_ring.{u} α": 1,
"has_zero.{u} α": 1,
"has_lt.{u} α": 3,
"linear_ordered_field.{u} α": 1,
"preorder.{u} α": 1,
"ordered_semiring.{u} α": 1,
"division_ring.{u} α": 1,
"has_lt.{u} α": 3,
"decidable_linear_order.{u} α": 1,
"ordered_semiring.{u} α": 1,
"add_group.{u} α": 2,
"add_monoid.{u} α": 1,
"has_lt.{u} α": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_le.{u} α": 2,
"ordered_semiring.{u} α": 1,
"linear_ordered_semiring.{0} nat": 6,
"has_zero.{u} α": 3,
"division_ring.{u} α": 1,
"linear_ordered_field.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_add.{u} α": 2,
"has_lt.{u} α": 3,
"division_ring.{u} α": 1,
"add_group.{u} α": 2,
"has_lt.{u} α": 1,
"add_monoid.{u} α": 1,
"has_le.{u} α": 2,
"has_div.{u} α": 1,
"ordered_semiring.{u} α": 1,
"has_zero.{u} α": 3,
"field.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"division_ring.{u} α": 1,
"has_lt.{u} α": 3,
"has_zero.{u} α": 3,
"has_div.{u} α": 1,
"has_zero.{u} α": 3,
"has_div.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_div.{u} α": 2,
"comm_semigroup.{u} α": 1,
"has_le.{u} α": 5,
"has_div.{u} α": 10,
"comm_semigroup.{u} α": 1,
"has_le.{u} α": 7,
"has_sub.{u} α": 4,
"field.{u} α": 2,
"add_group.{u} α": 1,
"has_lt.{u} α": 5,
"has_div.{u} α": 10,
"has_sub.{u} α": 4,
"has_mul.{u} α": 6,
"has_mul.{u} α": 12,
"has_zero.{u} α": 7,
"has_zero.{u} α": 6,
"ordered_comm_group.{u} α": 2,
"division_ring.{u} α": 2,
"has_mul.{u} α": 4,
"has_sub.{u} α": 8,
"has_lt.{u} α": 6,
"has_one.{u} α": 3,
"has_sub.{u} α": 1,
"has_div.{u} α": 14,
"has_zero.{u} α": 7,
"linear_order.{u} α": 6,
"preorder.{u} α": 4,
"linear_ordered_field.{u} α": 2,
"ordered_semiring.{u} α": 2,
"has_le.{u} α": 3,
"partial_order.{0} nat": 20,
"has_div.{u} α": 2,
"has_lt.{u} α": 1,
"has_zero.{u} α": 1,
"has_one.{u} α": 3,
"linear_ordered_field.{u} α": 2,
"has_mul.{u} α": 9,
"ordered_semiring.{u} α": 2,
"division_ring.{u} α": 4,
"has_div.{u} α": 5,
"has_mul.{u} α": 5,
"has_zero.{u} α": 1,
"division_ring.{u} α": 4,
"has_zero.{u} α": 1,
"has_one.{u} α": 3,
"has_mul.{u} α": 5,
"ring.{0} int": 3,
"ordered_ring.{u} α": 2,
"has_lt.{u} α": 5,
"has_zero.{u} α": 1,
"comm_monoid.{0} nat": 1,
"division_ring.{u} α": 2,
"ordered_ring.{u} α": 2,
"preorder.{u} α": 3,
"has_mul.{u} α": 1,
"division_ring.{u} α": 4,
"has_lt.{u} α": 3,
"ordered_semiring.{u} α": 2,
"has_div.{u} α": 5,
"has_le.{u} α": 4,
"has_lt.{u} α": 1,
"ordered_ring.{u} α": 2,
"has_lt.{u} α": 1,
"has_one.{u} α": 3,
"division_ring.{u} α": 4,
"has_zero.{u} α": 5,
"has_mul.{u} α": 1,
"linear_ordered_field.{u} α": 2,
"has_le.{u} α": 2,
"ordered_semiring.{u} α": 2,
"has_mul.{u} α": 5,
"preorder.{u} α": 1,
"has_mul.{u} α": 1,
"division_ring.{u} α": 4,
"has_subset.{u} (list.{u} α)": 3,
"has_div.{u} α": 1,
"has_div.{u} α": 5,
"has_add.{u} α": 2,
"has_le.{u} α": 4,
"has_mul.{u} α": 5,
"has_div.{u} α": 2,
"linear_order.{u} α": 2,
"has_lt.{u} α": 1,
"has_mul.{u} α": 1,
"has_le.{u} α": 2,
"has_zero.{u} α": 1,
"field.{u} α": 2,
"ordered_semiring.{u} α": 2,
"preorder.{u} α": 1,
"division_ring.{u} α": 4,
"has_one.{u} α": 3,
"linear_ordered_field.{u} α": 2,
"has_lt.{u} α": 4,
"ordered_semiring.{u} α": 2,
"linear_ordered_field.{u} α": 2,
"has_one.{u} α": 7,
"has_mul.{u} α": 1,
"ordered_semiring.{u} α": 2,
"has_lt.{u} α": 6,
"add_comm_semigroup.{u} α": 25,
"preorder.{u} α": 3,
"has_one.{u} α": 1,
"monoid.{u} α": 1,
"linear_ordered_field.{u} α": 2,
"has_lt.{u} α": 1,
"has_zero.{u} α": 1,
"has_zero.{u} α": 2,
"has_one.{u} α": 7,
"preorder.{u} α": 4,
"has_div.{u} α": 6,
"has_le.{u} α": 4,
"decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) y) (has_le.le.{0} nat nat.has_le y x))": 1,
"has_lt.{u} α": 2,
"ordered_semiring.{u} α": 2,
"has_one.{u} α": 2,
"preorder.{u} α": 2,
"has_zero.{u} α": 1,
"has_mul.{u} α": 1,
"has_one.{u} α": 1,
"Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b))": 1,
"mul_zero_class.{u} α": 1,
"has_le.{u} α": 3,
"has_zero.{u} α": 1,
"preorder.{u} α": 1,
"has_mul.{u} α": 2,
"preorder.{u} α": 2,
"Pi (a : α), (decidable (p a))": 1,
"has_zero.{u} α": 1,
"linear_ordered_field.{u} α": 2,
"division_ring.{u} α": 3,
"linear_ordered_semiring.{u} α": 2,
"has_one.{u} α": 1,
"preorder.{u} α": 1,
"has_lt.{u} α": 2,
"has_div.{u} α": 4,
"linear_ordered_semiring.{u} α": 2,
"has_zero.{u} α": 2,
"has_one.{u} α": 1,
"has_inv.{u} α": 2,
"has_zero.{u} α": 2,
"has_one.{u} α": 4,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)": 1,
"has_div.{u} α": 2,
"has_mul.{u} α": 8,
"has_subset.{u} (list.{u} α)": 3,
"has_mul.{u} α": 8,
"has_lt.{u} α": 5,
"has_zero.{u} α": 6,
"comm_semigroup.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"has_well_founded.{1} (psigma.{1 1} nat (fun (a : nat), nat))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"preorder.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{u+1} (α -> α)": 4,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{u+1} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"linear_ordered_ring.{u} α": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))": 2,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"subsingleton.{1} (decidable p)": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"linear_ordered_semiring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{u+1} (α -> α)": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)": 1,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"has_lt.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"division_ring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"preorder.{u} α": 1,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{u+1} α": 4,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"ordered_ring.{u} α": 2,
"preorder.{u} α": 8,
"ordered_semiring.{u} α": 6,
"linear_order.{u} α": 3,
"has_zero.{u} α": 10,
"linear_ordered_semiring.{u} α": 4,
"linear_ordered_ring.{u} α": 2,
"linear_order.{u} α": 4,
"has_le.{u} α": 2,
"has_one.{u} α": 2,
"has_zero.{u} α": 2,
"ordered_semiring.{u} α": 2,
"add_group.{u} α": 1,
"has_mul.{u} α": 2,
"has_le.{u} α": 4,
"has_zero.{u} α": 2,
"ordered_comm_group.{u} α": 2,
"linear_ordered_semiring.{u} α": 1,
"preorder.{u} α": 3,
"has_le.{u} α": 3,
"linear_ordered_semiring.{u} α": 2,
"has_one.{u} α": 3,
"has_zero.{u} α": 1,
"has_neg.{u} α": 1,
"has_one.{u} α": 1,
"ring.{u} α": 2,
"ordered_semiring.{u} α": 4,
"preorder.{u} α": 10,
"add_group.{u} α": 2,
"has_neg.{u} α": 11,
"has_le.{u} α": 2,
"has_lt.{u} α": 6,
"has_zero.{u} α": 1,
"has_mul.{u} α": 12,
"linear_order.{u} α": 3,
"has_lt.{u} α": 5,
"has_zero.{u} α": 8,
"preorder.{u} α": 1,
"ordered_ring.{u} α": 2,
"linear_order.{u} α": 2,
"has_mul.{u} α": 1,
"has_append.{u} (list.{u} α)": 1,
"has_zero.{u} α": 4,
"ordered_semiring.{u} α": 4,
"add_comm_semigroup.{u} α": 23,
"ordered_cancel_comm_monoid.{u} α": 1,
"add_left_cancel_semigroup.{u} α": 1,
"has_lt.{0} (fin n)": 1,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"ordered_comm_group.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_add.{u} α": 5,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"Pi (a : α), (decidable (eq.{1} bool (lt h a) bool.tt))": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_neg.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{u+1} α": 4,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"mul_zero_class.{u} α": 1,
"ring.{u} α": 2,
"has_sub.{u} α": 8,
"monoid.{u} α": 1,
"has_zero.{u} α": 4,
"ordered_comm_group.{u} α": 4,
"has_neg.{u} α": 5,
"has_mul.{u} α": 6,
"ring.{u} α": 2,
"has_zero.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 1,
"mul_zero_class.{u} α": 1,
"has_lt.{u} α": 6,
"ordered_comm_group.{u} α": 4,
"has_neg.{u} α": 5,
"has_mul.{u} α": 6,
"has_zero.{u} α": 2,
"has_lt.{u} α": 6,
"ordered_ring.{u} α": 2,
"ordered_semiring.{u} α": 2,
"has_mul.{u} α": 3,
"subsingleton.{1} (decidable c)": 1,
"has_zero.{u} α": 1,
"has_neg.{u} α": 5,
"has_mul.{u} α": 6,
"has_zero.{u} α": 2,
"has_le.{u} α": 6,
"ordered_comm_group.{u} α": 4,
"has_neg.{u} α": 5,
"has_mul.{u} α": 6,
"ring.{u} α": 1,
"ring.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 1,
"add_right_cancel_semigroup.{u} α": 1,
"add_left_cancel_semigroup.{u} α": 1,
"ordered_ring.{u} α": 2,
"ordered_comm_group.{u} α": 4,
"has_sub.{u} α": 3,
"has_mem.{u u} α (list.{u} α)": 2,
"ordered_ring.{u} α": 2,
"linear_ordered_field.{u} α": 2,
"has_zero.{u} α": 3,
"has_lt.{u} α": 5,
"ordered_comm_group.{u} α": 4,
"has_sub.{u} α": 3,
"ordered_ring.{u} α": 2,
"subsingleton.{1} (decidable c)": 1,
"has_mul.{u} α": 3,
"has_zero.{u} α": 3,
"preorder.{u} α": 2,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)": 1,
"has_le.{u} α": 5,
"has_sub.{u} α": 3,
"has_mul.{u} α": 3,
"linear_ordered_field.{u} α": 4,
"has_zero.{u} α": 3,
"has_le.{u} α": 5,
"has_sub.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"subsingleton.{1} (decidable c)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))": 1,
"has_mul.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_append.{v} (list.{v} β)": 1,
"has_sizeof.{u+1} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"has_le.{u} α": 3,
"has_zero.{u} α": 6,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) y) (has_le.le.{0} nat nat.has_le y x))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"discrete_linear_ordered_field.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_semiring.to_ordered_cancel_comm_monoid.{u} α (ordered_semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left mul_le_mul_of_nonneg_left mul_le_mul_of_nonneg_right mul_lt_mul_of_pos_left mul_lt_mul_of_pos_right))))) zero one)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))": 1,
"subsingleton.{1} (decidable (eq.{1} (fin n) i j))": 1,
"decidable (eq.{1} nat (has_mod.mod.{0} nat nat.has_mod n m) (has_zero.zero.{0} nat nat.has_zero))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{u+1} α": 4,
"preorder.{u} α": 1,
"has_neg.{u} α": 1,
"ordered_semiring.{u} α": 2,
"linear_order.{u} α": 2,
"has_le.{u} α": 2,
"ordered_cancel_comm_monoid.{0} nat": 15,
"has_mul.{u} α": 1,
"linear_order.{u} α": 2,
"has_lt.{u} α": 2,
"ordered_semiring.{u} α": 2,
"has_le.{u} α": 2,
"has_zero.{u} α": 4,
"linear_order.{u} α": 2,
"has_lt.{u} α": 2,
"has_mul.{u} α": 1,
"has_zero.{u} α": 4,
"linear_order.{u} α": 2,
"preorder.{u} α": 1,
"has_zero.{u} α": 2,
"has_mul.{u} α": 1,
"has_zero.{u} α": 1,
"has_zero.{u} α": 4,
"linear_order.{u} α": 2,
"ordered_semiring.{u} α": 2,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_le.{u} α": 2,
"preorder.{u} α": 2,
"linear_order.{u} α": 2,
"ordered_semiring.{u} α": 2,
"preorder.{u} α": 2,
"has_lt.{u} α": 2,
"has_le.{u} α": 2,
"has_zero.{u} α": 4,
"has_one.{u} α": 2,
"has_mul.{u} α": 1,
"linear_order.{u} α": 2,
"preorder.{u} α": 2,
"linear_order.{u} α": 2,
"ordered_comm_group.{u} α": 2,
"ordered_semiring.{u} α": 2,
"has_lt.{u} α": 2,
"has_zero.{u} α": 5,
"linear_ordered_ring.{u} α": 2,
"has_mul.{u} α": 2,
"preorder.{u} α": 2,
"ordered_semiring.{u} α": 2,
"has_lt.{u} α": 3,
"has_zero.{u} α": 1,
"linear_order.{u} α": 2,
"has_lt.{u} α": 3,
"has_lt.{u} α": 1,
"ordered_semiring.{u} α": 2,
"has_le.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"linear_ordered_semiring.{u} α": 1,
"has_mul.{u} α": 4,
"linear_order.{u} α": 2,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a a)": 1,
"has_le.{u} α": 3,
"has_neg.{u} α": 1,
"has_zero.{u} α": 1,
"has_mul.{u} α": 4,
"linear_order.{u} α": 2,
"has_zero.{u} α": 5,
"has_zero.{u} α": 1,
"linear_ordered_semiring.{u} α": 2,
"has_div.{u} α": 17,
"preorder.{u} α": 2,
"ordered_comm_group.{u} α": 4,
"has_le.{u} α": 1,
"has_one.{u} α": 1,
"has_one.{u} α": 1,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_semiring.to_ordered_cancel_comm_monoid.{u} α (ordered_semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left mul_le_mul_of_nonneg_left mul_le_mul_of_nonneg_right mul_lt_mul_of_pos_left mul_lt_mul_of_pos_right))))) zero one)": 1,
"has_zero.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))": 1,
"has_le.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_semiring.to_ordered_cancel_comm_monoid.{u} α (ordered_semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left mul_le_mul_of_nonneg_left mul_le_mul_of_nonneg_right mul_lt_mul_of_pos_left mul_lt_mul_of_pos_right))))) zero one)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sub.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"semigroup.{0} int": 1,
"discrete_field.{u} α": 4,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_well_founded.{1} nat": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{u+1} α": 4,
"has_zero.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"has_lt.{u} α": 1,
"ordered_comm_group.{u} α": 2,
"mul_zero_class.{u} α": 1,
"mul_zero_class.{u} α": 1,
"has_mul.{u} α": 2,
"preorder.{u} α": 2,
"ordered_semiring.{u} α": 2,
"has_le.{u} α": 3,
"mul_zero_class.{u} α": 1,
"has_lt.{u} α": 4,
"has_zero.{u} α": 4,
"has_mul.{u} α": 3,
"has_lt.{u} α": 4,
"has_zero.{u} α": 4,
"mul_zero_class.{u} α": 1,
"has_lt.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"preorder.{u} α": 2,
"ordered_semiring.{u} α": 4,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"has_zero.{u} α": 2,
"preorder.{u} α": 2,
"has_lt.{u} α": 3,
"mul_zero_class.{u} α": 1,
"has_le.{u} α": 2,
"has_mul.{u} α": 5,
"ordered_semiring.{u} α": 2,
"has_lt.{u} α": 3,
"has_mul.{u} α": 3,
"has_mem.{u u} α (list.{u} α)": 3,
"has_le.{u} α": 4,
"has_zero.{u} α": 4,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)": 1,
"has_le.{u} α": 4,
"has_zero.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"ordered_semiring.{u} α": 2,
"has_mul.{u} α": 3,
"has_le.{u} α": 4,
"has_mul.{u} α": 5,
"has_le.{u} α": 5,
"has_mul.{u} α": 2,
"has_zero.{u} α": 1,
"ordered_semiring.{u} α": 2,
"ordered_semiring.{u} α": 2,
"has_zero.{u} α": 1,
"has_mul.{u} α": 2,
"has_append.{u} (list.{u} α)": 2,
"ordered_semiring.{u} α": 2,
"has_zero.{u} α": 1,
"has_le.{u} α": 3,
"comm_monoid.{0} int": 1,
"has_mul.{u} α": 2,
"division_ring.{u} α": 1,
"subsingleton.{1} (decidable p)": 1,
"field.{u} α": 1,
"has_one.{u} α": 1,
"has_mul.{u} α": 2,
"has_zero.{u} α": 3,
"monoid.{u} α": 1,
"has_add.{u} α": 2,
"decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"has_div.{u} α": 2,
"decidable (eq.{1} bool (expr.is_constant bool.tt c) bool.tt)": 1,
"has_zero.{u} α": 1,
"division_ring.{u} α": 1,
"division_ring.{u} α": 4,
"division_ring.{u} α": 2,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_div.{u} α": 4,
"field.{u} α": 2,
"preorder.{u} α": 2,
"field.{u} α": 2,
"has_mul.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"discrete_field.{u} α": 2,
"has_sub.{u} α": 2,
"decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"field.{u} α": 2,
"has_zero.{u} α": 4,
"has_div.{u} α": 3,
"decidable (eq.{u+1} α c (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"decidable (eq.{u+1} α d (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"monoid.{0} nat": 21,
"mul_zero_class.{u} α": 1,
"has_zero.{u} α": 2,
"comm_semigroup.{u} α": 2,
"has_le.{u} α": 3,
"has_div.{u} α": 2,
"discrete_field.{u} α": 4,
"subsingleton.{1} (decidable c)": 1,
"has_mul.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"division_ring.{u} α": 2,
"integral_domain.{u} α": 2,
"field.{u} α": 2,
"subsingleton.{1} (decidable c)": 1,
"has_mul.{u} α": 2,
"decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"has_zero.{u} α": 1,
"discrete_field.{u} α": 2,
"has_mul.{u} α": 3,
"subsingleton.{1} (decidable c)": 1,
"mul_zero_class.{u} α": 1,
"has_div.{u} α": 3,
"discrete_field.{u} α": 2,
"decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"has_one.{u} α": 1,
"has_div.{u} α": 2,
"comm_semigroup.{u} α": 1,
"discrete_field.{u} α": 2,
"discrete_field.{u} α": 1,
"division_ring.{u} α": 2,
"has_le.{u} α": 1,
"mul_zero_class.{u} α": 4,
"subsingleton.{1} (decidable c)": 1,
"has_one.{u} α": 1,
"has_mul.{u} α": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_zero.{u} α": 3,
"division_ring.{u} α": 3,
"has_one.{u} α": 3,
"has_div.{u} α": 3,
"decidable_linear_ordered_comm_group.{u} α": 5,
"division_ring.{u} α": 2,
"discrete_field.{u} α": 2,
"has_zero.{u} α": 2,
"has_zero.{u} α": 4,
"add_comm_semigroup.{u} α": 21,
"has_inv.{u} α": 3,
"discrete_field.{u} α": 1,
"division_ring.{u} α": 2,
"discrete_field.{u} α": 5,
"decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"has_one.{u} α": 2,
"has_lt.{u} α": 1,
"decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"mul_zero_class.{u} α": 4,
"has_zero.{u} α": 2,
"has_zero.{u} α": 2,
"has_div.{u} α": 2,
"decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"has_zero.{u} α": 2,
"has_neg.{u} α": 2,
"mul_zero_class.{u} α": 1,
"has_zero.{u} α": 4,
"has_one.{u} α": 3,
"has_mul.{u} α": 2,
"has_div.{u} α": 3,
"discrete_field.{u} α": 1,
"has_add.{u} α": 5,
"discrete_field.{u} α": 1,
"division_ring.{u} α": 1,
"division_ring.{u} α": 2,
"decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"has_div.{u} α": 1,
"has_one.{u} α": 1,
"has_zero.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"preorder.{u} α": 1,
"has_mul.{u} α": 1,
"has_coe_t.{1 1} (expr bool.tt) (option.{0} (expr bool.tt))": 2,
"decidable (le a b)": 1,
"group.{u} α": 1,
"group.{u} α": 1,
"decidable (eq.{1} bool b bool.tt)": 1,
"Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))": 1,
"has_mul.{u} α": 2,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"has_add.{u} α": 4,
"decidable_linear_order.{u} α": 3,
"has_dvd.{u} α": 1,
"has_neg.{u} α": 3,
"has_add.{u} α": 1,
"has_mul.{u} α": 2,
"has_coe_t.{1 1} (reflected.{1} string acc) (expr bool.tt)": 1,
"has_le.{u} α": 3,
"has_inv.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"has_add.{u} α": 2,
"has_to_string.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_inv.{u} α": 1,
"group.{u} α": 2,
"monoid.{u} α": 1,
"distrib.{u} α": 2,
"subsingleton.{1} (decidable (or (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) n) (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))))))))))))": 1,
"has_mul.{u} α": 2,
"decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"add_comm_semigroup.{u} α": 2,
"has_mul.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))": 1,
"preorder.{u} α": 2,
"has_zero.{u} α": 4,
"monoid.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"has_inv.{u} α": 2,
"has_one.{u} α": 1,
"reflected.{1} name _p.1": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"group.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))": 1,
"semigroup.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))": 1,
"subsingleton.{1} (decidable c)": 1,
"decidable (and (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt e)) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))) name.anonymous)) (eq.{1} nat (expr.get_app_num_args e) (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))": 1,
"has_mul.{u} α": 1,
"has_mul.{u} α": 2,
"preorder.{u} α": 1,
"semigroup.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_inv.{u} α": 4,
"has_zero.{u} α": 1,
"group.{u} α": 2,
"mul_zero_class.{u} α": 4,
"Pi (a : α) (b : α), (decidable (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"has_mul.{u} α": 4,
"has_inv.{u} α": 4,
"has_lt.{u} α": 1,
"group.{u} α": 2,
"decidable_linear_order.{u} α": 2,
"has_inv.{u} α": 1,
"has_mul.{u} α": 1,
"group.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_lt.{u} α": 2,
"has_mul.{u} α": 2,
"has_bind.{u v} m": 1,
"decidable (eq.{u} α a b)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))": 1,
"has_inv.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"group.{u} α": 2,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"has_sizeof.{(imax u v)} (a -> S)": 1,
"has_mul.{u} α": 1,
"has_one.{u} α": 1,
"has_sizeof.{u+1} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_le.{u} α": 1,
"has_dvd.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"linear_order.{u} α": 2,
"add_comm_semigroup.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_mul.{u} α": 5,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"comm_semigroup.{u} α": 2,
"has_mul.{u} α": 4,
"preorder.{u} α": 2,
"has_mul.{u} α": 1,
"decidable (iff (eq.{1} bool (bxor bool.tt bool.tt) bool.tt) (xor (eq.{1} bool bool.tt bool.tt) (eq.{1} bool bool.tt bool.tt)))": 1,
"has_div.{u} α": 4,
"has_mul.{u} α": 2,
"has_add.{u} α": 1,
"has_one.{u} α": 2,
"has_le.{u} α": 4,
"ordered_semiring.{u} α": 2,
"semigroup.{u} α": 2,
"has_to_format.{0} data": 1,
"semiring.{0} int": 1,
"linear_ordered_field.{u} α": 2,
"has_mul.{u} α": 4,
"ordered_comm_group.{u} α": 4,
"decidable (iff (eq.{1} bool (band bool.tt bool.ff) bool.tt) (and (eq.{1} bool bool.tt bool.tt) (eq.{1} bool bool.ff bool.tt)))": 1,
"monoid.{u} α": 2,
"decidable (iff (eq.{1} bool (bor bool.ff bool.tt) bool.tt) (or (eq.{1} bool bool.ff bool.tt) (eq.{1} bool bool.tt bool.tt)))": 1,
"decidable c": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"decidable (or (eq.{1} bool (tactic.simp_config.fail_if_unchanged cfg) bool.ff) (or (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) (list.length.{0} (expr bool.tt) to_remove)) (eq.{1} bool goal_simplified bool.tt)))": 1,
"has_lt.{0} key": 1,
"has_one.{u} α": 1,
"monoid.{u} α": 1,
"add_monoid.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_dvd.{u} α": 2,
"decidable (iff (not (eq.{1} bool bool.ff bool.tt)) (eq.{1} bool bool.ff bool.ff))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"distrib.{0} int": 1,
"has_bind.{0 0} m": 1,
"has_orelse.{0 0} option.{0}": 2,
"has_sizeof.{u+1} (α -> α)": 2,
"decidable p": 2,
"add_comm_semigroup.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_div.{u} α": 1,
"monad_fail.{0 0} conv.{0}": 30,
"has_le.{u} α": 2,
"field.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{u+1} α": 2,
"field.{u} α": 3,
"has_mul.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a c)), (eq.{u+1} α b c))": 1,
"has_zero.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a c)), (eq.{u+1} α b c))": 1,
"field.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_mul.{u} α": 4,
"decidable (eq.{1} bool (expr.alpha_eqv t e) bool.tt)": 1,
"has_sizeof.{u+1} (α -> α)": 2,
"has_div.{u} α": 3,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state (expr bool.ff))) (smt_tactic (expr bool.ff))": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))": 1,
"decidable (has_lt.lt.{0} nat nat.has_lt sz' (prod.snd.{0 0} (expr bool.tt) nat p))": 1,
"decidable (eq.{1} bool (rsimp.is_value_like e) bool.tt)": 1,
"has_mul.{u} α": 1,
"has_le.{u} α": 2,
"has_one.{u} α": 3,
"decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"decidable (and (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt e)) (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))) (eq.{1} nat (expr.get_app_num_args e) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))": 1,
"linear_ordered_semiring.{u} α": 2,
"has_inv.{u} α": 1,
"has_sizeof.{(max ((u+1)+1) (v+1))} (Pi {α : Type.{u}} {β : Type.{u}} (a : f α) (a : f β), (f β))": 2,
"ordered_ring.{u} α": 2,
"has_sizeof.{u+1} (α -> α)": 2,
"comm_semigroup.{u} α": 1,
"decidable (not (eq.{1} bool (expr.is_constant bool.tt (expr.get_app_fn bool.tt e)) bool.tt))": 1,
"decidable (not (eq.{1} nat i idx))": 1,
"division_ring.{u} α": 8,
"monoid.{u} α": 2,
"decidable (eq.{1} bool c bool.tt)": 1,
"decidable (eq.{1} bool (expr.is_false t) bool.tt)": 1,
"decidable (eq.{1} bool c bool.tt)": 1,
"has_seq.{u v} f": 1,
"inhabited.{u} α": 1,
"has_neg.{u} α": 2,
"has_mul.{u} α": 2,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state α)) (smt_tactic α)": 1,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state hinst_lemma)) (smt_tactic hinst_lemma)": 5,
"has_zero.{u} α": 1,
"has_repr.{0} nat": 6,
"has_sub.{u} α": 1,
"has_bind.{0 0} smt_tactic": 120,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state α)) (smt_tactic α)": 1,
"preorder.{u} α": 3,
"has_mul.{u} α": 2,
"has_dvd.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"Pi (a_1 : β), (subsingleton.{u_c} (φ (quotient.mk.{u_a} α s₁ a) (quotient.mk.{u_b} β s₂ a_1)))": 1,
"decidable (eq.{1} bool (p (string.iterator.curr stop)) bool.tt)": 1,
"field.{u} α": 2,
"alternative.{0 0} (state_t.{0 0} smt_state (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))))": 1,
"has_lt.{u} α": 2,
"has_zero.{u} α": 2,
"has_zero.{u} α": 1,
"has_mul.{u} α": 1,
"has_dvd.{u} α": 2,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"has_mem.{u u} (set.{u} α) (set.{u} (set.{u} α))": 1,
"has_monad_lift_t.{u u_1 v} n m": 1,
"monad.{u_1 u_1} option.{u_1}": 17,
"has_lt.{u} α": 2,
"has_mul.{u} α": 1,
"decidable (eq.{1} name a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))": 1,
"semigroup.{u} α": 2,
"has_mem.{u u} α (set.{u} α)": 1,
"has_sep.{u u} α (set.{u} α)": 1,
"has_sizeof.{v+1} β": 1,
"has_zero.{u} α": 2,
"has_one.{u} α": 2,
"has_mul.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_zero.{u} α": 1,
"has_div.{u} α": 2,
"has_mem.{u u} α (set.{u} α)": 1,
"is_lawful_functor.{u v} m (applicative.to_functor.{u v} m (monad.to_applicative.{u v} m _inst_1))": 1,
"has_zero.{u} α": 1,
"semigroup.{u} α": 2,
"has_bind.{u v} m": 1,
"functor.{u v} (option_t.{u v} m)": 1,
"has_bind.{u v} (option_t.{u v} m)": 1,
"monad.{u v} m": 1,
"has_add.{u} α": 1,
"has_neg.{u} α": 1,
"has_bind.{u v} m": 1,
"has_mul.{u} α": 5,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))": 1,
"has_pure.{u v} (option_t.{u v} m)": 1,
"has_sub.{u} α": 1,
"add_comm_semigroup.{u} α": 3,
"has_zero.{u} α": 1,
"monad.{u (max u v)} (reader_t.{u v} ρ m)": 52,
"is_lawful_monad.{u v} m _inst_1": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"reflected.{1} (list.{0} tactic.interactive.rw_rule) _p.1": 1,
"monad.{u v} m": 2,
"decidable_linear_order.{u} α": 6,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_semiring.to_ordered_cancel_comm_monoid.{u} α (ordered_semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left mul_le_mul_of_nonneg_left mul_le_mul_of_nonneg_right mul_lt_mul_of_pos_left mul_lt_mul_of_pos_right))))) zero one)": 1,
"functor.{u v} m": 1,
"decidable (eq.{1} bool (name_set.empty s) bool.tt)": 1,
"monad.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_bind.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_pure.{u (max u v)} (reader_t.{u v} ρ m)": 1,
"has_coe_t.{1 1} string format": 37,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"applicative.{u v} m": 1,
"monad.{u v} (except_t.{u v} ε m)": 39,
"Pi (a : list.{0} tactic.simp_arg_type), (reflected.{1} (list.{0} tactic.simp_arg_type) a)": 8,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_neg.{u} α": 2,
"has_zero.{u} α": 2,
"functor.{u v} m": 1,
"monad.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))": 44,
"semigroup.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"decidable (iff (eq.{1} bool (bor bool.tt bool.tt) bool.tt) (or (eq.{1} bool bool.tt bool.tt) (eq.{1} bool bool.tt bool.tt)))": 1,
"has_bind.{u v} (except_t.{u v} ε m)": 1,
"decidable (iff (eq.{1} bool (bxor bool.ff bool.tt) bool.tt) (xor (eq.{1} bool bool.ff bool.tt) (eq.{1} bool bool.tt bool.tt)))": 1,
"has_lt.{u} α": 5,
"has_lt.{u} α": 1,
"has_pure.{u v} m": 1,
"has_div.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_pure.{u v} (except_t.{u v} ε m)": 1,
"monad.{u (max u v)} (state_t.{u v} σ m)": 52,
"has_lt.{u_1} key": 1,
"has_pure.{u v} m": 1,
"is_asymm.{u} α r": 1,
"has_pure.{u v} f": 1,
"has_mul.{u} α": 2,
"has_mul.{u} α": 2,
"decidable (eq.{1} nat (nat.bit b n) (has_zero.zero.{0} nat nat.has_zero))": 3,
"has_append.{0} smt_state": 1,
"is_incomp_trans.{u} α r": 1,
"add_comm_semigroup.{u} α": 3,
"has_pure.{u v} m": 1,
"decidable (eq.{1} bool (string.iterator.has_next stop) bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_bind.{u v} m": 1,
"left_cancel_semigroup.{u} α": 2,
"has_sizeof.{u+1} α": 4,
"division_ring.{u} α": 2,
"monad_functor_t.{u u_1 (max u v)} n n' (state_t.{u v} σ m) (state_t.{u v} σ m')": 1,
"decidable (not (eq.{1} bool (expr.is_app e) bool.tt))": 1,
"has_monad_lift_t.{u u_1 (max u v)} n (state_t.{u v} σ m)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))": 1,
"has_bind.{u v} m": 1,
"has_one.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"decidable c": 1,
"division_ring.{u} α": 1,
"preorder.{u} α": 1,
"functor.{u (max u v)} (state_t.{u v} σ m)": 1,
"has_sub.{u} α": 1,
"functor.{u v} m": 1,
"has_orelse.{u u} (fun (α : Type.{u}), (tactic_state -> (interaction_monad.result.{u} tactic_state α)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"monad.{u v} m": 16,
"linear_ordered_ring.{u} α": 1,
"monoid.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"monad.{0 v} m": 1,
"alternative.{0 0} conv.{0}": 1,
"has_pure.{u (max u v)} (state_t.{u v} σ m)": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{u+1} α": 2,
"has_le.{u} α": 4,
"is_lawful_functor.{u v} m (applicative.to_functor.{u v} m (monad.to_applicative.{u v} m _inst_1))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"decidable (iff (eq.{1} bool (band bool.ff bool.ff) bool.tt) (and (eq.{1} bool bool.ff bool.tt) (eq.{1} bool bool.ff bool.tt)))": 1,
"monad.{u_1 u_1} (id.{(u_1+1)+1} Type.{u_1})": 17,
"ordered_cancel_comm_monoid.{u} α": 1,
"functor.{u v} m": 2,
"preorder.{u} α": 2,
"is_lawful_monad.{u v} m _inst_1": 1,
"has_to_string.{0} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_mem.{u u} α (set.{u} α)": 1,
"decidable (not (has_mem.mem.{0 0} nat (list.{0} nat) (list.has_mem.{0} nat) p ps))": 1,
"add_group.{u} α": 1,
"semigroup.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"add_group.{u} α": 2,
"has_to_format.{0} α": 1,
"has_sizeof.{1} smt_pre_config": 2,
"has_monad_lift_t.{u v v} m m": 1,
"has_bind.{u v} m": 2,
"has_lt.{u} α": 4,
"division_ring.{u} α": 1,
"decidable (has_mem.mem.{0 0} nat (list.{0} nat) (list.has_mem.{0} nat) i occs)": 1,
"is_lawful_monad.{u v} m _inst_1": 1,
"division_ring.{u} α": 2,
"has_seq.{u v} m": 1,
"has_add.{0} int": 112,
"has_pure.{u v} m": 2,
"decidable (not (eq.{1} bool (expr.alpha_eqv new_t t) bool.tt))": 1,
"Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))": 1,
"decidable (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) (has_one.one.{0} nat nat.has_one))": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"ring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) c b)), (eq.{u+1} α a c))": 1,
"decidable (eq.{1} bool matched bool.tt)": 1,
"decidable c": 1,
"functor.{u v} m": 5,
"has_mem.{u u} α (array.{u} n α)": 1,
"has_orelse.{0 0} conv.{0}": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"alternative.{0 0} smt_tactic": 2,
"has_to_format.{u} α": 1,
"has_add.{u} α": 1,
"has_pure.{u v} f": 1,
"has_lt.{u} α": 4,
"decidable (and (eq.{1} bool (environment.is_ginductive env I_name) bool.tt) (not (eq.{1} bool (environment.is_inductive env I_name) bool.tt)))": 1,
"has_andthen.{0 0 0} (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (list.{0} (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))": 3,
"decidable (eq.{1} name a_a_a_a_1_hd_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_one.{u} α": 5,
"decidable (eq.{1} bool (environment.is_recursive env I_name) bool.tt)": 1,
"decidable_linear_ordered_comm_group.{u} α": 1,
"decidable (eq.{1} name r (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_one.{u} α": 2,
"decidable (not (eq.{1} (option.{0} (expr bool.tt)) (tactic.simp_all_entry.pr e) (option.none.{0} (expr bool.tt))))": 1,
"decidable (eq.{1} name r (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_coe_t.{1 1} string name": 1,
"has_mul.{u} α": 3,
"has_coe_t.{1 1} (reflected.{1} β a) (expr bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))": 1,
"has_zero.{u} α": 2,
"has_add.{u} α": 1,
"decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_sub.{u} α": 1,
"functor.{u v} f": 6,
"subsingleton.{v} (β a)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"monad.{0 0} conv.{0}": 9,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_bind.{0 0} conv.{0}": 51,
"decidable (eq.{1} (expr bool.tt) t r)": 1,
"linear_ordered_field.{u} α": 2,
"has_pure.{u v} f": 4,
"alternative.{u_1 u_1} (fun (α : Type.{u_1}), (tactic_state -> (interaction_monad.result.{u_1} tactic_state α)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_mul.{u} α": 1,
"decidable (eq.{1} bool (expr.has_meta_var tgt) bool.tt)": 1,
"add_group.{u} α": 2,
"has_neg.{u} α": 1,
"decidable (and (eq.{1} bool (list.empty.{0} name hs) bool.tt) (eq.{1} bool (option.is_none.{0} environment.projection_info (environment.is_projection env (expr.const_name bool.ff n))) bool.tt))": 1,
"has_mul.{u} α": 1,
"decidable (eq.{1} bool (environment.contains env n) bool.tt)": 1,
"decidable (eq.{1} bool (environment.contains env curr) bool.tt)": 1,
"decidable (eq.{1} bool (option.is_none.{0} punit.{1} use_iota_eqn) bool.tt)": 1,
"functor.{0 0} (id.{2} Type)": 1,
"decidable (eq.{1} bool all_hyps bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"add_group.{u} α": 1,
"has_sub.{u} α": 3,
"add_group.{u} α": 1,
"decidable c": 3,
"decidable (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) (list.length.{0} name eqns))": 1,
"decidable (eq.{1} bool b bool.tt)": 1,
"monoid.{u} α": 1,
"has_div.{0} nat": 86,
"has_lt.{u} α": 3,
"has_neg.{u} α": 3,
"functor.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_lt.{u} α": 3,
"has_mul.{u} α": 2,
"decidable (eq.{1} bool (pexpr.is_choice_macro p) bool.tt)": 1,
"has_sub.{u} α": 1,
"decidable (not (eq.{1} bool all_hyps bool.tt))": 1,
"has_div.{u} α": 2,
"decidable (eq.{1} bool b bool.tt)": 1,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"has_zero.{u} α": 5,
"decidable (eq.{1} bool at_most_one bool.tt)": 1,
"has_mem.{0 0} name (list.{0} name)": 2,
"subsingleton.{1} (decidable c)": 1,
"decidable (le c b)": 1,
"decidable_linear_ordered_comm_group.{u} α": 9,
"has_sub.{u} α": 1,
"Pi (a : option.{0} punit.{1}), (reflected.{1} (option.{0} punit.{1}) a)": 7,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{v+1} β": 1,
"Pi (a : sum.{0 0} (expr bool.ff) (list.{0} (expr bool.ff))), (reflected.{1} (sum.{0 0} (expr bool.ff) (list.{0} (expr bool.ff))) a)": 2,
"has_zero.{u} α": 3,
"has_to_string.{0} name": 8,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_monad_lift_t.{u u_1 v} n m": 1,
"decidable (has_lt.lt.{0} nat nat.has_lt (list.length.{0} name (option.get_or_else.{0} (list.{0} name) ids (list.nil.{0} name))) n)": 1,
"decidable (eq.{1} name _a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"decidable (eq.{1} name ty' ty)": 1,
"decidable (eq.{1} (expr bool.tt) a eq)": 1,
"subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))": 1,
"ordered_comm_group.{u} α": 2,
"has_bind.{0 0} option.{0}": 4,
"has_le.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_add.{u} α": 1,
"monad.{u v} m": 4,
"add_group.{u} α": 1,
"Pi (a : option.{0} (list.{0} name)), (reflected.{1} (option.{0} (list.{0} name)) a)": 3,
"has_zero.{u} α": 3,
"division_ring.{u} α": 2,
"Pi (a : prod.{0 0} (option.{0} name) (expr bool.ff)), (reflected.{1} (prod.{0 0} (option.{0} name) (expr bool.ff)) a)": 6,
"ordered_comm_group.{u} α": 2,
"group.{u} α": 1,
"Pi (a : prod.{0 0} (expr bool.ff) name), (reflected.{1} (prod.{0 0} (expr bool.ff) name) a)": 1,
"decidable c": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_mul.{u} α": 5,
"has_sub.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 2,
"reflected.{1} (pos -> bool -> (expr bool.ff) -> tactic.interactive.rw_rule) tactic.interactive.rw_rule.mk": 1,
"has_le.{u} α": 2,
"has_mem.{u u} α (set.{u} α)": 2,
"reflected.{1} (expr bool.ff) _p.3": 1,
"reflected.{1} bool _p.2": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"reflected.{1} pos _p.1": 1,
"reflected.{2} Type hinst_lemmas": 1,
"Pi (a : option.{0} (expr bool.ff)), (reflected.{1} (option.{0} (expr bool.ff)) a)": 13,
"decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"ring.{u} α": 2,
"is_lawful_functor.{u v} f (applicative.to_functor.{u v} f _inst_1)": 1,
"Pi (a : expr bool.ff), (reflected.{1} (expr bool.ff) a)": 33,
"comm_semigroup.{0} nat": 91,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_zero.{u} α": 1,
"has_coe_t.{1 1} (reflected.{1} (user_attribute hinst_lemmas punit.{1}) (user_attribute.mk hinst_lemmas punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.some.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (n : name) (_x : nat) (_x : bool), (has_orelse.orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (alternative.to_has_orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) tactic.alternative.{0}) punit.{1} (has_bind.and_then.{0 0} hinst_lemmas punit.{1} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (to_hinst_lemmas_core tactic.transparency.reducible as_simp (list.cons.{0} name n (list.nil.{0} name)) hinst_lemmas.mk) tactic.skip) (tactic.fail.{0 0} punit.{1} format format.has_to_format (has_append.append.{0} format format.has_append (has_append.append.{0} format format.has_append (to_fmt.{0} string string.has_to_format (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (to_fmt.{0} name name.has_to_format n)) (to_fmt.{0} string string.has_to_format (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))) (option.some.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (_x : name) (_x : bool), tactic.skip)) (user_attribute_cache_cfg.mk hinst_lemmas (fun (ns : list.{0} name), (to_hinst_lemmas_core tactic.transparency.reducible as_simp ns hinst_lemmas.mk)) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (list.nil.{0} name))) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))) (expr bool.tt)": 1,
"decidable (p x)": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"mul_zero_class.{u} α": 1,
"decidable (eq.{1} (expr bool.tt) (expr.get_app_fn bool.tt lhs) (expr.get_app_fn bool.tt rhs))": 1,
"reflected.{1} (user_attribute hinst_lemmas punit.{1}) (user_attribute.mk hinst_lemmas punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.some.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (n : name) (_x : nat) (_x : bool), (has_orelse.orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (alternative.to_has_orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) tactic.alternative.{0}) punit.{1} (has_bind.and_then.{0 0} hinst_lemmas punit.{1} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (to_hinst_lemmas_core tactic.transparency.reducible as_simp (list.cons.{0} name n (list.nil.{0} name)) hinst_lemmas.mk) tactic.skip) (tactic.fail.{0 0} punit.{1} format format.has_to_format (has_append.append.{0} format format.has_append (has_append.append.{0} format format.has_append (to_fmt.{0} string string.has_to_format (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (to_fmt.{0} name name.has_to_format n)) (to_fmt.{0} string string.has_to_format (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))) (option.some.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (_x : name) (_x : bool), tactic.skip)) (user_attribute_cache_cfg.mk hinst_lemmas (fun (ns : list.{0} name), (to_hinst_lemmas_core tactic.transparency.reducible as_simp ns hinst_lemmas.mk)) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (list.nil.{0} name))) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))": 1,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state α)) (smt_tactic α)": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_le.{u} α": 2,
"has_mul.{u} α": 2,
"has_one.{u} α": 3,
"reflected.{2} Type (user_attribute hinst_lemmas punit.{1})": 3,
"ordered_cancel_comm_monoid.{u} α": 2,
"decidable (eq.{1} tactic.tag tag (list.nil.{0} name))": 1,
"has_lt.{u} α": 2,
"has_le.{u} α": 2,
"reflected.{1} nat _p.1": 1,
"division_ring.{u} α": 1,
"has_repr.{0} binder_info": 2,
"has_zero.{u} α": 1,
"reflected.{1} α _p.1": 1,
"reflected.{1} (option.{0} α) (option.none.{0} α)": 1,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"reflected.{1} (β -> (sum.{0 0} α β)) (sum.inr.{0 0} α β)": 1,
"add_comm_semigroup.{u} α": 1,
"monad.{0 0} (option_t.{0 0} vm_core)": 2,
"decidable (eq.{1} name _a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"reflected.{1} (α -> β -> (prod.{0 0} α β)) (prod.mk.{0 0} α β)": 1,
"decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))": 1,
"decidable q": 1,
"has_dvd.{u} α": 2,
"has_zero.{u} α": 3,
"reflected.{1} β _p.2": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))": 1,
"reflected.{1} α _p.1": 1,
"has_le.{u} α": 1,
"has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} (a : α), (f α))": 2,
"add_monoid.{u} α": 1,
"reflected.{1} bool bool.tt": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"decidable (eq.{1} bool (expr.is_constant_of bool.ff p cls) bool.tt)": 1,
"decidable (not (eq.{1} bool success bool.tt))": 1,
"preorder.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_to_format.{0} (expr bool.ff)": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))": 1,
"is_lawful_monad.{u v} m _inst_1": 6,
"has_to_tactic_format.{0} (list.{0} (expr bool.tt))": 1,
"has_to_tactic_format.{0} nat": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_coe_t.{u+1 u+1} α (option.{u} α)": 1,
"decidable (eq.{1} bool rec bool.tt)": 2,
"decidable (eq.{1} bool (expr.is_app e) bool.tt)": 1,
"decidable p": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : eq.{u+1} α (mul a b) zero), (or (eq.{u+1} α a zero) (eq.{u+1} α b zero)))": 1,
"add_monoid.{u} α": 1,
"monad.{0 0} m": 1,
"has_neg.{u} α": 2,
"has_sizeof.{0} (equivalence.{u} α r)": 1,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))": 1,
"decidable (eq.{1} char a_tl_hd (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))": 1,
"decidable (eq.{1} char a_hd (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))": 1,
"has_to_pexpr.{1} (reflected.{1} string acc)": 1,
"decidable (eq.{1} char a_hd (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))": 1,
"add_monoid.{u} α": 1,
"has_add.{u} α": 2,
"decidable (eq.{1} char a_hd (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))": 1,
"decidable (eq.{1} char hd (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))": 1,
"add_monoid.{u} α": 1,
"has_one.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_to_pexpr.{1} (reflected.{1} string acc)": 1,
"ordered_comm_group.{u} α": 4,
"has_zero.{u} α": 4,
"has_lt.{u} α": 2,
"semigroup.{u} α": 2,
"has_lt.{u} α": 1,
"has_sizeof.{(imax u v)} (Pi (x : a), (F x))": 1,
"reflected.{1} string acc": 1,
"decidable (iff (eq.{1} bool (band bool.ff bool.tt) bool.tt) (and (eq.{1} bool bool.ff bool.tt) (eq.{1} bool bool.tt bool.tt)))": 1,
"has_to_pexpr.{1} (reflected.{1} string acc)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"decidable (not (eq.{1} (option.{0} (expr bool.tt)) (tactic.simp_all_entry.pr e) (option.none.{0} (expr bool.tt))))": 1,
"has_bind.{u v} m": 1,
"has_mem.{u u} α (list.{u} α)": 1,
"has_add.{u} α": 1,
"has_neg.{u} α": 1,
"reflected.{1} string acc": 1,
"has_lt.{u} α": 3,
"has_coe_t.{1 1} nat (option.{0} nat)": 1,
"add_comm_semigroup.{u} α": 36,
"decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"decidable (and (eq.{1} bool (expr.is_constant bool.tt e) bool.tt) (eq.{1} name (list.ilast.{0} name name.inhabited (name.components (expr.const_name bool.tt e))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"preorder.{u} α": 3,
"has_zero.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"add_comm_semigroup.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_mul.{u} α": 1,
"has_coe_t.{1 1} (reflected.{1} Prop false) (expr bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"add_monoid.{u} α": 1,
"comm_semiring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"is_lawful_monad.{u v} m _inst_1": 1,
"decidable (eq.{1} bool (_private.111772443.tag_match t pre) bool.tt)": 1,
"linear_order.{u} α": 2,
"monad_functor_t.{u v v} m m' n n'": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))": 10,
"decidable (or (eq.{1} bool (tactic.simp_config.fail_if_unchanged cfg) bool.ff) (or (eq.{1} bool target_changed bool.tt) (eq.{1} bool (list.any.{0} tactic.simp_all_entry r (fun (e : tactic.simp_all_entry), (decidable.to_bool (not (eq.{1} (option.{0} (expr bool.tt)) (tactic.simp_all_entry.pr e) (option.none.{0} (expr bool.tt)))) (ne.decidable.{1} (option.{0} (expr bool.tt)) (option.decidable_eq.{0} (expr bool.tt) expr.has_decidable_eq) (tactic.simp_all_entry.pr e) (option.none.{0} (expr bool.tt)))))) bool.tt)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"monad.{u v} m": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"decidable (eq.{1} (list.{0} char) cs₁ cs₂)": 1,
"has_seq.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))": 5,
"decidable (eq.{1} bool (expr.is_pi new_t) bool.tt)": 1,
"has_zero.{u} α": 1,
"monoid.{u} α": 2,
"decidable (eq.{1} bool (bor (expr.is_pi t) (expr.is_let t)) bool.tt)": 1,
"ordered_semiring.{u} α": 2,
"has_one.{u} α": 3,
"decidable (eq.{1} bool use_hyps bool.tt)": 1,
"monoid.{u} α": 2,
"decidable (eq.{1} bool (expr.is_local_constant h) bool.ff)": 1,
"decidable (eq.{1} name (name.get_prefix (expr.const_name bool.tt (expr.get_app_fn bool.tt e))) c)": 1,
"decidable (eq.{1} bool (expr.is_app_of e c) bool.tt)": 1,
"has_sizeof.{1} occurrences": 2,
"comm_semigroup.{u} α": 3,
"has_zero.{u} α": 6,
"add_group.{u} α": 1,
"has_sizeof.{1} tactic.apply_cfg": 2,
"Pi (a : α) (b : α), (decidable (eq.{u+1} α a b))": 1,
"add_group.{u} α": 5,
"decidable (eq.{1} name a_a_a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"has_coe_to_sort.{u₂ u₃} b": 2,
"has_repr.{u} α": 1,
"Pi (a : list.{0} (expr bool.ff)), (reflected.{1} (list.{0} (expr bool.ff)) a)": 12,
"decidable (eq.{1} name a_a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))": 1,
"semigroup.{u} α": 1,
"has_one.{u} α": 1,
"linear_ordered_field.{u} α": 2,
"decidable (eq.{1} (expr bool.tt) (cc_state.next s e) e)": 1,
"decidable_linear_order.{u} α": 2,
"decidable (eq.{1} bool (expr.is_local_constant (expr.get_app_fn bool.tt e)) bool.tt)": 1,
"decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"has_mul.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"has_equiv.{u} α": 1,
"has_div.{u} α": 2,
"has_lift_t.{ua₁+1 ub₂+1} a₁ a₂": 1,
"decidable c": 2,
"has_div.{u} α": 1,
"has_monad_lift_t.{u u_1 v} n (option_t.{u v} m)": 1,
"has_mul.{u} α": 8,
"decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))": 1,
"Pi (a : α) (b : α), (subsingleton.{1} (decidable (eq.{u} (quotient.{u} α s) (quotient.mk.{u} α s a) (quotient.mk.{u} α s b))))": 1,
"decidable (eq.{1} name a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))": 1,
"decidable (eq.{1} name a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))": 1,
"has_seq_left.{u v} f": 1,
"decidable (eq.{1} bool (environment.is_recursive env I_name) bool.tt)": 1,
"decidable (not (eq.{1} (list.{0} char) (has_append.append.{0} (list.{0} char) (list.has_append.{0} char) (list.reverse.{0} char p₁) n₁) (has_append.append.{0} (list.{0} char) (list.has_append.{0} char) (list.reverse.{0} char p₂) n₂)))": 1,
"has_sub.{u} α": 7,
"ordered_comm_group.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"decidable (eq.{1} bool (environment.is_recursive env I_name) bool.tt)": 1,
"is_trans.{u} α lt": 1,
"has_le.{u} α": 2,
"has_append.{0} (list.{0} format)": 4,
"has_inv.{u} α": 1,
"has_add.{u} α": 5,
"monad.{u v} m": 35,
"has_le.{u} α": 2,
"decidable (eq.{1} name a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_dvd.{u} α": 3,
"has_bind.{u v} m": 1,
"decidable (eq.{1} bool rec bool.tt)": 2,
"decidable (and (not (eq.{1} bool at_star bool.tt)) (eq.{1} bool all_hyps bool.tt))": 1,
"decidable (eq.{1} (expr bool.tt) (cc_state.next s e) f)": 1,
"reflected.{1} (user_attribute name_set punit.{1}) (user_attribute.mk name_set punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.none.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (option.none.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (user_attribute_cache_cfg.mk name_set (fun (ns : list.{0} name), (has_pure.pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (applicative.to_has_pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_applicative.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state))) name_set (name_set.of_list ns))) (list.nil.{0} name)) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))": 1,
"decidable (eq.{1} bool (expr.is_local_constant e) bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_one.{u} α": 2,
"has_pure.{u v} f": 1,
"decidable (eq.{1} bool (option.is_none.{0} punit.{1} rec) bool.tt)": 1,
"decidable (eq.{1} bool (interactive.loc.include_goal l) bool.tt)": 1,
"has_sub.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"Pi (a : punit.{1}), (reflected.{1} punit.{1} a)": 10,
"reflected.{2} Type (tactic_state -> (interaction_monad.result.{0} tactic_state α))": 1,
"decidable (eq.{1} bool (expr.is_pi t_type) bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"decidable (not (eq.{1} name n (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"decidable (eq.{1} bool (expr.is_app e) bool.tt)": 1,
"has_sub.{u} α": 1,
"monad.{u_1 u_1} (fun (α : Type.{u_1}), (tactic_state -> (interaction_monad.result.{u_1} tactic_state α)))": 5,
"decidable (eq.{1} bool rec bool.tt)": 2,
"decidable (eq.{1} bool (expr.is_arrow t) bool.tt)": 1,
"has_add.{u} α": 1,
"division_ring.{u} α": 2,
"decidable (eq.{1} bool (expr.is_app lhs) bool.tt)": 1,
"has_one.{u} α": 6,
"has_seq_right.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))": 36,
"has_mul.{u} α": 2,
"alternative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))": 65,
"has_to_format.{0} (list.{0} param_info)": 1,
"has_bind.{u v} m": 1,
"has_pure.{u v} m": 2,
"has_le.{u} α": 3,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"has_mul.{u} α": 1,
"has_sizeof.{1} (list.{0} param_info)": 2,
"alternative.{u v} m": 2,
"decidable (eq.{1} bool (name_set.contains s r) bool.tt)": 1,
"decidable (eq.{1} bool dbg bool.tt)": 1,
"monad_reader.{u v} ρ m": 1,
"reflected.{1} nat (has_zero.zero.{0} nat nat.has_zero)": 1,
"add_comm_semigroup.{u} α": 35,
"has_coe_t.{1 1} (reflected.{2} Type (user_attribute name_set punit.{1})) (expr bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_neg.{u} α": 3,
"has_le.{u} α": 1,
"division_ring.{u} α": 4,
"has_neg.{u} α": 1,
"decidable (eq.{1} bool (expr.is_napp_of type (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (has_one.one.{0} nat nat.has_one)) bool.tt)": 1,
"decidable (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) (list.length.{0} nat ds))": 1,
"has_add.{u} α": 3,
"Pi (a : tactic.interactive.rw_rules_t), (reflected.{1} tactic.interactive.rw_rules_t a)": 8,
"decidable (eq.{1} bool (format.is_nil f₂) bool.tt)": 1,
"has_coe_t.{1 1} (option.{0} (prod.{0 0} (expr bool.tt) (expr bool.tt))) (tactic_state -> (interaction_monad.result.{0} tactic_state (prod.{0 0} (expr bool.tt) (expr bool.tt))))": 10,
"distrib.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"decidable p": 2,
"decidable (eq.{1} nat (list.length.{0} (expr bool.tt) args) arity)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"linear_order.{u} α": 2,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"decidable (not (eq.{1} bool found bool.tt))": 1,
"has_zero.{u} α": 1,
"has_coe_t.{1 1} (option.{0} name) (tactic_state -> (interaction_monad.result.{0} tactic_state name))": 1,
"is_incomp_trans.{u} α (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))))": 1,
"comm_semiring.{u} α": 2,
"has_zero.{u} α": 1,
"division_ring.{u} α": 2,
"monad.{0 0} option.{0}": 23,
"has_add.{u} α": 24,
"has_div.{u} α": 1,
"has_to_format.{0} key": 1,
"decidable_linear_ordered_comm_group.{u} α": 5,
"monad_functor_t.{u u_1 v} n n' m m'": 1,
"has_dvd.{u} α": 1,
"functor.{u_1 u_1} (fun (α : Type.{u_1}), (tactic_state -> (interaction_monad.result.{u_1} tactic_state α)))": 1,
"has_to_pexpr.{1} (expr bool.tt)": 33,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"Pi (a : option.{0} name), (reflected.{1} (option.{0} name) a)": 14,
"linear_ordered_field.{u} α": 4,
"has_monad_lift_t.{0 0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) smt_tactic": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))": 1,
"has_monad_lift_t.{u v v} m n": 1,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"has_to_pexpr.{1} (expr bool.ff)": 17,
"decidable (eq.{1} bool d bool.tt)": 1,
"decidable (eq.{1} bool (tactic.apply_cfg.auto_param cfg) bool.tt)": 1,
"decidable (eq.{1} bool (expr.is_napp_of t (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (has_one.one.{0} nat nat.has_one)) bool.tt)": 1,
"has_div.{u} α": 1,
"has_mul.{u} α": 2,
"decidable (eq.{1} bool (tactic.apply_cfg.opt_param cfg) bool.tt)": 1,
"decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_lt.{u} α": 5,
"decidable (not (eq.{1} bool (expr.alpha_eqv new_e e) bool.tt))": 1,
"add_group.{u} α": 24,
"has_monad_lift_t.{u u_1 v} n m": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"reflected.{2} Type name": 1,
"discrete_field.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"decidable (eq.{1} name a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"decidable (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero))": 1,
"has_sizeof.{u+1} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_mem.{0 0} (expr bool.tt) (list.{0} (expr bool.tt))": 1,
"has_div.{u} α": 3,
"decidable (eq.{1} bool (tactic.is_trace_enabled_for n) bool.tt)": 1,
"has_mul.{u} α": 1,
"decidable p": 2,
"mul_zero_class.{u} α": 1,
"has_dvd.{u} α": 1,
"reflected.{2} Type derive_handler": 1,
"linear_ordered_field.{u} α": 2,
"decidable (eq.{1} bool progress bool.tt)": 1,
"decidable (eq.{1} nat ng (has_zero.zero.{0} nat nat.has_zero))": 1,
"decidable (eq.{1} bool (expr.is_app lhs) bool.tt)": 1,
"has_neg.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_append.{0} (list.{0} (expr bool.tt))": 17,
"has_sub.{u} α": 3,
"add_monoid.{u} α": 2,
"is_lawful_monad.{u v} m _inst_1": 4,
"has_one.{u} α": 2,
"decidable (eq.{1} (expr bool.tt) t (lift_t.{1 1} (reflected.{2} Type Prop) (expr bool.tt) (coe_to_lift.{1 1} (reflected.{2} Type Prop) (expr bool.tt) (coe_base.{1 1} (reflected.{2} Type Prop) (expr bool.tt) (expr.has_coe.{2} Type Prop))) `(Prop)))": 1,
"has_orelse.{u v} m": 1,
"ordered_semiring.{u} α": 2,
"has_coe_t.{1 1} (reflected.{2} Type Prop) (expr bool.tt)": 1,
"reflected.{2} Type Prop": 1,
"has_bind.{u v} m": 7,
"has_dvd.{u} α": 2,
"has_lt.{u} α": 2,
"decidable (not (eq.{1} bool found bool.tt))": 1,
"has_sizeof.{1} tactic.new_goals": 2,
"group.{u} α": 2,
"has_le.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"monad.{u v} m": 3,
"subsingleton.{1} (decidable c)": 1,
"ordered_comm_group.{u} α": 2,
"has_to_tactic_format.{0} format": 4,
"has_coe_t.{1 1} name (option.{0} name)": 4,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_to_tactic_format.{u} α": 1,
"monad.{0 0} exceptional": 8,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_to_tactic_format.{u} α": 1,
"reflected.{1} (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state punit.{1})) (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1})": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_to_format.{0} (list.{0} format)": 1,
"has_add.{u} α": 4,
"decidable (not (eq.{1} bool (expr.alpha_eqv new_e e) bool.tt))": 1,
"applicative.{u v} m": 1,
"monad.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))": 486,
"has_neg.{u} α": 1,
"decidable (eq.{1} bool (expr.has_meta_var proof) bool.tt)": 1,
"has_coe_to_sort.{u v} a": 2,
"has_to_string.{0} format": 2,
"is_lawful_functor.{u v} m (applicative.to_functor.{u v} m (monad.to_applicative.{u v} m _inst_1))": 1,
"has_pure.{u v} m": 1,
"has_to_format.{0} tactic_state": 3,
"monad_functor_t.{u u_1 v} n n' (except_t.{u v} ε m) (except_t.{u v} ε m')": 1,
"has_to_format.{v} β": 1,
"has_add.{u} α": 3,
"reflected.{1} punit.{1} punit.star.{1}": 1,
"has_to_pexpr.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"reflected.{1} (name -> name) (name.mk_numeral i)": 1,
"add_monoid.{u} α": 1,
"division_ring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_mem.{0 0} nat (list.{0} nat)": 3,
"reflected.{1} nat (has_one.one.{0} nat nat.has_one)": 1,
"decidable (iff (eq.{1} bool (bor bool.tt bool.ff) bool.tt) (or (eq.{1} bool bool.tt bool.tt) (eq.{1} bool bool.ff bool.tt)))": 1,
"monad_reader_adapter.{u v} ρ ρ' m m'": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"add_comm_semigroup.{0} nat": 266,
"has_neg.{u} α": 1,
"decidable (eq.{1} bool (list.empty.{0} format f₁) bool.tt)": 1,
"has_sizeof.{1} bool": 90,
"has_neg.{u} α": 3,
"has_div.{u} α": 10,
"subsingleton.{1} (decidable c)": 1,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)": 1,
"decidable (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero))": 1,
"has_lt.{0} (expr bool.tt)": 2,
"has_to_format.{0} (list.{0} level)": 1,
"has_sizeof.{u+1} α": 1,
"has_le.{u} α": 3,
"decidable p": 3,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"has_le.{u} α": 3,
"has_div.{u} α": 1,
"has_to_format.{0} level": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"group.{u} α": 4,
"decidable (not (eq.{1} nat (has_one.one.{0} nat nat.has_one) (has_zero.zero.{0} nat nat.has_zero)))": 1,
"division_ring.{u} α": 2,
"has_one.{u} α": 1,
"has_bind.{u v} m": 1,
"monad_run.{u_1 u_2} out m": 1,
"reflected.{1} ((list.{0} tactic.interactive.rw_rule) -> (option.{0} pos) -> tactic.interactive.rw_rules_t) tactic.interactive.rw_rules_t.mk": 1,
"has_dvd.{u} α": 1,
"monad.{u v} m": 1,
"has_lt.{u} (list.{u} α)": 1,
"has_mul.{u} α": 2,
"monad_functor_t.{u v v} m m' n n'": 1,
"has_add.{u} α": 1,
"has_coe.{u v} a b": 1,
"decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"preorder.{u} α": 2,
"monad_state.{u v} σ m": 1,
"Pi (a : α) (b : α), (decidable (eq.{u+1} α a b))": 1,
"has_le.{u} α": 1,
"monad_state.{u v} σ m": 1,
"group.{u} α": 2,
"has_add.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_monad_lift_t.{u v w} m n": 1,
"has_lift.{u v} a b": 1,
"ring.{u} α": 1,
"has_repr.{u} (list.{u} α)": 1,
"monad_state.{u v} σ m": 1,
"monad_except.{u_1 u v} ε m": 2,
"discrete_field.{u} α": 4,
"has_add.{u} α": 1,
"monad.{u v} m": 1,
"has_pure.{u v} m": 1,
"has_pure.{0 v} f": 1,
"monad_run.{u u_1} out m": 1,
"division_ring.{u} α": 4,
"division_ring.{u} α": 2,
"monad.{u v} m": 1,
"decidable (eq.{1} bool (expr.is_local_constant e) bool.tt)": 1,
"has_add.{u} α": 1,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)": 1,
"monad_functor_t.{u v v} m m' n n'": 1,
"has_add.{u} α": 1,
"has_div.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_mul.{u} α": 3,
"has_mul.{u} α": 2,
"has_pure.{u v} m": 1,
"is_trichotomous.{u} α lt": 1,
"has_lt.{u} α": 1,
"has_le.{u} α": 3,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"monoid.{u} α": 1,
"has_zero.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))": 1,
"functor.{0 0} smt_tactic": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (monoid.to_semigroup.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one))) (inv a) a) (has_one.one.{u} α (monoid.to_has_one.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one)))))": 1,
"division_ring.{u} α": 5,
"has_le.{u} α": 1,
"decidable (not (eq.{1} bool (_private.1110872373.uses_hyp e hyp) bool.tt))": 1,
"has_pure.{u v} m": 1,
"has_pure.{u v} m": 1,
"has_bind.{u v} m": 1,
"applicative.{u v} m": 1,
"has_mul.{u} α": 2,
"has_le.{u} α": 2,
"has_to_format.{0} α": 1,
"comm_semigroup.{u} α": 2,
"has_monad_lift_t.{u v w} m n": 1,
"add_comm_semigroup.{u} α": 2,
"monad.{u v} m'": 1,
"has_sizeof.{v+1} (m ρ)": 2,
"has_zero.{u} α": 1,
"has_mul.{u} α": 2,
"has_add.{u} α": 2,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) b c)": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))": 1,
"monad_except.{u_1 u v} ε m": 2,
"decidable (eq.{1} (list.{0} (expr bool.tt)) (list.bag_inter.{0} (expr bool.tt) expr.has_decidable_eq (_private.4211256083.collect_add_args lhs) (_private.4211256083.collect_add_args rhs)) (list.nil.{0} (expr bool.tt)))": 1,
"has_div.{u} α": 2,
"decidable c": 1,
"has_mem.{u u} α (list.{u} α)": 2,
"has_sizeof.{u+1} (α -> α)": 2,
"decidable p": 2,
"monad.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"decidable (and (eq.{1} bool (declaration.is_trusted decl) bool.tt) (eq.{1} bool (declaration.is_trusted cls_decl) bool.tt))": 1,
"has_sub.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 1,
"has_add.{u} α": 1,
"has_add.{u} α": 7,
"functor.{u v} f": 1,
"Pi (a : name) (b : name), (decidable (has_lt.lt.{0} name name.has_lt a b))": 1,
"decidable p": 1,
"has_mul.{u} α": 3,
"is_lawful_monad.{u v} m _inst_1": 3,
"preorder.{u} α": 2,
"decidable (eq.{1} bool (name_set.contains input_hyp_uids (expr.local_uniq_name h)) bool.tt)": 1,
"decidable (eq.{1} name c p)": 1,
"preorder.{u} α": 4,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"decidable (iff (eq.{1} bool (bxor bool.ff bool.ff) bool.tt) (xor (eq.{1} bool bool.ff bool.tt) (eq.{1} bool bool.ff bool.tt)))": 1,
"has_le.{u} α": 6,
"decidable (eq.{1} bool use_first_ex bool.tt)": 1,
"has_mul.{u} α": 2,
"is_irrefl.{u} α r": 1,
"decidable (eq.{1} bool (expr.is_app_of e n) bool.tt)": 1,
"has_orelse.{u v} f": 1,
"preorder.{u} α": 1,
"has_mul.{u} α": 3,
"decidable_linear_order.{u} α": 3,
"has_coe_t.{1 1} (exceptional declaration) (tactic_state -> (interaction_monad.result.{0} tactic_state declaration))": 9,
"reflected.{1} tactic.simp_arg_type tactic.simp_arg_type.all_hyps": 1,
"monad_state_adapter.{u v} σ σ' m m'": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"ordered_comm_group.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"decidable (eq.{1} bool p bool.tt)": 1,
"has_to_format.{v} β": 1,
"has_add.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_inv.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))": 1,
"has_to_format.{u} α": 1,
"Pi (a : expr bool.tt), (decidable (not (eq.{1} (expr bool.tt) a g)))": 2,
"decidable_linear_order.{u} α": 2,
"monad.{u v} m": 3,
"has_add.{u} α": 2,
"has_to_format.{0} string": 193,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_lt.{u} α": 4,
"linear_ordered_ring.{u} α": 1,
"reflected.{1} unsigned (unsigned.of_nat' n)": 1,
"is_total.{u} α le": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_to_string.{0} key": 1,
"has_one.{u} α": 1,
"has_div.{u} α": 3,
"mul_zero_class.{u} α": 1,
"has_bind.{u (max u v)} (state_t.{u v} σ m)": 1,
"is_total.{u} α r": 1,
"has_repr.{0} unsigned": 2,
"has_sizeof.{(imax u v)} (a -> b)": 2,
"has_to_string.{u} α": 2,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"add_group.{u} α": 3,
"is_total.{u} α r": 1,
"reflected.{1} ((expr bool.ff) -> tactic.simp_arg_type) tactic.simp_arg_type.expr": 1,
"has_sub.{u} α": 7,
"has_zero.{u} α": 1,
"has_to_string.{v} (β a)": 1,
"has_to_string.{v} β": 1,
"has_mul.{u} α": 3,
"decidable (p a)": 1,
"has_neg.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))": 1,
"preorder.{u} α": 10,
"reflected.{1} Prop false": 1,
"has_to_string.{u} α": 1,
"has_add.{u} α": 2,
"has_neg.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))": 1,
"has_pure.{u (max u v)} (reader_t.{u v} ρ m)": 1,
"has_to_string.{0} nat": 2,
"has_zero.{u} α": 1,
"has_to_string.{u} α": 1,
"Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))": 1,
"has_one.{u} α": 1,
"Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α _inst_1 a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_to_string.{0} (list.{0} (list.{0} name))": 1,
"has_zero.{u} α": 1,
"decidable (eq.{1} name a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_lt.{u} α": 3,
"decidable (lt a b)": 1,
"decidable (not (or (eq.{1} bool (expr.is_pi t) bool.tt) (eq.{1} bool (expr.is_let t) bool.tt)))": 1,
"linear_ordered_semiring.{u} α": 4,
"decidable (and (eq.{u+1} α (prod.fst.{u v} α β t) (prod.fst.{u v} α β s)) (has_lt.lt.{v} β _inst_2 (prod.snd.{u v} α β t) (prod.snd.{u v} α β s)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"reflected.{2} Type simp_lemmas": 1,
"Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))": 1,
"add_group.{u} α": 1,
"has_lt.{u} α": 5,
"decidable (or (has_le.le.{0} nat nat.has_le (char.to_nat c) (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))) (eq.{1} char c (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))": 1,
"add_comm_semigroup.{u} α": 54,
"decidable (eq.{1} bool b bool.tt)": 1,
"decidable (eq.{1} nat n (has_one.one.{0} nat nat.has_one))": 1,
"has_sub.{u} α": 2,
"decidable (eq.{1} char c (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))": 1,
"decidable (eq.{1} char c (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))": 1,
"reflected.{2} Type (list.{0} (expr bool.ff))": 1,
"has_div.{u} α": 7,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"decidable (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero))": 1,
"has_pure.{u v} m": 1,
"has_lt.{u} α": 2,
"has_add.{u} α": 2,
"has_neg.{u} α": 3,
"has_to_format.{0} nat": 2,
"group.{u} α": 6,
"Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))": 1,
"has_one.{u} α": 2,
"decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))": 1,
"has_sizeof.{u+1} α": 4,
"is_irrefl.{u} α lt": 1,
"has_le.{u} α": 2,
"decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_zero.{u} α": 3,
"has_lt.{u} α": 4,
"reflected.{2} Type (user_attribute name_set punit.{1})": 1,
"monad.{0 0} (state_t.{0 0} smt_state (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))))": 1,
"has_lt.{u} α": 1,
"has_one.{u} α": 5,
"has_mul.{u} α": 2,
"has_add.{u} α": 1,
"has_lt.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α (discrete_linear_ordered_field.to_discrete_field.{u} α _inst_1) (discrete_linear_ordered_field.to_discrete_field.{u} α _inst_1))))))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"linear_ordered_field.{u} α": 2,
"has_repr.{u} α": 1,
"has_pure.{u v} m": 1,
"has_lt.{0} key": 2,
"has_dvd.{u} α": 1,
"is_antisymm.{u} α r": 1,
"monad.{u v} m": 2,
"has_le.{u} α": 2,
"decidable p": 1,
"decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_le.{u} α": 2,
"ordered_ring.{u} α": 1,
"has_repr.{v} β": 1,
"has_sizeof.{u+1} (α -> α)": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_le.{u} α": 7,
"has_pure.{u v} m": 1,
"has_neg.{u} α": 2,
"reflected.{1} (nat -> nat -> pos) pos.mk": 1,
"ordered_comm_group.{u} α": 2,
"has_lt.{0} name": 1,
"ordered_semiring.{u} α": 2,
"monoid.{u} α": 2,
"Pi (a : α), (has_sizeof.{v+1} (β a))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_zero.{u} α": 4,
"has_mul.{u} α": 2,
"decidable (eq.{1} bool (interactive.loc.include_goal l) bool.tt)": 1,
"has_sizeof.{(imax u v)} (a -> b)": 2,
"has_neg.{u} α": 1,
"has_lift_t.{u+1 v+1} a b": 1,
"ring.{u} α": 2,
"has_sub.{u} α": 9,
"is_incomp_trans.{u} α r": 1,
"decidable_linear_order.{u} α": 2,
"Pi (a : α) (b : α), (decidable (eq.{u_1+1} α a b))": 1,
"has_div.{u} α": 5,
"decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))": 1,
"subsingleton.{v} (β (quot.mk.{u} α r b))": 1,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"add_monoid.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (has_lt.lt.{0} nat nat.has_lt val n)": 1,
"has_to_format.{v} β": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"decidable (eq.{1} nat (string.length s) (has_zero.zero.{0} nat nat.has_zero))": 1,
"has_lt.{u} α": 3,
"preorder.{u} α": 2,
"has_one.{0} nat": 19324,
"subsingleton.{1} (decidable c)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"is_irrefl.{u} α lt": 2,
"setoid.{u} α": 2,
"has_coe_t_aux.{u₁ u₂} a b": 2,
"distrib.{u} α": 1,
"has_coe.{u₁ u₂} a b": 1,
"decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))": 1,
"has_coe_t.{u₂ u₃} b c": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{(max (u+1) v)+1} (has_seq.{u v} f)": 2,
"has_div.{u} α": 2,
"has_lift_t.{ua₂ ua₁} a₂ a₁": 1,
"has_lt.{u} α": 1,
"has_lt.{0} key": 1,
"has_coe.{u₁ u₂} a b": 1,
"has_neg.{u} α": 8,
"has_sizeof.{(max ((u+1)+1) (max ((u+1)+1) (v+1)) (w+1))} (Pi {α : Type.{u}} (a : Pi {α : Type.{u}} (a : m α), (m' α)) (a : n α), (n' α))": 2,
"has_bind.{u v} m": 1,
"has_neg.{u} α": 3,
"has_add.{u} α": 1,
"decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_repr.{u} α": 1,
"decidable (eq.{1} bool (cc_state.inconsistent s) bool.tt)": 1,
"decidable (le b c)": 1,
"has_coe_t.{u v} a b": 1,
"has_mul.{u} α": 2,
"decidable (eq.{1} name a_a_a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"mul_zero_class.{u} α": 1,
"monoid.{u} α": 1,
"add_group.{u} α": 1,
"linear_ordered_field.{u} α": 2,
"decidable (eq.{1} bool (environment.contains env (mk_str_name (expr.const_name bool.tt (expr.get_app_fn bool.tt lhs)) (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))) bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_mul.{u} α": 2,
"has_to_string.{u} α": 1,
"has_sub.{u} α": 5,
"has_add.{0} nat": 19354,
"has_lt.{u} α": 2,
"decidable (eq.{1} name a_a_3_a (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"add_monoid.{u} α": 1,
"decidable (eq.{1} nat (prod.snd.{0 0} (expr bool.tt) nat p) (has_one.one.{0} nat nat.has_one))": 1,
"reflected.{2} Type (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))": 1,
"has_to_format.{0} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"decidable (le b a)": 1,
"has_bind.{u u} m": 1,
"decidable (eq.{1} bool zeta_reduce bool.tt)": 2,
"has_sizeof.{(max ((u+1)+1) (v+1))} (Pi {α : Type.{u}} {β : Type.{u}} (a : f (α -> β)) (a : f α), (f β))": 2,
"decidable (eq.{1} bool (_private.2952678747.is_next_explicit ps) bool.tt)": 1,
"has_sizeof.{1} (list.{0} nat)": 8,
"preorder.{u} α": 1,
"reflected.{1} (user_attribute simp_lemmas punit.{1}) (user_attribute.mk simp_lemmas punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.none.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (option.none.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (user_attribute_cache_cfg.mk simp_lemmas (fun (ns : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) simp_lemmas simp_lemmas (tactic.to_simp_lemmas simp_lemmas.mk ns) (fun (s : simp_lemmas), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) simp_lemmas simp_lemmas (list.mfoldl.{0 0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state) simp_lemmas name (fun (s : simp_lemmas) (attr_name : name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (list.{0} name) simp_lemmas (attribute.get_instances attr_name) (tactic.to_simp_lemmas s))) s attr_deps) (has_pure.pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (applicative.to_has_pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_applicative.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state))) simp_lemmas))))) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) attr_deps)) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))": 1,
"decidable (eq.{1} name a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))": 1,
"has_inv.{u} α": 1,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {σ'' : Type.{u}} {α : Type.{u}} (split : σ' -> (prod.{u u} σ σ'')) (join : σ -> σ'' -> σ') (a : m α), (m' α))": 2,
"decidable (eq.{1} bool (expr.is_napp_of e op (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))) bool.tt)": 1,
"has_to_format.{u} α": 1,
"has_bind.{0 u} m": 1,
"has_pure.{u_1 u_2} m": 1,
"has_to_tactic_format.{0} cc_state": 1,
"has_le.{u} α": 3,
"distrib.{u} α": 1,
"has_div.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{(imax u v)} (Pi (x : a), (F x))": 1,
"add_monoid.{u} α": 1,
"linear_ordered_field.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_le.{u} α": 1,
"has_div.{u} α": 3,
"applicative.{u v} m": 3,
"has_append.{0} (list.{0} char)": 38,
"is_lawful_functor.{u v} m (applicative.to_functor.{u v} m (monad.to_applicative.{u v} m _inst_1))": 1,
"has_to_string.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_coe.{u v} a b": 1,
"group.{u} α": 4,
"add_comm_semigroup.{u} α": 21,
"has_mul.{u} α": 1,
"has_sizeof.{(imax u v)} (a -> b)": 2,
"decidable (eq.{1} bool univ_poly bool.tt)": 2,
"has_le.{u} α": 2,
"monad.{u v} m": 1,
"decidable (eq.{1} bool (expr.is_napp_of a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))) bool.tt)": 1,
"has_zero.{u} α": 2,
"has_lt.{u} α": 1,
"ordered_semiring.{u} α": 1,
"has_lt.{u} α": 1,
"has_le.{u} α": 5,
"has_le.{u} α": 7,
"preorder.{u} α": 3,
"monad_functor_t.{u_1 u_2 u_3} m m' n n'": 1,
"group.{u} α": 2,
"has_zero.{u} α": 3,
"has_div.{u} α": 8,
"preorder.{u} α": 2,
"has_le.{u} (list.{u} α)": 1,
"is_lawful_monad.{u v} m _inst_1": 1,
"has_sizeof.{(max (u+1) (v+1))} (σ -> (m (prod.{u u} α σ)))": 2,
"has_ssubset.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"decidable (not (eq.{1} nat (list.length.{0} (expr bool.tt) (expr.get_app_args lhs)) (list.length.{0} (expr bool.tt) (expr.get_app_args rhs))))": 1,
"has_coe_to_fun.{u v} a": 2,
"division_ring.{u} α": 4,
"add_group.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))": 1,
"has_lt.{u} α": 1,
"has_mul.{u} α": 3,
"has_to_format.{0} key": 1,
"has_add.{u} α": 7,
"decidable (eq.{1} nat (has_add.add.{0} nat nat.has_add d (has_one.one.{0} nat nat.has_one)) base)": 1,
"has_sizeof.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_inv.{u} α": 1,
"linear_ordered_field.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))": 1,
"add_group.{u} α": 3,
"mul_zero_class.{u} α": 2,
"has_lt.{0} key": 1,
"decidable (has_le.le.{0} nat nat.has_le n (has_one.one.{0} nat nat.has_one))": 1,
"add_group.{u} α": 5,
"linear_ordered_field.{u} α": 2,
"reflected.{1} interactive.loc interactive.loc.wildcard": 1,
"ordered_cancel_comm_monoid.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"monad.{u v} m": 1,
"has_lt.{u} α": 2,
"mul_zero_class.{u} α": 2,
"has_neg.{u} α": 3,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)": 1,
"linear_order.{u} α": 1,
"Pi (a : option.{0} nat), (reflected.{1} (option.{0} nat) a)": 1,
"add_group.{u} α": 2,
"has_zero.{u} α": 1,
"decidable_linear_ordered_comm_group.{u} α": 1,
"decidable (not (eq.{1} bool (environment.is_inductive env I) bool.tt))": 1,
"decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) y) (has_le.le.{0} nat nat.has_le y x))": 1,
"Pi (a : α) (b : α), (decidable (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"decidable (eq.{1} nat x (has_zero.zero.{0} nat nat.has_zero))": 1,
"has_bind.{u_1 u_1} (fun (α : Type.{u_1}), (tactic_state -> (interaction_monad.result.{u_1} tactic_state α)))": 13,
"has_mul.{u} α": 1,
"division_ring.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{(max u (v+1))} (a -> Sort.{v})": 2,
"decidable (has_mem.mem.{u u} α (list.{u} α) (list.has_mem.{u} α) a l)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_mem.{u u} α (list.{u} α)": 1,
"partial_order.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"is_commutative.{u} α op": 1,
"has_sizeof.{v+1} Sort.{v}": 2,
"decidable (and (not (eq.{1} bool b₁ bool.tt)) (not (eq.{1} bool b₂ bool.tt)))": 1,
"decidable (and (eq.{1} bool (expr.is_app_of e c) bool.tt) (eq.{1} nat (expr.get_app_num_args e) n))": 1,
"add_group.{u} α": 4,
"add_monoid.{u} α": 1,
"semigroup.{u} α": 2,
"preorder.{u} α": 1,
"has_equiv.{u_b} β": 1,
"has_seq.{u (max u v)} (reader_t.{u v} ρ m)": 1,
"linear_order.{0} int": 4,
"inhabited.{u+1} α": 1,
"has_sizeof.{(max (u+1) v)+1} (functor.{u v} f)": 2,
"has_sizeof.{(max (u+1) (v+1))} (ρ -> (m α))": 2,
"comm_semiring.{u} α": 2,
"has_seq.{u v} f": 3,
"monad.{0 u} m": 1,
"has_add.{u} α": 2,
"has_add.{u} α": 24,
"has_bind.{0 0} m": 1,
"decidable p": 1,
"has_bind.{u v} m": 1,
"has_pure.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_repr.{u} α": 1,
"partial_order.{u} α": 1,
"has_append.{u} (list.{u} α)": 1,
"decidable (eq.{1} nat (list.length.{0} name (environment.constructors_of env I)) (has_zero.zero.{0} nat nat.has_zero))": 1,
"has_add.{u} α": 1,
"monad_state.{0 0} smt_state (state_t.{0 0} smt_state (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))))": 1,
"has_sizeof.{u+1} α": 1,
"has_add.{u} α": 6,
"is_symm.{u} α r": 2,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"has_le.{u} α": 4,
"discrete_field.{u} α": 1,
"decidable (Exists.{u} α p)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_pure.{u_1 u_1} option.{u_1}": 1,
"division_ring.{u} α": 2,
"has_mul.{0} nat": 209,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))": 1,
"subsingleton.{1} (decidable c)": 1,
"division_ring.{u} α": 3,
"has_zero.{u} α": 2,
"has_lt.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"has_append.{0} (list.{0} (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})))": 1,
"linear_order.{u} α": 2,
"has_sizeof.{1} (list.{0} char)": 6,
"decidable (eq.{1} bool (expr.is_constant bool.tt I) bool.tt)": 1,
"has_equiv.{u} α": 1,
"decidable (and (has_le.le.{0} nat nat.has_le (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))) (char.val c)) (has_le.le.{0} nat nat.has_le (char.val c) (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_one.{u} α": 7,
"has_lt.{u} α": 2,
"has_sizeof.{u} α": 2,
"has_zero.{u} α": 3,
"ordered_semiring.{u} α": 1,
"functor.{u v} m": 1,
"has_append.{0} string": 88,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"comm_semiring.{u} α": 2,
"has_mem.{u u} α (list.{u} α)": 1,
"has_zero.{u} α": 1,
"has_to_format.{u} α": 1,
"has_lt.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_le.{u} α": 2,
"has_to_pexpr.{1} (reflected.{1} string acc)": 1,
"has_le.{u} α": 1,
"has_sub.{u} α": 1,
"has_add.{u} α": 1,
"has_to_tactic_format.{0} (expr bool.tt)": 11,
"has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} (a : ρ' -> ρ) (a : m α), (m' α))": 2,
"has_lift_t.{1 1} bool Prop": 3,
"has_add.{u} α": 4,
"has_to_string.{u} α": 1,
"has_add.{u} α": 1,
"setoid.{u} α": 3,
"has_zero.{u} α": 14,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))": 1,
"setoid.{u} α": 3,
"has_mul.{u} α": 2,
"comm_semigroup.{u} α": 30,
"setoid.{u} α": 14,
"decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))": 1,
"has_pure.{u v} m": 1,
"add_group.{u} α": 3,
"decidable q": 4,
"distrib.{u} α": 2,
"has_add.{u} α": 1,
"decidable (and (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt e)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))) (eq.{1} nat (expr.get_app_num_args e) (has_one.one.{0} nat nat.has_one)))": 1,
"monad_functor_t.{u u_1 v} n n' m m'": 1,
"has_div.{u} α": 1,
"add_comm_semigroup.{u} α": 1,
"has_equiv.{u} α": 1,
"decidable_linear_order.{u} α": 2,
"decidable c": 1,
"decidable (eq.{1} bool no_dflt bool.tt)": 1,
"has_equiv.{u} α": 1,
"add_monoid.{u} α": 1,
"decidable (eq.{1} bool (format.is_nil f₁) bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"decidable q": 1,
"monad.{u (max u v)} (state_t.{u v} σ m)": 6,
"decidable c": 1,
"decidable b": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"decidable (p a)": 1,
"has_sizeof.{u+1} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_mul.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"setoid.{u} α": 1,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"distrib.{u} α": 3,
"monad.{0 0} m": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_div.{u} α": 3,
"preorder.{u} α": 2,
"has_add.{u} α": 5,
"has_one.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{u+1} α": 1,
"has_coe_t.{1 1} (reflected.{1} β val) (expr bool.tt)": 1,
"decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))": 1,
"has_sizeof.{u+1} α": 4,
"decidable (eq.{1} bool (d_array.beq.{u} n α _inst_1 a b) bool.tt)": 1,
"Pi (a : α) (b : α), (decidable (eq.{u+1} α a b))": 1,
"decidable (has_mem.mem.{u_1 u_1} α (list.{u_1} α) (list.has_mem.{u_1} α) a l₁)": 1,
"has_pure.{u v} (option_t.{u v} m)": 1,
"has_sub.{u} α": 1,
"has_lt.{u} α": 8,
"monoid.{u} α": 1,
"has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} {β : Type.{u}} (a : α -> β) (a : f α), (f β))": 2,
"add_comm_group.{u} α": 2,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_lt.{u} α": 2,
"preorder.{u} α": 2,
"linear_order.{u} α": 1,
"decidable (eq.{1} name a_a_a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"is_irrefl.{u} α r": 1,
"reflected.{1} ((list.{0} α) -> (list.{0} α)) (list.cons.{0} α h)": 1,
"setoid.{u} α": 1,
"division_ring.{u} α": 2,
"decidable (p a)": 1,
"has_le.{u} α": 3,
"decidable c": 3,
"decidable (iff (eq.{1} bool (bor bool.ff bool.ff) bool.tt) (or (eq.{1} bool bool.ff bool.tt) (eq.{1} bool bool.ff bool.tt)))": 1,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_lt.{u} α": 1,
"add_group.{u} α": 1,
"has_inv.{u} α": 1,
"has_repr.{v} (β a)": 1,
"decidable p": 2,
"has_mul.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))) name.anonymous))": 1,
"has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))": 6465,
"alternative.{0 v} f": 1,
"decidable (eq.{1} bool (expr.alpha_eqv (cc_state.next s c) first) bool.tt)": 1,
"Pi (a : α) (b : α), (decidable (eq.{u+1} α a b))": 1,
"has_coe.{u v} a b": 1,
"setoid.{u} α": 2,
"has_mul.{u} α": 2,
"has_sizeof.{1} ematch_config": 2,
"has_neg.{u} α": 1,
"inhabited.{u} α": 1,
"has_pure.{u v} m": 1,
"distrib.{u} α": 1,
"has_neg.{u} α": 3,
"preorder.{u} α": 6,
"has_one.{u} α": 2,
"decidable p": 2,
"semigroup.{u} α": 2,
"has_mul.{u} α": 5,
"setoid.{u_b} β": 8,
"decidable (eq.{u+1} α a b)": 1,
"has_add.{u} α": 1,
"has_sizeof.{u+1} (bin_tree.{u} α)": 2,
"has_mul.{u} α": 3,
"decidable p": 1,
"ring.{u} α": 1,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_lt.{u} α": 1,
"has_add.{u} α": 2,
"add_monoid.{u} α": 1,
"comm_semigroup.{u} α": 4,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"decidable (not (eq.{1} bool (environment.contains env (mk_str_name base (has_append.append.{0} string string.has_append (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (repr.{0} nat nat.has_repr i)))) bool.tt))": 1,
"decidable p": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"decidable (eq.{1} bool (expr.is_napp_of t (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)) (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))) bool.tt)": 1,
"decidable p": 1,
"has_le.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{u+1} α": 1,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state bool)) (smt_tactic bool)": 1,
"has_zero.{u} α": 3,
"has_sizeof.{u+1} α": 1,
"has_div.{u} α": 2,
"decidable (eq.{1} bool m bool.tt)": 1,
"has_mul.{u} α": 1,
"has_coe_t_aux.{u₁ u₂} a b": 1,
"has_le.{0} int": 66,
"decidable q": 2,
"preorder.{u} α": 1,
"decidable p": 1,
"has_le.{u} α": 4,
"has_add.{u} α": 2,
"linear_ordered_field.{u} α": 1,
"has_add.{u} α": 1,
"has_sizeof.{u+1} α": 1,
"is_trichotomous.{u} α r": 1,
"has_zero.{u} α": 1,
"monad_state.{0 0} smt_state smt_tactic": 2,
"ordered_semiring.{u} α": 2,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"decidable_linear_order.{u} α": 3,
"decidable (eq.{1} bool (p x y) bool.tt)": 1,
"monad.{0 0} m": 1,
"has_pure.{u v} m": 1,
"has_mul.{u} α": 2,
"monoid.{u} α": 1,
"decidable (eq.{1} bool (option.is_some.{0} environment.projection_info (environment.is_projection env n)) bool.tt)": 1,
"decidable_linear_ordered_comm_group.{u} α": 2,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"decidable (eq.{1} bool (expr.is_app t) bool.tt)": 1,
"decidable p": 1,
"functor.{u (max u v)} (reader_t.{u v} ρ m)": 1,
"decidable q": 1,
"discrete_field.{u} α": 2,
"has_sizeof.{u+1} α": 4,
"has_sizeof.{u+1} α": 2,
"has_lt.{u} α": 1,
"has_div.{u} α": 3,
"decidable (eq.{1} bool (expr.alpha_eqv t e) bool.tt)": 1,
"decidable p": 1,
"division_ring.{u} α": 1,
"add_semigroup.{u} α": 1,
"has_lt.{u} α": 1,
"ordered_ring.{u} α": 2,
"setoid.{u} α": 1,
"decidable c": 1,
"has_coe_t.{1 1} (reflected.{2} Type (user_attribute hinst_lemmas punit.{1})) (expr bool.tt)": 3,
"linear_order.{u} α": 2,
"linear_order.{0} nat": 25,
"has_add.{u} α": 2,
"comm_semigroup.{0} int": 1,
"reflected.{1} nat _p.2": 1,
"has_sub.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_equiv.{u} α": 2,
"add_group.{u} α": 25,
"decidable c": 1,
"has_sub.{u} α": 1,
"monad_except.{u v w} ε m": 1,
"inhabited.{1} char": 1,
"decidable c": 1,
"add_group.{u} α": 4,
"decidable c": 2,
"field.{u} α": 4,
"decidable (eq.{1} bool (tactic.apply_cfg.opt_param cfg) bool.tt)": 1,
"has_sizeof.{u+1} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_lt.{u} (list.{u} α)": 2,
"subsingleton.{1} (decidable (eq.{1} (fin n) i j))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"functor.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))": 25,
"has_orelse.{0 0} smt_tactic": 11,
"has_sizeof.{(max ((v+1)+1) (u+1) (w+1))} (Pi {α : Type.{v}} (a : m α) (a : ε -> (m α)), (m α))": 2,
"preorder.{u} α": 8,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))": 1,
"monad_run.{u_1 u_2} out m": 1,
"decidable (eq.{1} bool (option.is_none.{0} punit.{1} rec) bool.tt)": 1,
"alternative.{u v} m": 1,
"has_mem.{u u} α (list.{u} α)": 1,
"has_repr.{v} β": 1,
"decidable (eq.{1} bool (environment.is_inductive env n) bool.tt)": 1,
"has_le.{u} α": 6,
"has_one.{u} α": 1,
"decidable (eq.{1} name (expr.local_uniq_name h) (expr.local_uniq_name hi))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_sizeof.{u} α": 2,
"decidable_linear_order.{u} α": 3,
"preorder.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_zero.{u} α": 1,
"has_mul.{u} α": 2,
"has_lt.{v} β": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_zero.{u} α": 4,
"add_group.{u} α": 7,
"has_append.{v} (list.{v} β)": 1,
"is_symm.{u} α r": 1,
"inhabited.{v+1} β": 1,
"setoid.{u} α": 1,
"partial_order.{u} α": 2,
"monoid.{u} α": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))": 1,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"has_repr.{u} α": 2,
"decidable q": 1,
"has_add.{u} α": 2,
"has_neg.{u} α": 2,
"has_one.{u} α": 6,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"decidable_linear_order.{u} α": 1,
"partial_order.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"decidable b": 1,
"has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} (a : state_t.{u u} σ (id.{(u+1)+1} Type.{u}) α), (m α))": 2,
"preorder.{u} α": 8,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_add.{u} α": 1,
"has_mul.{u} α": 1,
"has_insert.{u v} α γ": 1,
"has_lt.{u} α": 2,
"has_mul.{u} α": 2,
"has_le.{u} α": 1,
"decidable (and (eq.{1} bool all_hyps bool.tt) (and (eq.{1} bool at_star bool.tt) (not (eq.{1} bool (list.empty.{0} name hex) bool.tt))))": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_equiv.{u} α": 1,
"Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))": 1,
"has_one.{u} α": 1,
"Pi (a : bool), (reflected.{1} bool a)": 8,
"Pi (a : list.{0} nat), (reflected.{1} (list.{0} nat) a)": 1,
"has_sizeof.{u+1} α": 1,
"has_le.{u} α": 3,
"has_sizeof.{u} α": 1,
"has_zero.{u} α": 1,
"has_sizeof.{v+1} β": 1,
"decidable_linear_order.{u} α": 2,
"has_neg.{u} α": 2,
"monoid.{u} α": 1,
"Pi (a_1 : α), (decidable (eq.{u+1} α a a_1))": 1,
"decidable (not (eq.{1} bool (expr.is_app e) bool.tt))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"preorder.{u} α": 4,
"has_coe_t.{1 1} (reflected.{1} (user_attribute name_set punit.{1}) (user_attribute.mk name_set punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.none.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (option.none.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (user_attribute_cache_cfg.mk name_set (fun (ns : list.{0} name), (has_pure.pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (applicative.to_has_pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_applicative.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state))) name_set (name_set.of_list ns))) (list.nil.{0} name)) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))) (expr bool.tt)": 1,
"decidable c": 1,
"has_sizeof.{v+1} (m (except.{u u} ε α))": 2,
"is_trichotomous.{u} α r": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"applicative.{u_1 u_1} option.{u_1}": 6,
"has_sizeof.{(max ((u+1)+1) (max ((u+1)+1) (v+1)) (w+1))} (Pi {α : Type.{u}} (a : Pi {α : Type.{u}} (a : m α), (m' α)) (a : n α), (n' α))": 2,
"linear_ordered_semiring.{u} α": 4,
"decidable (eq.{1} nat n (has_one.one.{0} nat nat.has_one))": 1,
"ordered_comm_group.{u} α": 1,
"has_to_string.{0} α": 1,
"decidable (and (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt e)) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))) name.anonymous)) (eq.{1} nat (expr.get_app_num_args e) (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))": 1,
"has_seq.{u_1 u_1} option.{u_1}": 1,
"has_lt.{0} string": 2,
"decidable (has_le.le.{0} nat (preorder.to_has_le.{0} nat (partial_order.to_preorder.{0} nat (linear_order.to_partial_order.{0} nat (linear_order.mk.{0} nat (decidable_linear_order.le.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.lt.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_refl.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_trans.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.lt_iff_le_not_le.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_antisymm.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)) (decidable_linear_order.le_total.{0} nat (decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)))))) (nat.succ x) (nat.succ y))": 2,
"division_ring.{u} α": 5,
"has_inv.{u} α": 1,
"setoid.{u} α": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"reflected.{1} α _p.1": 1,
"comm_semigroup.{u} α": 1,
"monad_functor_t.{u u_1 v} n n' m m'": 1,
"has_lt.{(max u v)} (prod.{u v} α β)": 1,
"has_lt.{u} α": 4,
"has_lt.{u} α": 1,
"has_one.{0} int": 58,
"has_lift_t.{ub₁+1 ub₂+1} b₁ b₂": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"distrib.{0} nat": 8,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"add_monoid.{u} α": 1,
"has_sizeof.{0} (well_founded.{u} α r)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_insert.{u v} α γ": 1,
"has_subset.{u} α": 1,
"has_pow.{0 0} nat nat": 35,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"reflected.{1} β _p.2": 1,
"ordered_comm_group.{u} α": 4,
"has_sizeof.{v+1} (β a)": 1,
"has_le.{u} α": 6,
"has_sizeof.{1} name": 10,
"has_sub.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_mul.{u} α": 1,
"setoid.{u} α": 1,
"has_to_format.{u} α": 1,
"add_group.{u} α": 1,
"has_le.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sub.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (monoid.to_semigroup.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one))) (inv a) a) (has_one.one.{u} α (monoid.to_has_one.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))": 1,
"has_le.{u} α": 2,
"has_lt.{u} α": 2,
"has_equiv.{u_b} β": 1,
"has_div.{u} α": 1,
"has_sizeof.{v+1} (β a)": 1,
"reflected.{2} Type format": 1,
"has_sizeof.{u+1} α": 1,
"has_coe_t.{1 1} (reflected.{2} Type nat) (expr bool.tt)": 1,
"has_sizeof.{0} (or (has_lt.lt.{0} nat nat.has_lt val (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) val) (has_lt.lt.{0} nat nat.has_lt val (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))))))))))": 1,
"inhabited.{u} α": 1,
"monoid.{u} α": 1,
"has_sizeof.{(max (u+1) v)+1} (has_orelse.{u v} f)": 2,
"ordered_comm_group.{u} α": 2,
"has_sizeof.{u+1} α": 1,
"add_group.{u} α": 4,
"subsingleton.{1} (decidable c)": 1,
"comm_semiring.{u} α": 4,
"has_zero.{u} α": 3,
"has_coe_t.{1 1} (reflected.{2} Type (user_attribute simp_lemmas punit.{1})) (expr bool.tt)": 1,
"comm_semigroup.{u} α": 1,
"has_sizeof.{u+1} (α -> α)": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"decidable b": 2,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{(max ((u+1)+1) (v+1))} (applicative.{u v} m)": 2,
"monad.{u_1 u_2} m'": 1,
"decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))) name.anonymous))": 1,
"has_sizeof.{1} (option.{0} (list.{0} name))": 2,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{(max ((u+1)+1) (v+1))} (applicative.{u v} f)": 2,
"has_zero.{u} α": 1,
"decidable_linear_ordered_comm_group.{u} α": 1,
"has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} (a : ε -> ε') (a : m α), (m' α))": 2,
"ring.{u} α": 1,
"linear_order.{u} α": 1,
"has_coe_t.{u v} a b": 1,
"decidable (and (eq.{1} bool (environment.is_constructor_app env lhs) bool.tt) (and (eq.{1} bool (environment.is_constructor_app env rhs) bool.tt) (not (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt lhs)) (expr.const_name bool.tt (expr.get_app_fn bool.tt rhs))))))": 1,
"has_le.{u} α": 1,
"has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} {β : Type.{u}} (a : m α) (a : α -> (m β)), (m β))": 2,
"preorder.{u} α": 1,
"has_add.{u} α": 6,
"applicative.{u v} m": 1,
"subsingleton.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_div.{u} α": 1,
"has_sizeof.{(max (u+1) v)+1} (has_seq_right.{u v} f)": 2,
"has_zero.{u} α": 2,
"has_pure.{u v} m": 1,
"monad.{u_1 u_2} m": 1,
"has_div.{u} α": 5,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_lt.{u} α": 1,
"monad.{u v} f": 1,
"has_lt.{u} α": 2,
"has_neg.{u} α": 1,
"has_orelse.{u v} f": 1,
"distrib.{u} α": 2,
"decidable b": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))": 2,
"decidable c": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"linear_ordered_field.{u} α": 1,
"decidable p": 1,
"has_pure.{u v} m": 1,
"has_zero.{u} α": 4,
"has_andthen.{0 0 0} (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))": 295,
"preorder.{u} α": 4,
"has_coe_t.{1 1} (reflected.{1} (user_attribute simp_lemmas punit.{1}) (user_attribute.mk simp_lemmas punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.none.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (option.none.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (user_attribute_cache_cfg.mk simp_lemmas (fun (ns : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) simp_lemmas simp_lemmas (tactic.to_simp_lemmas simp_lemmas.mk ns) (fun (s : simp_lemmas), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) simp_lemmas simp_lemmas (list.mfoldl.{0 0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state) simp_lemmas name (fun (s : simp_lemmas) (attr_name : name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (list.{0} name) simp_lemmas (attribute.get_instances attr_name) (tactic.to_simp_lemmas s))) s attr_deps) (has_pure.pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (applicative.to_has_pure.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_applicative.{0 0} (fun {α : Type}, (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state))) simp_lemmas))))) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) attr_deps)) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))) (expr bool.tt)": 1,
"has_mul.{u} α": 14,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"field.{u} α": 2,
"has_mul.{u} α": 5,
"has_to_string.{v} β": 1,
"subsingleton.{1} (decidable c)": 1,
"has_le.{u} α": 2,
"decidable (eq.{1} bool (expr.is_local_constant e) bool.tt)": 1,
"linear_ordered_field.{u} α": 2,
"decidable c": 1,
"decidable_linear_order.{u} α": 1,
"decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))": 1,
"add_group.{u} α": 2,
"decidable b": 1,
"has_mem.{u_1 u_1} α (list.{u_1} α)": 1,
"comm_ring.{u} α": 2,
"has_sizeof.{u} α": 2,
"has_add.{u} α": 4,
"has_lift_t.{ub₁+1 ub₂+1} b₁ b₂": 1,
"has_lt.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_sizeof.{v+1} β": 1,
"has_repr.{(max u v)} (list.{(max u v)} (prod.{u v} α β))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{(max ((u+1)+1) (v+1))} (Pi {α : Type.{u}} (a : m α), (out α))": 2,
"has_to_format.{v} β": 1,
"has_lt.{u} α": 1,
"has_inv.{u} α": 3,
"field.{u} α": 2,
"has_equiv.{u_a} α": 2,
"group.{u} α": 1,
"decidable (eq.{1} name a_a_a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"reflected.{1} string acc": 1,
"has_le.{u} α": 2,
"monad_fail.{u v} m": 1,
"has_sub.{u} α": 1,
"subsingleton.{(max (u_1+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_mul.{u} α": 1,
"decidable p": 1,
"add_right_cancel_semigroup.{u} α": 1,
"linear_order.{u} α": 1,
"decidable c": 1,
"has_add.{u} α": 2,
"inhabited.{u+1} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_append.{u} (list.{u} α)": 1,
"decidable c": 3,
"add_comm_semigroup.{u} α": 23,
"has_bind.{u v} m": 2,
"has_bind.{u v} f": 2,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_mul.{u} α": 1,
"linear_ordered_field.{u} α": 4,
"has_pure.{u v} m": 1,
"has_mem.{u u} α (list.{u} α)": 2,
"has_mul.{u} α": 6,
"has_bind.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_le.{0} char": 2,
"has_mul.{u} α": 1,
"has_zero.{u} α": 2,
"has_bind.{u (max u v)} (state_t.{u v} σ m)": 1,
"has_coe_to_sort.{1 1} bool": 189,
"functor.{u v} m": 1,
"has_sizeof.{(max u 1)} (α -> α -> Prop)": 2,
"decidable b": 1,
"decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_add.{u} α": 1,
"has_mul.{u} α": 2,
"subsingleton.{1} (decidable c)": 1,
"group.{u} α": 4,
"inhabited.{v} (β a)": 1,
"has_neg.{u} α": 2,
"has_sizeof.{0} (has_lt.lt.{0} nat nat.has_lt val n)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_inv.{u} α": 1,
"has_neg.{u} α": 1,
"ring.{u} α": 2,
"has_to_format.{v} (β a)": 1,
"has_mul.{u} α": 8,
"has_sizeof.{(max ((u+1)+1) 1 (v+1))} (Pi {a : Type.{u}} (a_1 : string), (m a))": 2,
"decidable (eq.{1} nat c₁ c₂)": 1,
"has_lift.{u₁ u₂} a b": 1,
"has_div.{u} α": 1,
"has_equiv.{u} α": 1,
"linear_ordered_ring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"decidable (not (eq.{1} pos (lean.parser_state.cur_pos s) (lean.parser_state.cur_pos s')))": 1,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (smt_tactic punit.{1})": 25,
"has_append.{0} (list.{0} name)": 4,
"Pi (a : α), (decidable (not (has_mem.mem.{u u} α (list.{u} α) (list.has_mem.{u} α) a ys)))": 1,
"monad.{u v} m": 2,
"has_to_format.{u} β": 1,
"decidable (eq.{1} char hd (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))": 1,
"ordered_semiring.{u} α": 2,
"add_group.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_append.{0} name": 4,
"has_mul.{u} α": 1,
"has_zero.{u} α": 2,
"decidable (eq.{1} bool (list.empty.{0} format f₁) bool.tt)": 1,
"decidable (eq.{1} (list.{0} char) n₁ n₂)": 1,
"has_to_format.{0} (prod.{0 0} format format)": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"has_lt.{u} α": 1,
"has_lt.{(max u v)} (prod.{u v} α β)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"preorder.{u} α": 2,
"ring.{u} α": 2,
"has_lt.{u} α": 1,
"has_inv.{u} α": 2,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"has_lt.{v} β": 1,
"comm_semiring.{u} α": 2,
"has_equiv.{u} α": 3,
"monad.{0 v} m": 3,
"decidable (eq.{1} name a_hd (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"division_ring.{u} α": 2,
"decidable (or (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) n) (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))))))))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"reflected.{1} (user_attribute_cache_cfg punit.{1}) (user_attribute_cache_cfg.mk punit.{1} (fun (_x : list.{0} name), (has_pure.pure.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) tactic.alternative.{0})) punit.{1} punit.star.{1})) (list.nil.{0} name))": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"is_trans.{u} α le": 3,
"add_left_cancel_semigroup.{u} α": 2,
"has_pure.{u v} (except_t.{u v} ε m)": 1,
"has_coe_to_fun.{u₂ u₃} b": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"monad.{u v} m": 1,
"has_sizeof.{s+1} α": 2,
"has_sub.{u} α": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"monad.{u v} m": 2,
"has_add.{u} α": 2,
"has_add.{u} α": 1,
"monad.{u v} m": 32,
"has_lt.{v} β": 1,
"add_comm_semigroup.{u} α": 4,
"decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))": 1,
"has_lt.{0} nat": 301,
"field.{u} α": 1,
"has_zero.{u} α": 1,
"decidable (p a)": 1,
"has_le.{u} α": 2,
"has_le.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_append.{u} (list.{u} α)": 1,
"inhabited.{u+1} α": 1,
"has_sizeof.{1} tactic.transparency": 4,
"has_sub.{0} nat": 189,
"has_le.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{u+1} (α -> α)": 2,
"monad_functor_t.{u u_1 v} n n' m m'": 1,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_le.{u} α": 2,
"has_div.{u} α": 1,
"has_sizeof.{(max ((u+1)+1) (v+1))} (Pi {α : Type.{u}}, (f α))": 2,
"decidable (has_lt.lt.{0} nat nat.has_lt i (environment.inductive_num_params env n))": 1,
"monoid.{u} α": 1,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α _inst_1) b a)": 1,
"has_sizeof.{(max u 1)} (α -> α -> Prop)": 2,
"monad.{u v} m": 1,
"monoid.{u} α": 1,
"has_le.{u} α": 1,
"has_lt.{0} (fin n)": 2,
"has_mul.{u} α": 2,
"has_inv.{u} α": 1,
"decidable (eq.{1} name a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))": 1,
"has_repr.{u} α": 1,
"has_to_string.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_add.{u} α": 13,
"decidable (has_mem.mem.{u_1 u_1} α (list.{u_1} α) (list.has_mem.{u_1} α) a l₂)": 1,
"decidable_linear_ordered_comm_group.{u} α": 52,
"has_pure.{u v} m": 1,
"decidable p": 2,
"linear_order.{u} α": 2,
"monad_run.{u_1 u_2} out m": 1,
"decidable (lt b a)": 1,
"has_lt.{0} (list.{0} char)": 1,
"has_zero.{u} α": 6,
"has_mul.{u} α": 2,
"has_coe_to_fun.{u v} a": 2,
"ordered_cancel_comm_monoid.{u} α": 1,
"Pi (a : interactive.loc), (reflected.{1} interactive.loc a)": 16,
"decidable false": 3,
"has_le.{0} (fin n)": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"division_ring.{u} α": 2,
"monad.{u v} (option_t.{u v} m)": 39,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)": 1,
"has_le.{u} α": 1,
"has_sizeof.{u+1} (α -> α)": 2,
"reflected.{1} (name -> tactic.simp_arg_type) tactic.simp_arg_type.except": 1,
"has_sizeof.{0} (well_founded.{u} α r)": 1,
"has_coe_t.{1 1} simp_lemmas (option.{0} simp_lemmas)": 3,
"has_add.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"setoid.{u} α": 4,
"has_lt.{u} α": 2,
"decidable (eq.{1} bool (expr.alpha_eqv h_type new_h_type) bool.tt)": 1,
"decidable (has_lt.lt.{0} nat nat.has_lt n unsigned_sz)": 1,
"has_lt.{u} α": 3,
"decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))": 1,
"has_sizeof.{0} (is_trichotomous.{u} α lt)": 2,
"has_zero.{u} α": 1,
"has_sizeof.{v+1} β": 1,
"has_sizeof.{u} α": 1,
"preorder.{u} α": 3,
"has_bind.{0 0} m": 1,
"has_zero.{u} α": 3,
"has_zero.{u} α": 14,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"decidable p": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"division_ring.{u} α": 5,
"decidable p": 1,
"has_one.{u} α": 2,
"has_monad_lift_t.{u_1 u_2 u_3} m n": 1,
"add_comm_semigroup.{u} α": 1,
"ordered_comm_group.{u} α": 3,
"has_bind.{0 0} (id.{2} Type)": 1,
"Pi (a : α) (b : α), (decidable (eq.{u_1+1} α a b))": 1,
"has_add.{u} α": 2,
"is_lawful_monad.{u v} m _inst_1": 3,
"has_le.{u} α": 2,
"has_mod.{0} nat": 86,
"decidable b": 1,
"has_to_tactic_format.{0} (list.{0} level)": 1,
"has_mul.{u} α": 1,
"has_lift_t.{ua₂ ua₁} a₂ a₁": 1,
"has_add.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) y) (has_le.le.{0} nat nat.has_le y x))": 1,
"ring.{u} α": 2,
"has_zero.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_monad_lift_t.{u u_1 v} n m": 1,
"reflected.{1} string acc": 1,
"has_equiv.{u} α": 1,
"has_zero.{u} α": 1,
"has_div.{u} α": 2,
"has_le.{u} α": 2,
"add_group.{u} α": 16,
"decidable p": 1,
"has_zero.{u} α": 1,
"applicative.{u (max u v)} (state_t.{u v} σ m)": 9,
"has_le.{u} α": 4,
"mul_zero_class.{u} α": 4,
"has_mul.{u} α": 3,
"has_one.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_le.{u} α": 2,
"decidable p": 1,
"has_div.{u} α": 2,
"decidable (iff (eq.{1} bool (bxor bool.tt bool.ff) bool.tt) (xor (eq.{1} bool bool.tt bool.tt) (eq.{1} bool bool.ff bool.tt)))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))": 1,
"has_div.{u} α": 1,
"has_mul.{u} α": 2,
"setoid.{u} α": 1,
"preorder.{u} α": 2,
"has_le.{u} α": 4,
"decidable (eq.{1} bool (expr.is_local_constant e) bool.tt)": 1,
"has_seq_right.{u v} f": 1,
"linear_ordered_field.{u} α": 2,
"add_group.{u} α": 1,
"decidable p": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sub.{u} α": 1,
"has_lift_t.{u₂ u₃} b c": 1,
"Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_equiv.{u} α": 1,
"decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))": 1,
"has_sub.{u} α": 1,
"functor.{u v} f": 1,
"setoid.{u} α": 1,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"group.{u} α": 2,
"has_to_format.{u} (list.{u} α)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"monad_fail.{u v} m": 1,
"add_group.{u} α": 1,
"has_sizeof.{0} (equivalence.{u} α r)": 1,
"setoid.{u_b} β": 2,
"has_inv.{u} α": 2,
"comm_semigroup.{u} α": 2,
"setoid.{u_b} β": 2,
"setoid.{u_a} α": 2,
"has_lift_t.{u v} a b": 1,
"is_irrefl.{u} α lt": 1,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (decidable_linear_ordered_comm_group.to_ordered_comm_group.{u} α _inst_1)))) b a)": 1,
"has_to_tactic_format.{0} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_zero.{u} α": 1,
"decidable (eq.{1} bool (option.is_none.{0} punit.{1} rec) bool.tt)": 1,
"Pi (a : α), (decidable (has_mem.mem.{u u} α (list.{u} α) (list.has_mem.{u} α) a l₂))": 1,
"has_add.{u} α": 2,
"monoid.{u} α": 1,
"has_mul.{u} α": 1,
"monad.{0 0} m": 1,
"has_repr.{u} α": 1,
"is_trans.{u} α r": 1,
"setoid.{u_b} β": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"decidable (has_lt.lt.{0} nat nat.has_lt (pos.line p) line0)": 1,
"add_group.{u} α": 1,
"setoid.{u_a} α": 2,
"subsingleton.{1} (decidable c)": 1,
"decidable (eq.{u_1+1} α a b)": 1,
"decidable (or (eq.{1} bool (expr.is_pi t) bool.tt) (eq.{1} bool (expr.is_let t) bool.tt))": 1,
"has_le.{u} α": 1,
"decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))": 1,
"has_le.{0} nat": 226,
"has_add.{u} α": 5,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (decidable_linear_ordered_comm_group.to_ordered_comm_group.{u} α _inst_1)))) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (decidable_linear_ordered_comm_group.to_add_comm_group.{u} α _inst_1))))) b)": 1,
"is_irrefl.{u} α r": 2,
"has_sub.{u} α": 2,
"is_trans.{u} α r": 1,
"is_irrefl.{u} α r": 1,
"preorder.{u} α": 4,
"has_to_format.{u} α": 1,
"has_div.{u} α": 2,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_to_format.{u} α": 1,
"monoid.{u} α": 1,
"Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b))": 2,
"has_neg.{u} α": 1,
"subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))": 1,
"decidable c": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"has_lt.{0} key": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"monad.{0 0} m": 1,
"decidable_linear_ordered_comm_group.{u} α": 5,
"subsingleton.{1} (decidable c)": 1,
"has_sub.{u} α": 2,
"is_incomp_trans.{u} α lt": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"is_trichotomous.{u} α lt": 1,
"ordered_comm_group.{u} α": 4,
"decidable p": 2,
"decidable (or (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) n) (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))))))))))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_mul.{u} α": 2,
"has_mul.{u} α": 4,
"decidable (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))": 1,
"monad_fail.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))": 4,
"add_comm_semigroup.{u} α": 1,
"has_add.{u} α": 1,
"decidable (lt a c)": 1,
"has_zero.{u} α": 3,
"has_one.{u} α": 3,
"monoid.{u} α": 2,
"has_sizeof.{0} (is_strict_weak_order.{u} α lt)": 2,
"is_incomp_trans.{u} α lt": 1,
"has_le.{u} α": 2,
"ordered_semiring.{u} α": 2,
"reflected.{1} ((list.{0} (option.{0} name)) -> interactive.loc) interactive.loc.ns": 1,
"add_group.{u} α": 2,
"functor.{u v} m": 1,
"has_one.{u} α": 24,
"alternative.{0 v} f": 1,
"has_le.{u} α": 2,
"decidable (eq.{u+1} α a b)": 1,
"has_inv.{u} α": 2,
"is_trichotomous.{u} α lt": 1,
"has_le.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))": 1,
"monad_state.{0 0} (list.{0} smt_goal) smt_tactic": 1,
"division_ring.{u} α": 2,
"has_orelse.{u v} m": 1,
"add_comm_semigroup.{u} α": 34,
"applicative.{u v} (option_t.{u v} m)": 6,
"is_trichotomous.{u} α lt": 1,
"is_irrefl.{u} α lt": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"linear_order.{u} α": 2,
"has_one.{u} α": 1,
"has_sizeof.{(max ((u+1)+1) (u+1) (v+1))} (Pi {α : Type.{u}} {β : Type.{u}} (a : α) (a : f β), (f α))": 2,
"has_sub.{u} α": 1,
"partial_order.{u} α": 1,
"decidable (eq.{1} (expr bool.tt) new_h_type (lift_t.{1 1} (reflected.{1} Prop false) (expr bool.tt) (coe_to_lift.{1 1} (reflected.{1} Prop false) (expr bool.tt) (coe_base.{1 1} (reflected.{1} Prop false) (expr bool.tt) (expr.has_coe.{1} Prop false))) `(false)))": 1,
"has_to_string.{0} data": 1,
"has_lt.{u} α": 2,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_lift.{u v} a b": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_div.{u} α": 3,
"has_sub.{u} α": 2,
"has_bind.{u v} m": 1,
"monad.{u_1 u_2} m": 1,
"is_trans.{u} α r": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_mul.{u} α": 1,
"has_to_format.{u} α": 1,
"comm_semigroup.{u} α": 7,
"Pi (a : α), (has_sizeof.{v+1} (β a))": 1,
"has_sub.{u} α": 4,
"has_sizeof.{(max (u+1) v)+1} (has_seq_left.{u v} f)": 2,
"has_mem.{u u} α (list.{u} α)": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"division_ring.{u} α": 1,
"decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"has_div.{u} α": 1,
"has_add.{u} α": 5,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"ordered_semiring.{u} α": 2,
"has_lt.{u} α": 2,
"distrib.{u} α": 1,
"has_sizeof.{(imax u v)} (a -> b)": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_pure.{0 0} option.{0}": 1,
"subsingleton.{1} (decidable c)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"reflected.{1} (α -> (option.{0} α)) (option.some.{0} α)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : eq.{u+1} α (mul a b) zero), (or (eq.{u+1} α a zero) (eq.{u+1} α b zero)))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))": 1,
"has_sub.{u} α": 1,
"setoid.{u_b} β": 2,
"Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b))": 5,
"has_lt.{u} α": 3,
"applicative.{u v} m": 23,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b)": 1,
"has_lt.{u} α": 2,
"has_sizeof.{(max ((u+1)+1) (v+1))} (has_bind.{u v} m)": 2,
"decidable (eq.{1} bool b bool.tt)": 1,
"linear_ordered_field.{u} α": 10,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{1} unsigned": 2,
"decidable (eq.{1} bool (list.empty.{0} name ns) bool.tt)": 1,
"division_ring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"semigroup.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"division_ring.{u} α": 3,
"has_le.{u} α": 2,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"has_inv.{u} α": 1,
"alternative.{0 0} option.{0}": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_dvd.{u} α": 3,
"has_sizeof.{(max ((u+1)+1) (v+1))} (Pi {α : Type.{u}} {β : Type.{u}} (a : f α) (a : f β), (f α))": 2,
"has_sizeof.{(max ((v+1)+1) (u+1) (w+1))} (Pi {α : Type.{v}} (a : ε), (m α))": 2,
"has_to_string.{u} α": 1,
"add_comm_semigroup.{u} α": 17,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_one.{u} α": 4,
"has_mul.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"decidable (eq.{1} bool first bool.tt)": 1,
"decidable (eq.{u+1} α a b)": 1,
"partial_order.{u} α": 2,
"has_le.{u} α": 1,
"has_lt.{u} α": 4,
"has_one.{u} α": 2,
"has_pure.{u v} m": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"preorder.{u} α": 2,
"has_monad_lift.{u_1 u_2 u_3} n o": 1,
"has_emptyc.{v} γ": 1,
"has_le.{u} α": 3,
"monad_fail.{0 0} smt_tactic": 24,
"has_lt.{u} α": 1,
"has_neg.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_lt.{u} α": 2,
"ordered_comm_group.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"ordered_comm_group.{u} α": 2,
"has_lt.{u} α": 3,
"decidable (eq.{1} bool (string.is_empty s) bool.tt)": 1,
"has_le.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"has_lt.{u} α": 1,
"ordered_comm_group.{u} α": 2,
"has_inv.{u} α": 1,
"has_add.{u} α": 2,
"has_mul.{u} α": 3,
"monad_functor_t.{u v v} m m' m m'": 1,
"decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) y) (has_le.le.{0} nat nat.has_le y x))": 1,
"has_lt.{u} α": 1,
"preorder.{u} α": 3,
"has_mem.{u_1 u_1} α (list.{u_1} α)": 1,
"has_pure.{u v} m": 1,
"has_pure.{u (max u v)} (state_t.{u v} σ m)": 1,
"has_lt.{u} α": 2,
"has_mul.{u} α": 2,
"has_div.{u} α": 3,
"preorder.{u} α": 2,
"has_lt.{u} α": 2,
"functor.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))": 17,
"decidable (eq.{1} name n₁ n)": 1,
"division_ring.{u} α": 4,
"preorder.{u} α": 4,
"decidable c": 3,
"linear_ordered_field.{u} α": 2,
"has_add.{u} α": 1,
"has_sizeof.{v+1} α": 2,
"has_le.{u} α": 1,
"decidable_linear_ordered_cancel_comm_monoid.{u} α": 1,
"preorder.{u} α": 1,
"has_le.{u} α": 2,
"has_sizeof.{u+1} α": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"has_le.{u} α": 2,
"has_le.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_div.{u} α": 5,
"decidable (eq.{1} name a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))": 1,
"decidable (eq.{1} bool (list.empty.{0} format f₂) bool.tt)": 1,
"has_orelse.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))": 20,
"subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))": 1,
"has_le.{u} α": 2,
"has_mul.{u} α": 1,
"preorder.{u} α": 4,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state (list.{0} (prod.{0 0} name (expr bool.tt))))) (smt_tactic (list.{0} (prod.{0 0} name (expr bool.tt))))": 2,
"has_bind.{u v} m": 2,
"has_le.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"preorder.{u} α": 2,
"linear_order.{u} α": 2,
"has_append.{u} (list.{u} α)": 1,
"has_add.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_le.{u} α": 2,
"setoid.{u} α": 4,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"has_lt.{u} α": 6,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"ordered_semiring.{u} α": 2,
"has_to_tactic_format.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_lt.{u} α": 4,
"monad.{0 0} m": 1,
"has_sizeof.{u+1} α": 2,
"add_monoid.{u} α": 1,
"has_mul.{u} α": 1,
"has_pure.{u v} m": 1,
"has_neg.{u} α": 1,
"decidable (eq.{1} bool (tactic.apply_cfg.auto_param cfg) bool.tt)": 1,
"has_lt.{u} α": 3,
"has_mul.{u} α": 3,
"has_le.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))": 1,
"group.{u} α": 3,
"ordered_semiring.{u} α": 2,
"decidable (eq.{1} char c (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_bind.{0 0} m": 1,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"add_comm_semigroup.{u} α": 1,
"has_to_format.{u} α": 1,
"ordered_comm_group.{u} α": 2,
"has_lt.{u} α": 3,
"preorder.{u} α": 2,
"is_lawful_functor.{u v} m (applicative.to_functor.{u v} m (monad.to_applicative.{u v} m _inst_1))": 1,
"reflected.{2} Type (user_attribute punit.{1} punit.{1})": 1,
"applicative.{u (max u v)} (reader_t.{u v} ρ m)": 9,
"has_repr.{0} char": 1,
"decidable (has_mem.mem.{0 0} (expr bool.tt) (list.{0} (expr bool.tt)) (list.has_mem.{0} (expr bool.tt)) e goals)": 1,
"distrib.{u} α": 1,
"preorder.{u} α": 2,
"has_lt.{u} α": 2,
"decidable (eq.{1} char c (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))": 1,
"has_lt.{u} α": 2,
"has_le.{u} (list.{u} α)": 1,
"has_lt.{u} α": 2,
"has_lt.{u} α": 2,
"ring.{u} α": 2,
"division_ring.{u} α": 2,
"has_sizeof.{u+1} α": 2,
"ordered_semiring.{u} α": 2,
"distrib.{u} α": 1,
"semiring.{u} α": 4,
"has_bind.{u (max u v)} (reader_t.{u v} ρ m)": 1,
"subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))": 1,
"has_div.{u} α": 3,
"monad_fail.{u_1 u_1} (fun (α : Type.{u_1}), (tactic_state -> (interaction_monad.result.{u_1} tactic_state α)))": 1,
"has_lt.{0} key": 1,
"has_coe_t.{1 1} (reflected.{2} Type (user_attribute punit.{1} punit.{1})) (expr bool.tt)": 1,
"monad.{u u_1} m": 1,
"decidable (eq.{1} bool (bnot (list.empty.{0} (expr bool.tt) gs)) bool.tt)": 1,
"has_sizeof.{u+1} α": 2,
"decidable (not (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero)))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"linear_order.{u} α": 2,
"Pi (a : α) (b : α), (decidable (lt a b))": 2,
"decidable (eq.{1} name a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"add_group.{u} α": 3,
"has_div.{u} α": 2,
"has_le.{u} α": 4,
"has_lt.{u} α": 1,
"has_le.{u} α": 2,
"decidable (eq.{1} nat n (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))": 1,
"has_le.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α _inst_1)) b a)": 1,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"Pi (a : expr bool.tt), (decidable (eq.{1} bool (expr.is_local_constant a) bool.tt))": 1,
"division_ring.{u} α": 1,
"has_sizeof.{(max ((u+1)+1) (v+1) (w+1))} (Pi {α : Type.{u}} (a : m α), (n α))": 2,
"has_seq.{u v} f": 8,
"has_bind.{0 v} m": 1,
"has_neg.{u} α": 2,
"has_sub.{u} α": 1,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_lt.{u} α": 2,
"inhabited.{v+1} β": 1,
"decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"linear_order.{u} α": 1,
"division_ring.{u} α": 4,
"has_add.{u} α": 1,
"has_le.{u} α": 2,
"has_mem.{u u} α (list.{u} α)": 1,
"has_add.{u} α": 3,
"partial_order.{u} α": 2,
"distrib.{u} α": 2,
"has_zero.{u} α": 3,
"comm_semiring.{u} α": 4,
"preorder.{u} α": 2,
"has_mul.{u} α": 5,
"has_sizeof.{1} tactic.dsimp_config": 4,
"decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"alternative.{0 v} f": 1,
"linear_order.{u} α": 2,
"decidable (lt a c)": 1,
"has_lt.{u} α": 1,
"division_ring.{u} α": 2,
"preorder.{u} α": 4,
"has_le.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))": 1,
"has_le.{u} α": 2,
"has_mul.{u} α": 1,
"monoid.{u} α": 1,
"has_mem.{u u} α (set.{u} α)": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))": 1,
"Pi (a : expr bool.tt), (decidable (eq.{1} bool (name_set.contains (_private.3046988405.remove_deps s t) (expr.local_uniq_name a)) bool.tt))": 1,
"has_sizeof.{v+1} β": 1,
"linear_order.{u} α": 1,
"decidable (not (or (eq.{1} bool (expr.is_pi t) bool.tt) (eq.{1} bool (expr.is_let t) bool.tt)))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_le.{u} α": 3,
"has_coe_to_fun.{1 1} (expr bool.tt)": 6,
"monad.{0 0} m": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"decidable (eq.{1} bool te bool.tt)": 2,
"preorder.{u} α": 4,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"comm_ring.{u} α": 2,
"has_lt.{0} key": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"add_group.{u} α": 4,
"has_add.{u} α": 1,
"has_pure.{0 v} f": 1,
"Pi (a : key) (b : key), (decidable (has_lt.lt.{0} key _inst_1 a b))": 1,
"has_le.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_zero.{u} α": 4,
"monad_fail.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))": 228,
"Pi (a : α), (decidable (not (eq.{1} bool (lt h a) bool.tt)))": 1,
"has_le.{u} α": 3,
"setoid.{u_b} β": 4,
"has_mul.{u} α": 3,
"has_bind.{0 0} m": 1,
"has_inv.{u} α": 1,
"setoid.{(imax u v)} (Pi (x : α), (β x))": 1,
"setoid.{u_a} α": 2,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_lt.{0} key": 2,
"has_mul.{u} α": 2,
"functor.{u v} f": 1,
"decidable (eq.{1} bool (name_set.contains ex n) bool.tt)": 1,
"comm_semigroup.{u} α": 1,
"has_to_format.{u} α": 1,
"decidable (eq.{1} name a_hd_a_1 (name.mk_string (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"preorder.{u} α": 2,
"monoid.{u} α": 1,
"preorder.{u} α": 6,
"has_to_format.{0} data": 1,
"ordered_comm_group.{u} α": 2,
"has_to_tactic_format.{u} α": 1,
"functor.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"preorder.{u} α": 4,
"Pi (a : name) (b : name), (decidable (eq.{1} name a b))": 2,
"has_mul.{u} α": 3,
"has_bind.{u v} m": 1,
"has_le.{u} α": 1,
"has_sub.{u} α": 3,
"has_zero.{u} α": 2,
"alternative.{u v} m": 2,
"monoid.{u} α": 1,
"setoid.{u_a} α": 2,
"decidable (eq.{1} bool (tactic.is_trace_enabled_for n) bool.tt)": 1,
"decidable (not (eq.{1} bool (list.empty.{0} name u) bool.tt))": 1,
"has_sizeof.{(max (u+1) 1)} (α -> string)": 2,
"ring.{u} α": 1,
"has_lt.{0} key": 1,
"has_mul.{u} α": 2,
"division_ring.{u} α": 1,
"has_mul.{u} α": 2,
"division_ring.{u} α": 4,
"decidable (eq.{1} nat l₁ l₂)": 1,
"has_sub.{u} α": 2,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"linear_ordered_ring.{u} α": 2,
"has_inv.{u} α": 1,
"has_add.{u} α": 1,
"monad.{0 0} m": 1,
"division_ring.{u} α": 1,
"group.{u} α": 4,
"monad.{u v} m": 1,
"monad_except.{u v w} ε m": 3,
"has_equiv.{u} α": 1,
"division_ring.{u} α": 2,
"has_lt.{u} α": 2,
"has_bind.{u v} m": 1,
"has_zero.{u} α": 1,
"has_mul.{u} α": 2,
"ordered_comm_group.{u} α": 4,
"has_lt.{u} α": 1,
"monad_state.{u v} σ m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_mul.{u} α": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"add_group.{u} α": 7,
"decidable_linear_order.{u} α": 1,
"has_to_format.{0} name": 20,
"has_zero.{u} α": 1,
"has_bind.{0 0} m": 1,
"decidable p": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"is_refl.{u} α le": 1,
"is_incomp_trans.{u} α r": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"decidable_linear_ordered_comm_group.{u} α": 2,
"has_pure.{0 0} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_mem.{u u} α (set.{u} α)": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_bind.{u v} m": 2,
"decidable (eq.{1} name p n)": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"decidable (eq.{1} bool first bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_zero.{u} α": 3,
"has_pure.{u v} m": 1,
"has_add.{u} α": 15,
"division_ring.{u} α": 3,
"ring.{u} α": 1,
"has_le.{u} α": 1,
"preorder.{u} α": 2,
"decidable (and (eq.{1} bool use_ns bool.tt) (not (eq.{1} bool (list.empty.{0} name ns) bool.tt)))": 1,
"ordered_cancel_comm_monoid.{u} α": 4,
"decidable (eq.{1} name _a (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"ring.{u} α": 2,
"reflected.{1} (expr bool.ff) _p.2": 1,
"inhabited.{1} name": 4,
"has_mul.{u} α": 2,
"has_mul.{u} α": 2,
"ordered_comm_group.{u} α": 3,
"discrete_field.{u} α": 2,
"monad.{0 0} m": 2,
"has_lt.{u} α": 1,
"has_lt.{u} α": 1,
"has_le.{u} α": 8,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"ordered_semiring.{u} α": 4,
"group.{u} α": 2,
"decidable (eq.{1} bool (bor (tactic.apply_cfg.auto_param cfg) (tactic.apply_cfg.opt_param cfg)) bool.tt)": 1,
"ring.{u} α": 1,
"add_group.{u} α": 1,
"decidable_linear_order.{u} α": 6,
"has_bind.{u v} m": 1,
"alternative.{u v} f": 1,
"has_sizeof.{u+1} ε": 2,
"preorder.{u} α": 2,
"has_lt.{u} α": 4,
"has_coe_t.{1 1} nat format": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"inhabited.{1} (expr bool.tt)": 4,
"decidable_linear_order.{u} α": 1,
"add_group.{u} α": 2,
"has_sub.{u} α": 1,
"has_sizeof.{1} string": 2,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state name)) (smt_tactic name)": 1,
"has_add.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_mem.{u u} α (set.{u} α)": 1,
"preorder.{u} α": 2,
"linear_order.{u} α": 2,
"ordered_ring.{u} α": 1,
"reflected.{1} (name -> name) (name.mk_string s)": 1,
"comm_semigroup.{u} α": 16,
"is_irrefl.{u} α (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))))": 1,
"has_zero.{u} α": 4,
"has_lt.{u} α": 4,
"has_one.{u} α": 4,
"has_sizeof.{u+1} (rbnode.{u} α)": 4,
"decidable (has_le.le.{0} nat nat.has_le (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)) (expr.get_app_num_args e))": 1,
"has_lt.{u} α": 2,
"has_bind.{u v} m": 1,
"has_bind.{u v} m": 1,
"add_comm_semigroup.{u} α": 3,
"has_zero.{u} α": 1,
"preorder.{u} α": 1,
"Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))) a b))": 1,
"decidable (eq.{1} bool (list.empty.{0} format f₂) bool.tt)": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"ordered_comm_group.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_le.{u} α": 1,
"has_lt.{u} α": 1,
"has_lt.{u} α": 1,
"decidable c": 3,
"add_comm_semigroup.{u} α": 6,
"has_lt.{u} α": 1,
"has_sizeof.{(imax u v)} (a -> b)": 2,
"has_bind.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_to_tactic_format.{0} α": 1,
"has_inv.{u} α": 3,
"has_sub.{u} α": 2,
"monad.{u v} m'": 1,
"has_to_format.{0} key": 1,
"distrib.{u} α": 1,
"has_zero.{u} α": 3,
"has_zero.{u} α": 4,
"has_to_format.{0} (expr bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"functor.{u v} m": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))": 2,
"monad_except_adapter.{u v} ε ε' m m'": 1,
"monad.{u v} m": 1,
"preorder.{u} α": 2,
"decidable (eq.{1} name n₁ n₂)": 1,
"add_comm_semigroup.{u} α": 1,
"has_lt.{u} α": 2,
"has_sizeof.{v+1} (m (option.{u} α))": 2,
"has_dvd.{u} α": 2,
"has_sizeof.{u+1} α": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"add_semigroup.{u} α": 1,
"reflected.{1} (user_attribute hinst_lemmas punit.{1}) (user_attribute.mk hinst_lemmas punit.{1} attr_name (has_append.append.{0} string string.has_append (has_append.append.{0} string string.has_append (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (to_string.{0} name name.has_to_string simp_attr_name)) (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.none.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (option.none.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (user_attribute_cache_cfg.mk hinst_lemmas (fun (ns : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) hinst_lemmas hinst_lemmas (_private.787519257.to_hinst_lemmas tactic.transparency.reducible mk_name_set ns hinst_lemmas.mk) (fun (hs : hinst_lemmas), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (list.{0} name) hinst_lemmas (attribute.get_instances simp_attr_name) (fun (ss : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) name_set hinst_lemmas (get_name_set_for_attr ex_attr_name) (fun (ex : name_set), (_private.787519257.to_hinst_lemmas tactic.transparency.reducible ex ss hs)))))))) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (list.cons.{0} name simp_attr_name (list.nil.{0} name)))) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))": 1,
"has_add.{u} α": 3,
"has_mul.{u} α": 8,
"has_add.{u} α": 1,
"decidable (iff (eq.{1} bool (band bool.tt bool.tt) bool.tt) (and (eq.{1} bool bool.tt bool.tt) (eq.{1} bool bool.tt bool.tt)))": 1,
"has_to_tactic_format.{0} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sub.{u} α": 2,
"has_to_format.{u_1} key": 1,
"has_mul.{u} α": 2,
"has_to_string.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (monoid.to_semigroup.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one))) (inv a) a) (has_one.one.{u} α (monoid.to_has_one.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one)))))": 1,
"has_div.{u} α": 2,
"monad.{u_1 u_2} m'": 1,
"alternative.{u v} m": 1,
"left_cancel_semigroup.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_add.{u} α": 2,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (decidable_linear_ordered_cancel_comm_monoid.to_ordered_cancel_comm_monoid.{u} α _inst_1)))) b c)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : eq.{u+1} α (mul a b) zero), (or (eq.{u+1} α a zero) (eq.{u+1} α b zero)))": 1,
"setoid.{(imax u v)} (Pi (x : α), (β x))": 3,
"has_neg.{u} α": 1,
"monad.{u u} (id.{(u+1)+1} Type.{u})": 3,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"field.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_zero.{u} α": 2,
"has_le.{u} α": 3,
"decidable true": 2,
"has_lt.{u} α": 2,
"has_sizeof.{u+1} α": 2,
"has_sizeof.{0} (eq.{u+1} α (inv zero) zero)": 1,
"decidable p": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"field.{u} α": 4,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"decidable (eq.{1} rbnode.color (rbnode.get_color.{u} α b) rbnode.color.red)": 1,
"reflected.{2} Type β": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"has_sizeof.{u+1} α": 2,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_zero.{u} α": 2,
"monoid.{u} α": 1,
"semigroup.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_neg.{u} α": 1,
"has_add.{u} α": 1,
"division_ring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"comm_semiring.{u} α": 6,
"has_sizeof.{u+1} (α -> α)": 2,
"ordered_comm_group.{u} α": 2,
"has_equiv.{u_a} α": 1,
"has_dvd.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"ordered_semiring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_neg.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"preorder.{u} α": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"add_comm_semigroup.{u} α": 39,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_le.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"distrib.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"decidable (eq.{1} name attr_name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_dvd.{u} α": 1,
"has_sizeof.{u+1} (α -> α)": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"group.{u} α": 4,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"add_monoid.{u} α": 1,
"decidable (eq.{1} (expr bool.tt) t h)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"add_comm_semigroup.{u} α": 2,
"decidable p": 2,
"has_neg.{u} α": 1,
"monad.{0 0} smt_tactic": 79,
"decidable (eq.{1} bool (exceptional.to_bool declaration (environment.get env tgt)) bool.ff)": 1,
"has_zero.{u} α": 1,
"add_semigroup.{u} α": 2,
"field.{u} α": 1,
"add_group.{u} α": 1,
"decidable (not (eq.{1} (expr bool.tt) e' e))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sub.{u} α": 1,
"monad_functor_t.{u u_1 (max u v)} n n' (reader_t.{u v} ρ m) (reader_t.{u v} ρ m')": 1,
"has_sub.{u} α": 1,
"add_group.{u} α": 1,
"has_add.{u} α": 1,
"has_sizeof.{(max ((u+1)+1) (v+1))} (has_pure.{u v} f)": 2,
"has_sub.{u} α": 1,
"has_zero.{u} α": 2,
"has_add.{u} α": 1,
"reflected.{1} (option.{0} pos) _p.2": 1,
"has_mul.{u} α": 3,
"decidable (eq.{1} bool (name_set.contains s (expr.local_pp_name bool.tt h)) bool.tt)": 1,
"decidable (f b)": 1,
"add_group.{u} α": 1,
"add_group.{u} α": 2,
"has_lt.{u} α": 2,
"has_sub.{u} α": 2,
"Pi (a : α), (decidable (eq.{1} bool (lt h a) bool.tt))": 2,
"has_mul.{u} α": 3,
"has_add.{u} α": 2,
"decidable (not (eq.{1} name n (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"has_zero.{u} α": 1,
"has_pure.{0 v} f": 1,
"add_group.{u} α": 2,
"has_add.{u} α": 2,
"semigroup.{u} α": 1,
"add_semigroup.{u} α": 1,
"has_div.{u} α": 2,
"has_neg.{u} α": 2,
"has_zero.{u} α": 1,
"has_sub.{u} α": 1,
"has_mul.{u} α": 1,
"has_zero.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_zero.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_sub.{u} α": 1,
"add_comm_semigroup.{0} int": 53,
"ring.{u} α": 2,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state level)) (smt_tactic level)": 2,
"add_group.{u} α": 2,
"preorder.{u} α": 2,
"has_neg.{u} α": 1,
"add_monoid.{u} α": 1,
"distrib.{u} α": 1,
"has_sub.{u} α": 2,
"functor.{u v} f": 9,
"has_neg.{u} α": 1,
"ordered_comm_group.{u} α": 2,
"add_comm_semigroup.{u} α": 23,
"add_group.{u} α": 2,
"has_to_format.{0} (list.{0} nat)": 4,
"linear_order.{u} α": 2,
"distrib.{u} α": 2,
"integral_domain.{0} int": 2,
"division_ring.{u} α": 2,
"has_sub.{u} α": 2,
"linear_ordered_field.{u} α": 2,
"has_zero.{u} α": 2,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_le.{u} α": 2,
"monad.{u v} m": 1,
"add_group.{u} α": 1,
"preorder.{u} α": 2,
"has_subset.{u} (set.{u} α)": 1,
"has_add.{u} α": 1,
"has_add.{u} α": 1,
"decidable (iff (not (eq.{1} bool bool.tt bool.tt)) (eq.{1} bool bool.tt bool.ff))": 1,
"has_zero.{u} α": 4,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"semigroup.{u} α": 1,
"has_sub.{u} α": 1,
"add_group.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sub.{u} α": 1,
"has_mem.{u u} α (list.{u} α)": 2,
"has_add.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"partial_order.{u} α": 1,
"add_group.{u} α": 3,
"has_sub.{u} α": 1,
"has_mul.{u} α": 2,
"has_add.{u} α": 1,
"ordered_comm_group.{0} int": 14,
"add_semigroup.{u} α": 1,
"decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))": 1,
"has_dvd.{u} α": 1,
"linear_ordered_field.{u} α": 6,
"add_group.{u} α": 14,
"add_semigroup.{u} α": 1,
"has_add.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"decidable c": 3,
"add_semigroup.{u} α": 1,
"has_lt.{u} α": 3,
"add_group.{u} α": 3,
"add_monoid.{u} α": 1,
"division_ring.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"add_monoid.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_zero.{u} α": 3,
"decidable (eq.{1} bool (expr.is_local_constant h) bool.tt)": 1,
"has_neg.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_neg.{u} α": 1,
"add_comm_semigroup.{u} α": 13,
"decidable (eq.{1} bool r bool.tt)": 1,
"add_semigroup.{u} α": 1,
"add_group.{u} α": 14,
"has_dvd.{u} α": 1,
"decidable p": 1,
"add_monoid.{u} α": 1,
"add_group.{u} α": 5,
"preorder.{u} α": 2,
"add_left_cancel_semigroup.{u} α": 1,
"has_sub.{u} α": 2,
"has_div.{u} α": 5,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"applicative.{u v} (except_t.{u v} ε m)": 6,
"has_mul.{u} α": 1,
"field.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"add_semigroup.{u} α": 1,
"ordered_semiring.{u} α": 1,
"add_monoid.{u} α": 1,
"decidable (eq.{1} rbnode.color (rbnode.get_color.{u} α a) rbnode.color.red)": 1,
"has_mul.{u} α": 1,
"has_le.{u} α": 6,
"add_group.{u} α": 2,
"add_comm_group.{u} α": 1,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"has_to_string.{u} α": 1,
"has_dvd.{u} α": 2,
"add_group.{u} α": 3,
"has_insert.{u u} α (list.{u} α)": 1,
"add_monoid.{u} α": 1,
"ring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"linear_order.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_sub.{u} α": 3,
"decidable (eq.{1} (fin n) i j)": 1,
"has_lt.{u} α": 2,
"add_semigroup.{u} α": 1,
"add_monoid.{u} α": 1,
"has_add.{u} α": 1,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"has_add.{u} α": 2,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"add_group.{u} α": 1,
"decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))))": 1,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"add_group.{u} α": 7,
"has_neg.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_mul.{u} α": 1,
"add_comm_semigroup.{u} α": 12,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))": 1,
"add_group.{u} α": 10,
"subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))": 1,
"monad.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))": 1,
"add_comm_semigroup.{u} α": 8,
"subsingleton.{1} (decidable c)": 1,
"subsingleton.{1} (decidable c)": 1,
"preorder.{u} α": 2,
"has_sub.{u} α": 1,
"decidable (eq.{1} bool use_default bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sub.{u} α": 1,
"add_group.{u} α": 14,
"has_sub.{u} α": 2,
"has_add.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"has_div.{u} α": 5,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"monoid.{u} α": 1,
"add_comm_semigroup.{u} α": 11,
"add_group.{u} α": 4,
"subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))": 1,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state tactic_state)) (smt_tactic tactic_state)": 1,
"Pi (a : expr bool.tt) (b : expr bool.tt), (decidable (has_lt.lt.{0} (expr bool.tt) expr.has_lt a b))": 2,
"add_monoid.{u} α": 1,
"add_semigroup.{0} int": 5,
"has_one.{u} α": 8,
"subsingleton.{1} (decidable c)": 1,
"setoid.{u_a} α": 2,
"subsingleton.{1} (decidable c)": 1,
"has_sub.{u} α": 3,
"subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))": 1,
"ordered_semiring.{u} α": 2,
"has_sub.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"add_group.{u} α": 22,
"has_zero.{u} α": 2,
"is_trans.{u} α lt": 1,
"has_div.{u} α": 3,
"alternative.{0 0} m": 1,
"has_sub.{u} α": 2,
"subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))": 1,
"linear_order.{u} α": 2,
"add_group.{u} α": 17,
"decidable (eq.{1} bool first bool.tt)": 1,
"add_comm_semigroup.{u} α": 18,
"add_group.{u} α": 3,
"add_comm_semigroup.{u} α": 4,
"has_lt.{u} α": 1,
"add_monoid.{u} α": 1,
"add_comm_semigroup.{u} α": 4,
"has_sizeof.{u+1} α": 2,
"add_group.{u} α": 2,
"has_add.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"division_ring.{u} α": 4,
"has_zero.{u} α": 14,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))": 1,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_one.{u} α": 1,
"setoid.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"ordered_comm_group.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))": 1,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sub.{u} α": 1,
"has_mul.{u} α": 6,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_le.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_pure.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))": 1,
"decidable (has_mem.mem.{0 0} char (list.{0} char) (list.has_mem.{0} char) c (list.cons.{0} char (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (list.cons.{0} char (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))) (list.cons.{0} char (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))) (list.nil.{0} char)))))": 1,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_zero.{u} α": 1,
"ring.{u} α": 1,
"decidable (eq.{1} bool (expr.has_meta_var e) bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"decidable (eq.{u+1} α b (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"has_dvd.{u} α": 2,
"decidable (eq.{1} name a_a_a_a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_one.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))": 1,
"has_mem.{u u} α (list.{u} α)": 1,
"has_add.{u} α": 2,
"has_add.{u} α": 2,
"has_zero.{u} α": 4,
"has_mul.{u} α": 2,
"division_ring.{u} α": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))": 1,
"has_add.{u} α": 1,
"has_add.{u} α": 2,
"has_to_tactic_format.{u} α": 1,
"monad_functor.{u_1 u_2 u_3} n n' o o'": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))": 1,
"has_mul.{u} α": 1,
"mul_zero_class.{u} α": 2,
"has_zero.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"mul_zero_class.{u} α": 2,
"has_sizeof.{u+1} α": 4,
"has_lt.{u} α": 1,
"has_zero.{u} α": 1,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"ordered_comm_group.{u} α": 3,
"has_inv.{u} α": 2,
"has_one.{u} α": 1,
"add_semigroup.{0} nat": 5,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))": 1,
"has_zero.{u} α": 1,
"discrete_field.{u} α": 2,
"has_one.{u} α": 1,
"has_zero.{u} α": 1,
"decidable (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))": 4,
"comm_semigroup.{u} α": 1,
"has_le.{u} α": 2,
"has_add.{u} α": 2,
"has_le.{u} α": 2,
"has_one.{u} α": 2,
"preorder.{u} α": 6,
"has_add.{u} α": 2,
"preorder.{u} α": 6,
"has_zero.{u} α": 2,
"add_monoid.{u} α": 1,
"ordered_semiring.{u} α": 2,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"add_comm_semigroup.{u} α": 2,
"has_add.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_lt.{u} α": 2,
"has_add.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"division_ring.{u} α": 1,
"has_le.{u} α": 3,
"setoid.{u} α": 4,
"has_add.{u} α": 2,
"has_lt.{u} α": 2,
"has_zero.{u} α": 2,
"preorder.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 4,
"has_zero.{u} α": 2,
"has_neg.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_add.{0} (fin n)": 1,
"has_zero.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))": 1,
"has_add.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{u+1} α": 4,
"comm_semiring.{u} α": 2,
"linear_order.{u} α": 1,
"has_lt.{u} α": 3,
"has_zero.{u} α": 1,
"has_le.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"ordered_semiring.{u} α": 2,
"has_add.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 4,
"has_add.{u} α": 2,
"zero_ne_one_class.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"reflected.{2} Type string": 3,
"preorder.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"ordered_cancel_comm_monoid.{u} α": 4,
"has_sub.{u} α": 2,
"has_lt.{u} α": 2,
"has_mul.{u} α": 6,
"has_le.{u} α": 1,
"add_group.{u} α": 6,
"has_le.{u} α": 1,
"has_mul.{u} α": 2,
"monad.{u v} m": 2,
"add_monoid.{u} α": 1,
"has_add.{u} α": 2,
"decidable_linear_order.{u} α": 10,
"decidable (has_lt.lt.{u} (list.{u} α) (list.has_lt.{u} α _inst_1) b a)": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_seq.{u (max u v)} (state_t.{u v} σ m)": 1,
"has_add.{u} α": 3,
"has_add.{u} α": 2,
"has_lt.{u} α": 2,
"setoid.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))": 1,
"has_add.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_add.{u} α": 4,
"decidable (and (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt e)) (name.mk_string (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))) (eq.{1} nat (expr.get_app_num_args e) (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))": 1,
"has_le.{u} α": 3,
"add_monoid.{u} α": 1,
"has_add.{u} α": 2,
"add_monoid.{u} α": 1,
"preorder.{u} α": 2,
"has_le.{u} α": 2,
"has_mul.{u} α": 1,
"comm_semigroup.{u} α": 14,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_div.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_add.{u} α": 1,
"add_comm_semigroup.{u} α": 14,
"add_monoid.{u} α": 1,
"has_mul.{u} α": 3,
"has_lt.{u} α": 2,
"has_lt.{u} α": 3,
"ordered_cancel_comm_monoid.{u} α": 2,
"mul_zero_class.{u} α": 4,
"has_zero.{u} α": 4,
"add_monoid.{u} α": 1,
"has_sub.{u} α": 1,
"has_div.{u} α": 2,
"has_sub.{u} α": 2,
"has_le.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 35,
"add_monoid.{u} α": 1,
"preorder.{u} α": 2,
"has_sizeof.{(max ((u+1)+1) (v+1))} (Pi {α : Type.{u}} (a : f α) (a : f α), (f α))": 2,
"semigroup.{u} α": 1,
"has_zero.{u} α": 4,
"field.{u} α": 5,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"decidable (eq.{1} bool use_first_ex bool.tt)": 1,
"has_zero.{u} α": 4,
"has_coe_t.{1 1} (reflected.{1} (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state punit.{1})) (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1})) (expr bool.tt)": 1,
"has_le.{u} α": 1,
"decidable (eq.{1} nat (has_mod.mod.{0} nat nat.has_mod n (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))) (has_zero.zero.{0} nat nat.has_zero))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"add_group.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_neg.{u} α": 1,
"has_le.{u} α": 2,
"monad.{u v} m": 1,
"add_comm_semigroup.{u} α": 2,
"has_mem.{u u} α (list.{u} α)": 1,
"add_monoid.{u} α": 1,
"decidable (eq.{1} bool (format.is_nil r) bool.tt)": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_div.{u} α": 6,
"has_add.{u} α": 1,
"add_monoid.{u} α": 1,
"has_zero.{u} α": 4,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_mul.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"linear_order.{u} α": 2,
"has_add.{u} α": 2,
"has_zero.{u} α": 1,
"has_add.{u} α": 1,
"ordered_ring.{u} α": 2,
"add_comm_semigroup.{u} α": 1,
"add_monoid.{u} α": 1,
"decidable_linear_ordered_comm_group.{u} α": 2,
"has_le.{u} α": 1,
"decidable (or (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) n) (has_lt.lt.{0} nat nat.has_lt n (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))))))))))": 1,
"has_one.{u} α": 6,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"comm_semiring.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"monoid.{u} α": 1,
"has_mem.{u u} α (set.{u} α)": 1,
"has_to_string.{0} key": 1,
"has_le.{u} α": 8,
"has_add.{u} α": 8,
"has_zero.{u} α": 1,
"has_add.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"add_monoid.{u} α": 1,
"discrete_field.{u} α": 1,
"has_zero.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) c b)), (eq.{u+1} α a c))": 1,
"add_monoid.{u} α": 1,
"add_group.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 4,
"decidable c": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"monoid.{u} α": 1,
"has_add.{u} α": 1,
"has_zero.{u} α": 4,
"has_le.{u} α": 1,
"decidable (p a)": 1,
"has_sizeof.{u+1} α": 2,
"is_trans.{u} α lt": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_inv.{u} α": 1,
"has_neg.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_monad_lift_t.{u u_1 v} n (except_t.{u v} ε m)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))": 1,
"has_lt.{u} α": 2,
"has_add.{u} α": 1,
"has_zero.{u} α": 1,
"has_div.{u} α": 1,
"has_add.{u} α": 1,
"has_le.{u} α": 3,
"decidable (eq.{1} bool tgt bool.tt)": 1,
"has_add.{u} α": 1,
"has_add.{u} α": 1,
"has_zero.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_neg.{u} α": 2,
"has_to_tactic_format.{u} α": 1,
"has_zero.{0} nat": 843,
"has_add.{u} α": 1,
"add_monoid.{u} α": 3,
"discrete_field.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"add_monoid.{u} α": 1,
"add_monoid.{u} α": 1,
"has_repr.{u} α": 1,
"has_le.{u} α": 1,
"has_neg.{u} α": 1,
"has_zero.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_one.{u} α": 2,
"has_lt.{u} α": 2,
"has_mul.{u} α": 2,
"add_monoid.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_to_string.{0} (list.{0} name)": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_lt.{u} α": 1,
"has_lt.{u} α": 2,
"has_to_tactic_format.{v} β": 1,
"has_add.{u} α": 1,
"has_lt.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"is_trans.{u} α lt": 1,
"has_mul.{u} α": 2,
"has_zero.{u} α": 1,
"has_inv.{u} α": 1,
"has_neg.{u} α": 1,
"has_le.{u} α": 1,
"has_add.{u} α": 1,
"is_refl.{u} α r": 1,
"decidable (eq.{1} bool (expr.alpha_eqv h_val h) bool.tt)": 1,
"add_monoid.{u} α": 1,
"has_pure.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))": 26,
"has_zero.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_lt.{u} α": 3,
"has_neg.{u} α": 2,
"add_monoid.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_add.{u} α": 4,
"has_zero.{u} α": 1,
"has_bind.{u v} m": 2,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))": 2,
"monoid.{u} α": 2,
"monoid.{u} α": 2,
"has_le.{u} α": 1,
"has_mul.{u} α": 1,
"add_group.{u} α": 4,
"has_lt.{u} α": 2,
"has_add.{u} α": 1,
"has_lt.{u} α": 3,
"add_monoid.{u} α": 1,
"has_sizeof.{u+1} (α -> α)": 2,
"has_lt.{u} α": 2,
"ordered_comm_group.{u} α": 1,
"decidable p": 1,
"decidable (eq.{1} bool (name_set.contains s r) bool.tt)": 1,
"has_le.{u} α": 1,
"comm_semigroup.{u} α": 1,
"has_add.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"add_monoid.{u} α": 1,
"has_le.{u} α": 1,
"has_one.{u} α": 2,
"has_lt.{u} α": 1,
"has_lift_t.{ub₁ ub₂} b₁ b₂": 1,
"has_lt.{u} α": 3,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_add.{u} α": 2,
"has_sizeof.{1} tactic.simp_config": 4,
"add_monoid.{u} α": 1,
"has_mul.{u} α": 5,
"has_add.{u} α": 4,
"has_le.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"semigroup.{u} α": 2,
"has_one.{u} α": 3,
"add_comm_semigroup.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))": 1,
"has_zero.{u} α": 4,
"has_mul.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))": 1,
"semigroup.{u} α": 1,
"distrib.{u} α": 2,
"has_lt.{u} α": 2,
"has_zero.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_lt.{u} α": 5,
"has_mul.{u} α": 2,
"add_comm_semigroup.{u} α": 69,
"add_group.{u} α": 1,
"right_cancel_semigroup.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_zero.{u} α": 4,
"mul_zero_class.{u} α": 1,
"preorder.{u} α": 3,
"decidable (eq.{1} name c p)": 1,
"has_add.{u} α": 4,
"has_mul.{u} α": 4,
"decidable (eq.{1} char a_tl_hd (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))": 1,
"has_sub.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"division_ring.{u} α": 2,
"has_add.{u} α": 2,
"field.{u} α": 4,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sub.{u} α": 1,
"decidable (eq.{1} name a_a_a_a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_sizeof.{u+1} α": 4,
"decidable (eq.{1} name (expr.const_name bool.tt (expr.get_app_fn bool.tt lhs)) (expr.const_name bool.tt (expr.get_app_fn bool.tt rhs)))": 1,
"has_le.{u} α": 2,
"division_ring.{u} α": 4,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"preorder.{u} α": 1,
"add_group.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_div.{u} α": 9,
"has_zero.{u} α": 1,
"has_sub.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_pure.{u v} m": 1,
"add_comm_semigroup.{u} α": 2,
"add_comm_semigroup.{u} α": 18,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_coe_t_aux.{u₂ u₃} b c": 1,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"add_group.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_dvd.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"monoid.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_mul.{0} (fin n)": 1,
"add_comm_semigroup.{u} α": 32,
"decidable (eq.{1} bool b bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_add.{u} α": 2,
"preorder.{u} α": 1,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"semigroup.{u} α": 1,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"decidable_linear_order.{u} α": 10,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"inhabited.{u+1} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))": 1,
"discrete_field.{u} α": 2,
"comm_semiring.{u} α": 4,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"add_group.{u} α": 7,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_le.{u} α": 2,
"has_le.{u} α": 1,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"decidable (has_mem.mem.{0 0} name (list.{0} name) (list.has_mem.{0} name) (expr.const_name bool.tt I) type_names)": 1,
"preorder.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_mul.{u} α": 1,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α _inst_1) a b)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"ordered_cancel_comm_monoid.{u} α": 4,
"has_lt.{0} char": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))": 1,
"has_mul.{u} α": 1,
"division_ring.{u} α": 4,
"has_mul.{u} α": 1,
"partial_order.{u} α": 1,
"has_mul.{u} α": 9,
"has_dvd.{u} α": 1,
"has_mul.{u} α": 1,
"division_ring.{u} α": 2,
"has_mul.{u} α": 2,
"has_lt.{u} α": 2,
"division_ring.{u} α": 2,
"comm_semigroup.{u} α": 2,
"comm_semiring.{u} α": 2,
"mul_zero_class.{u} α": 1,
"has_add.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))": 1,
"has_add.{u} α": 1,
"comm_semiring.{u} α": 2,
"has_one.{u} α": 1,
"decidable_linear_ordered_comm_group.{u} α": 5,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state hinst_lemmas)) (smt_tactic hinst_lemmas)": 1,
"has_mul.{u} α": 5,
"is_total_preorder.{u} α (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))))": 1,
"has_zero.{u} α": 3,
"has_inv.{u} α": 1,
"has_mul.{u} α": 2,
"has_sub.{u} α": 2,
"mul_zero_class.{u} α": 2,
"has_inv.{u} α": 1,
"has_zero.{u} α": 2,
"linear_order.{u} α": 2,
"ring.{u} α": 1,
"has_dvd.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"group.{u} α": 4,
"has_one.{u} α": 1,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"comm_semiring.{u} α": 2,
"has_add.{u} α": 2,
"discrete_field.{u} α": 2,
"has_dvd.{u} α": 2,
"add_left_cancel_semigroup.{u} α": 2,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state (list.{0} (expr bool.tt)))) (smt_tactic (list.{0} (expr bool.tt)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_one.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_mul.{u} α": 1,
"comm_semiring.{u} α": 3,
"has_inv.{u} α": 1,
"has_le.{u} α": 3,
"linear_order.{u} α": 2,
"comm_semigroup.{u} α": 11,
"subsingleton.{1} (decidable c)": 1,
"has_neg.{u} α": 2,
"ordered_comm_group.{u} α": 2,
"semigroup.{u} α": 1,
"has_mul.{u} α": 2,
"ring.{u} α": 1,
"decidable (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (division_ring.to_zero_ne_one_class.{u} α (field.to_division_ring.{u} α (discrete_field.to_field.{u} α _inst_1))))))": 1,
"has_lt.{u} α": 3,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"ordered_comm_group.{u} α": 2,
"has_mul.{u} α": 5,
"has_zero.{u} α": 1,
"has_pure.{u v} m": 1,
"has_one.{u} α": 6,
"applicative.{u v} f": 5,
"has_mul.{u} α": 10,
"has_lt.{u} α": 1,
"add_right_cancel_semigroup.{u} α": 1,
"monoid.{u} α": 1,
"has_orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))": 97,
"decidable (eq.{1} bool (expr.is_local_constant h) bool.ff)": 1,
"comm_semigroup.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"setoid.{u} α": 2,
"monoid.{u} α": 1,
"comm_semigroup.{u} α": 1,
"has_mul.{u} α": 2,
"comm_semigroup.{u} α": 3,
"has_add.{u} α": 1,
"has_dvd.{u} α": 3,
"has_le.{u} α": 4,
"has_one.{u} α": 2,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"has_neg.{u} α": 8,
"add_monoid.{u} α": 1,
"add_group.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_add.{u} α": 4,
"add_group.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 4,
"has_mul.{u} α": 2,
"comm_semiring.{u} α": 3,
"has_zero.{u} α": 6,
"has_neg.{u} α": 6,
"has_neg.{u} α": 3,
"decidable (has_lt.lt.{u} (list.{u} α) (list.has_lt.{u} α _inst_1) l₁ l₂)": 1,
"add_group.{u} α": 3,
"division_ring.{u} α": 2,
"division_ring.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_zero.{u} α": 3,
"has_le.{u} α": 3,
"has_mem.{u u} α (list.{u} α)": 2,
"add_group.{u} α": 1,
"has_lt.{u} α": 4,
"ordered_comm_group.{u} α": 2,
"decidable (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero))": 1,
"ordered_comm_group.{u} α": 2,
"has_sizeof.{u+1} α": 2,
"has_zero.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_le.{u} α": 3,
"linear_order.{u} α": 2,
"monad.{u_1 u_2} m": 1,
"add_comm_semigroup.{u} α": 3,
"has_zero.{u} α": 1,
"distrib.{u} α": 2,
"has_inv.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"comm_semigroup.{u} α": 4,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"add_group.{u} α": 1,
"decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α _inst_1)) a b)": 1,
"has_le.{u} α": 3,
"has_sizeof.{u+1} α": 4,
"has_neg.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"add_group.{u} α": 1,
"monoid.{u} α": 1,
"has_dvd.{u} α": 2,
"has_le.{u} α": 1,
"add_comm_semigroup.{u} α": 1,
"Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b))": 3,
"functor.{u v} f": 2,
"Pi (a : α) (b : α), (decidable (lt a b))": 2,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_add.{u} α": 4,
"has_lt.{u} α": 2,
"has_zero.{u} α": 2,
"semigroup.{u} α": 1,
"ring.{u} α": 4,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"Pi (a : name), (reflected.{1} name a)": 3,
"has_lt.{u} (list.{u} α)": 4,
"ordered_cancel_comm_monoid.{u} α": 4,
"comm_semigroup.{u} α": 9,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_lt.{u} α": 3,
"comm_semigroup.{u} α": 12,
"has_lt.{0} int": 58,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"is_refl.{u} α r": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_neg.{u} α": 3,
"ordered_comm_group.{u} α": 2,
"reflected.{1} (α -> (sum.{0 0} α β)) (sum.inl.{0 0} α β)": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_coe_t.{1 1} (option.{0} (expr bool.tt)) (tactic_state -> (interaction_monad.result.{0} tactic_state (expr bool.tt)))": 12,
"comm_semigroup.{u} α": 1,
"has_zero.{u} α": 3,
"has_lt.{u} α": 3,
"has_orelse.{u v} m": 1,
"has_monad_lift_t.{u u_1 (max u v)} n (reader_t.{u v} ρ m)": 1,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"add_group.{u} α": 1,
"has_sub.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_zero.{u} α": 3,
"ring.{u} α": 1,
"has_lt.{u} α": 3,
"has_append.{0} format": 118,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"Pi (a : α) (b : α), (decidable (lt a b))": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_lt.{u} α": 2,
"add_monoid.{u} α": 1,
"add_group.{u} α": 1,
"has_zero.{u} α": 2,
"has_lt.{u} α": 4,
"add_group.{u} α": 1,
"has_le.{u} α": 2,
"decidable (eq.{1} bool (list.empty.{0} name new_tag) bool.tt)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"ordered_semiring.{u} α": 2,
"ordered_comm_group.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"decidable_linear_order.{u} α": 5,
"has_neg.{u} α": 2,
"preorder.{u} α": 2,
"has_le.{u} α": 2,
"linear_ordered_semiring.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_inv.{u} α": 2,
"has_sizeof.{1} (list.{0} (option.{0} name))": 2,
"add_comm_semigroup.{u} α": 2,
"ordered_comm_group.{u} α": 2,
"add_group.{u} α": 1,
"has_le.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_neg.{u} α": 2,
"has_lt.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"add_group.{u} α": 1,
"ring.{u} α": 2,
"decidable (and (has_le.le.{0} nat nat.has_le (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))) (char.to_nat c)) (has_le.le.{0} nat nat.has_le (char.to_nat c) (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))": 1,
"reflected.{2} Type β": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"integral_domain.{u} α": 2,
"decidable (eq.{1} bool (expr.is_napp_of e (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)) (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))) bool.tt)": 1,
"has_neg.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"ordered_comm_group.{u} α": 3,
"ordered_semiring.{u} α": 6,
"has_add.{u} α": 4,
"add_group.{u} α": 1,
"has_neg.{u} α": 2,
"has_pure.{0 0} (id.{2} Type)": 1,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_lt.{u} α": 1,
"Pi (a : α) (b : α), (decidable (lt a b))": 2,
"has_sub.{u} α": 1,
"has_zero.{u} α": 1,
"add_group.{u} α": 1,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"add_group.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_mul.{u} α": 9,
"has_add.{u} α": 4,
"has_sub.{u} α": 1,
"mul_zero_class.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))": 1,
"Pi (a : α) (b : α), (decidable (lt a b))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"add_group.{u} α": 1,
"add_group.{u} α": 1,
"add_monoid.{u} α": 1,
"ordered_semiring.{u} α": 2,
"has_zero.{u} α": 1,
"has_sub.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))": 1,
"has_neg.{u} α": 2,
"add_group.{u} α": 1,
"has_mul.{u} α": 2,
"has_div.{u} α": 2,
"has_zero.{u} α": 1,
"is_symm.{u} α r": 1,
"has_mul.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_coe_t.{1 1} (reflected.{1} (user_attribute_cache_cfg punit.{1}) (user_attribute_cache_cfg.mk punit.{1} (fun (_x : list.{0} name), (has_pure.pure.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) tactic.alternative.{0})) punit.{1} punit.star.{1})) (list.nil.{0} name))) (expr bool.tt)": 1,
"has_div.{u} α": 3,
"has_mul.{u} α": 2,
"add_comm_semigroup.{u} α": 25,
"has_neg.{u} α": 1,
"ring.{u} α": 2,
"has_add.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{u+1} α": 2,
"has_neg.{u} α": 1,
"has_neg.{u} α": 2,
"distrib.{u} α": 1,
"add_group.{u} α": 1,
"mul_zero_class.{u} α": 1,
"has_mul.{u} α": 2,
"preorder.{u} α": 2,
"has_zero.{u} α": 3,
"mul_zero_class.{u} α": 1,
"has_sub.{u} α": 1,
"has_le.{u} α": 2,
"has_mul.{u} α": 12,
"mul_zero_class.{u} α": 3,
"has_lt.{u} α": 3,
"distrib.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_one.{u} α": 1,
"reflected.{1} (user_attribute hinst_lemmas punit.{1}) (user_attribute.mk hinst_lemmas punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.some.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (n : name) (_x : nat) (_x : bool), (has_orelse.orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (alternative.to_has_orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) tactic.alternative.{0}) punit.{1} (has_bind.and_then.{0 0} hinst_lemmas punit.{1} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (to_hinst_lemmas_core tactic.transparency.reducible bool.ff (list.cons.{0} name n (list.nil.{0} name)) hinst_lemmas.mk) tactic.skip) (tactic.fail.{0 0} punit.{1} format format.has_to_format (has_append.append.{0} format format.has_append (has_append.append.{0} format format.has_append (to_fmt.{0} string string.has_to_format (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (to_fmt.{0} name name.has_to_format n)) (to_fmt.{0} string string.has_to_format (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))) (option.some.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (_x : name) (_x : bool), tactic.skip)) (user_attribute_cache_cfg.mk hinst_lemmas (fun (ns : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) hinst_lemmas hinst_lemmas (to_hinst_lemmas_core tactic.transparency.reducible bool.ff ns hinst_lemmas.mk) (fun (hs₁ : hinst_lemmas), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) hinst_lemmas hinst_lemmas (merge_hinst_lemma_attrs tactic.transparency.reducible bool.ff attr_names hs₁) (merge_hinst_lemma_attrs tactic.transparency.reducible bool.tt simp_attr_names))))) (has_append.append.{0} (list.{0} name) (list.has_append.{0} name) (has_append.append.{0} (list.{0} name) (list.has_append.{0} name) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (list.nil.{0} name)) attr_names) simp_attr_names)) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))": 1,
"add_monoid.{u} α": 2,
"has_mem.{u u} α (set.{u} α)": 1,
"add_group.{u} α": 1,
"has_lt.{u} α": 3,
"has_bind.{0 v} m": 2,
"has_neg.{u} α": 2,
"has_neg.{u} α": 1,
"has_mul.{u} α": 8,
"has_neg.{u} α": 1,
"has_neg.{u} α": 2,
"has_zero.{u} α": 2,
"add_group.{u} α": 1,
"ring.{u} α": 2,
"has_le.{u} α": 4,
"has_neg.{u} α": 1,
"monad.{u v} m": 4,
"has_sub.{u} α": 1,
"has_zero.{u} α": 1,
"decidable (eq.{1} nat n (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))": 1,
"has_lt.{u} α": 2,
"decidable_linear_ordered_comm_ring.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_zero.{u} α": 1,
"has_zero.{u} α": 2,
"add_group.{u} α": 3,
"monoid.{u} α": 1,
"comm_semigroup.{u} α": 1,
"add_group.{u} α": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (lt a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_append.{0} (list.{0} smt_goal)": 3,
"has_sizeof.{u+1} α": 4,
"reflected.{1} name name.anonymous": 1,
"add_monoid.{u} α": 1,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_to_format.{0} format": 27,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul zero a) zero))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"add_group.{u} α": 4,
"add_monoid.{0} nat": 69,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_neg.{u} α": 1,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_zero.{u} α": 6,
"monad.{u v} m": 2,
"ring.{u} α": 1,
"add_comm_semigroup.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_div.{u} α": 2,
"has_add.{u} α": 2,
"has_neg.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"add_monoid.{u} α": 1,
"add_group.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state (prod.{0 0} (expr bool.ff) name))) (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state (prod.{0 0} (expr bool.ff) name)))": 1,
"has_add.{u} α": 2,
"has_neg.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"add_group.{u} α": 1,
"has_sub.{u} α": 1,
"comm_semigroup.{u} α": 2,
"preorder.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"preorder.{u} α": 2,
"add_comm_semigroup.{u} α": 1,
"division_ring.{u} α": 3,
"has_le.{u} α": 2,
"has_add.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"add_group.{u} α": 1,
"decidable_linear_ordered_comm_group.{u} α": 5,
"Pi (a : expr bool.tt), (decidable (not (has_mem.mem.{0 0} name (list.{0} name) (list.has_mem.{0} name) (expr.local_uniq_name a) hex)))": 1,
"has_lt.{u} α": 3,
"mul_zero_class.{u} α": 4,
"has_add.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sub.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"subsingleton.{1} (decidable p)": 1,
"has_sizeof.{u+1} α": 1,
"has_neg.{u} α": 2,
"has_mul.{u} α": 5,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_add.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_add.{u} α": 2,
"has_neg.{u} α": 2,
"add_group.{u} α": 3,
"has_one.{u} α": 4,
"has_zero.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_neg.{u} α": 2,
"has_append.{u} (list.{u} α)": 1,
"has_mul.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_subset.{u} (list.{u} α)": 1,
"comm_semiring.{u} α": 4,
"has_zero.{u} α": 3,
"has_mul.{u} α": 1,
"has_neg.{u} α": 1,
"has_neg.{u} α": 1,
"has_mul.{u} α": 3,
"comm_ring.{u} α": 4,
"has_one.{u} α": 3,
"has_lt.{u} α": 2,
"has_add.{u} α": 1,
"has_sub.{u} α": 1,
"add_group.{u} α": 1,
"has_mul.{u} α": 1,
"has_mul.{u} α": 1,
"has_sub.{u} α": 3,
"distrib.{u} α": 3,
"has_neg.{u} α": 1,
"has_dvd.{u} α": 2,
"field.{u} α": 2,
"comm_ring.{u} α": 2,
"has_le.{u} α": 2,
"has_neg.{u} α": 1,
"decidable (not (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero)))": 1,
"add_comm_semigroup.{u} α": 1,
"add_group.{u} α": 1,
"has_lt.{0} key": 2,
"has_sub.{u} α": 1,
"has_seq_left.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))": 2,
"comm_semigroup.{u} α": 11,
"comm_ring.{u} α": 4,
"semigroup.{u} α": 1,
"monoid.{u} α": 3,
"has_sub.{u} α": 1,
"distrib.{u} α": 5,
"ring.{u} α": 2,
"has_coe_t.{1 1} (tactic_state -> (interaction_monad.result.{0} tactic_state (expr bool.tt))) (smt_tactic (expr bool.tt))": 26,
"has_dvd.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_lt.{u} α": 1,
"comm_semiring.{u} α": 2,
"comm_semigroup.{u} α": 2,
"has_zero.{u} α": 2,
"comm_ring.{u} α": 2,
"add_monoid.{u} α": 1,
"has_neg.{u} α": 1,
"has_add.{u} α": 1,
"add_comm_semigroup.{u} α": 1,
"has_neg.{u} α": 1,
"discrete_field.{u} α": 4,
"has_add.{u} α": 2,
"has_le.{u} α": 2,
"semiring.{u} α": 1,
"has_neg.{u} α": 1,
"has_le.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_neg.{u} α": 1,
"add_group.{u} α": 1,
"has_add.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_dvd.{u} α": 3,
"has_mul.{u} α": 2,
"has_le.{u} α": 2,
"subsingleton.{1} (decidable c)": 1,
"has_le.{u} α": 2,
"has_sizeof.{1} nat": 32,
"has_add.{u} α": 1,
"discrete_field.{u} α": 1,
"comm_semiring.{u} α": 2,
"add_comm_semigroup.{u} α": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_neg.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"add_comm_semigroup.{u} α": 1,
"add_group.{u} α": 4,
"has_sizeof.{0} (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_ring.to_ordered_comm_group.{u} α (ordered_ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left zero_ne_one mul_nonneg mul_pos))))) zero one)": 1,
"is_lawful_applicative.{u v} f _inst_1": 1,
"decidable (eq.{1} name _a (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_le.{u} α": 2,
"preorder.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"reflected.{2} Type name_set": 1,
"partial_order.{u} α": 2,
"has_sub.{u} α": 1,
"has_zero.{u} α": 4,
"has_le.{u} α": 2,
"decidable (eq.{1} bool (expr.is_false t) bool.tt)": 1,
"has_add.{u} α": 1,
"comm_ring.{u} α": 2,
"ordered_comm_group.{u} α": 4,
"has_zero.{u} α": 3,
"add_comm_semigroup.{u} α": 1,
"has_add.{u} α": 3,
"ordered_comm_group.{u} α": 2,
"has_zero.{u} α": 2,
"add_comm_semigroup.{u} α": 1,
"has_sub.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_neg.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : eq.{u+1} α (mul a b) zero), (or (eq.{u+1} α a zero) (eq.{u+1} α b zero)))": 1,
"has_le.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_add.{u} α": 1,
"has_le.{u} α": 2,
"ring.{u} α": 2,
"monad.{u v} m": 2,
"has_div.{u} α": 1,
"has_sub.{u} α": 2,
"ordered_comm_group.{u} α": 4,
"monad.{u v} m": 1,
"has_le.{u} α": 2,
"has_sub.{u} α": 2,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_le.{u} α": 2,
"has_one.{u} α": 5,
"linear_ordered_field.{u} α": 4,
"has_mul.{u} α": 5,
"ordered_cancel_comm_monoid.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_neg.{u} α": 1,
"ordered_comm_group.{u} α": 3,
"has_sub.{u} α": 2,
"field.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"alternative.{u v} m": 1,
"has_neg.{u} α": 1,
"decidable (eq.{u+1} α a (has_zero.zero.{u} α (no_zero_divisors.to_has_zero.{u} α (integral_domain.to_no_zero_divisors.{u} α (discrete_field.to_integral_domain.{u} α _inst_1 _inst_1)))))": 1,
"decidable (and (has_lt.lt.{0} nat nat.has_lt (has_zero.zero.{0} nat nat.has_zero) y) (has_le.le.{0} nat nat.has_le y x))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_zero.{u} α": 3,
"linear_ordered_field.{u} α": 2,
"has_bind.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α)))": 10,
"no_zero_divisors.{u} α": 2,
"add_semigroup.{u} α": 1,
"discrete_field.{u} α": 2,
"no_zero_divisors.{u} α": 2,
"has_mul.{u} α": 8,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"has_add.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"add_group.{u} α": 1,
"has_sizeof.{u+1} α": 4,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_add.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{u+1} (α -> α)": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_zero.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"decidable (not (eq.{1} name n (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"decidable (eq.{1} name a_a_a (name.mk_string (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous))": 1,
"has_one.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_div.{u} α": 3,
"has_subset.{u} (list.{u} α)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_add.{u} α": 1,
"has_inv.{u} α": 1,
"has_sizeof.{1} cc_config": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_zero.{u} α": 3,
"add_comm_semigroup.{u} α": 2,
"has_lt.{u} α": 2,
"has_div.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sub.{u} α": 1,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_mul.{u} α": 1,
"add_comm_semigroup.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"field.{u} α": 2,
"add_group.{u} α": 3,
"has_neg.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"alternative.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))": 41,
"has_lt.{u} (list.{u} α)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_neg.{u} α": 1,
"has_zero.{u} α": 1,
"has_lt.{u} α": 2,
"has_mul.{u} α": 1,
"has_add.{u} α": 1,
"has_le.{u} α": 3,
"has_sizeof.{(max ((u+1)+1) (v+1) (w+1))} (Pi {α : Type.{u}} (a : m α), (n α))": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_add.{u} α": 1,
"has_sub.{u} α": 1,
"subsingleton.{(max (u+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_add.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"division_ring.{u} α": 2,
"has_zero.{u} α": 1,
"add_group.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_neg.{u} α": 1,
"has_sub.{u} α": 8,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_add.{u} α": 2,
"has_div.{u} α": 3,
"monad.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"decidable (eq.{1} nat j n)": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"linear_order.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_neg.{u} α": 2,
"has_equiv.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sub.{u} α": 1,
"has_div.{u} α": 1,
"has_lt.{u} α": 2,
"add_group.{u} α": 3,
"ordered_ring.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"add_group.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_div.{u} α": 2,
"has_lt.{u} α": 2,
"has_sub.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"no_zero_divisors.{u} α": 2,
"has_zero.{u} α": 2,
"has_mul.{u} α": 3,
"has_zero.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))": 1,
"has_mul.{u} α": 1,
"has_add.{u} α": 1,
"has_zero.{u} α": 4,
"has_one.{u} α": 1,
"has_mul.{u} α": 5,
"has_zero.{u} α": 1,
"has_sub.{u} α": 3,
"add_group.{u} α": 3,
"no_zero_divisors.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"add_group.{u} α": 2,
"add_monoid.{u} α": 1,
"add_group.{u} α": 1,
"linear_ordered_field.{u} α": 2,
"ring.{u} α": 1,
"has_mul.{u} α": 3,
"has_zero.{u} α": 7,
"add_group.{u} α": 1,
"has_sub.{u} α": 4,
"has_lt.{u} α": 2,
"has_add.{u} α": 1,
"monad.{u v} m": 2,
"has_mul.{u} α": 1,
"has_zero.{u} α": 1,
"has_neg.{u} α": 1,
"has_sizeof.{u+1} (α -> α)": 4,
"has_one.{u} α": 3,
"has_lt.{u} α": 2,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"ordered_comm_group.{u} α": 2,
"comm_semigroup.{u} α": 1,
"has_mul.{u} α": 2,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_mul.{u} α": 3,
"add_group.{u} α": 1,
"has_le.{u} α": 2,
"ordered_comm_group.{u} α": 2,
"integral_domain.{u} α": 2,
"decidable c": 1,
"has_bind.{0 0} (option_t.{0 0} vm_core)": 1,
"ordered_comm_group.{u} α": 2,
"has_add.{u} α": 2,
"has_to_string.{0} data": 1,
"has_lt.{u} α": 2,
"add_comm_semigroup.{u} α": 1,
"has_div.{u} α": 3,
"ordered_comm_group.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) a) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) b), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_comm_group.to_partial_order.{u} α (ordered_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left add_lt_add_left)))) (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a b)))": 1,
"has_div.{u} α": 4,
"has_lt.{u} α": 2,
"has_append.{u} (list.{u} α)": 4,
"has_add.{u} α": 1,
"has_add.{u} α": 1,
"comm_ring.{u} α": 1,
"ordered_comm_group.{u} α": 4,
"ordered_comm_group.{u} α": 2,
"decidable (not (eq.{1} name n (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"add_group.{u} α": 4,
"has_add.{u} α": 2,
"no_zero_divisors.{u} α": 2,
"monoid.{u} α": 1,
"subsingleton.{(max (u+1) 1)} (Pi (i : fin n) (a : α i) (b : α i), (decidable (eq.{u+1} (α i) a b)))": 1,
"applicative.{u_1 u_1} (id.{(u_1+1)+1} Type.{u_1})": 6,
"no_zero_divisors.{u} α": 2,
"has_div.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"decidable (eq.{1} name a_a_a_a_a_a (name.mk_string (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"ordered_cancel_comm_monoid.{u} α": 4,
"ordered_comm_group.{u} α": 2,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"zero_ne_one_class.{u} α": 1,
"has_add.{u} α": 1,
"ordered_semiring.{u} α": 2,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sub.{u} α": 1,
"has_sub.{u} α": 1,
"has_le.{u} α": 2,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_neg.{u} α": 3,
"has_mul.{u} α": 3,
"has_add.{u} α": 5,
"has_neg.{u} α": 1,
"has_lt.{u} α": 2,
"has_add.{u} α": 1,
"monoid.{u} α": 1,
"has_mul.{u} α": 2,
"has_zero.{u} α": 2,
"has_inv.{u} α": 1,
"has_add.{u} α": 1,
"preorder.{u} α": 1,
"has_zero.{u} α": 1,
"has_sub.{u} α": 1,
"ring.{u} α": 1,
"ordered_cancel_comm_monoid.{u} α": 2,
"subsingleton.{1} (decidable c)": 1,
"has_lt.{u} α": 2,
"has_lt.{u} α": 3,
"has_one.{u} α": 1,
"has_neg.{u} α": 1,
"add_comm_semigroup.{u} α": 1,
"ordered_comm_group.{u} α": 2,
"has_sub.{u} α": 2,
"ordered_semiring.{u} α": 2,
"decidable (eq.{1} bool (option.is_none.{0} name (environment.inductive_type_of env r_id)) bool.tt)": 1,
"has_to_format.{v} β": 1,
"ordered_comm_group.{u} α": 2,
"has_le.{u} α": 4,
"has_add.{u} α": 3,
"decidable (eq.{1} bool (band (expr.is_pi f) (bnot (expr.is_arrow f))) bool.tt)": 1,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"has_le.{u} α": 4,
"has_add.{u} α": 4,
"has_lift_t.{ub₁ ub₂} b₁ b₂": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"decidable (p a)": 1,
"has_sizeof.{u+1} α": 4,
"has_neg.{u} α": 2,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_mem.{u u} α (list.{u} α)": 3,
"has_le.{u} α": 2,
"add_monoid.{u} α": 1,
"has_sizeof.{u+1} (α -> α)": 4,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"reflected.{1} string acc": 1,
"has_lt.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_add.{u} α": 4,
"has_one.{u} α": 4,
"preorder.{u} α": 2,
"preorder.{u} α": 1,
"has_div.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_lt.{u} α": 5,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_one.{u} α": 3,
"has_one.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_zero.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"has_one.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_add.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"add_monoid.{u} α": 1,
"linear_order.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"subsingleton.{1} (decidable c)": 1,
"has_zero.{u} α": 2,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_one.{u} α": 2,
"functor.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_mul.{u} α": 2,
"reflected.{1} bool bool.ff": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) a b) (c : α), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α (decidable_linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total decidable_le decidable_eq decidable_lt))))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_inv.{u} α": 1,
"add_group.{u} α": 2,
"has_neg.{u} α": 17,
"no_zero_divisors.{u} α": 2,
"division_ring.{u} α": 1,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"decidable (not (eq.{1} nat n (has_zero.zero.{0} nat nat.has_zero)))": 1,
"has_mul.{u} α": 1,
"has_div.{u} α": 1,
"has_append.{u} (list.{u} α)": 4,
"has_zero.{u} α": 1,
"decidable (eq.{1} nat nparams (has_zero.zero.{0} nat nat.has_zero))": 1,
"has_inv.{u} α": 1,
"linear_ordered_semiring.{u} α": 2,
"has_one.{u} α": 1,
"has_inv.{u} α": 2,
"decidable_linear_ordered_comm_ring.{u} α": 5,
"preorder.{u} α": 1,
"has_div.{u} α": 1,
"has_one.{u} α": 3,
"has_div.{u} α": 1,
"ordered_semiring.{u} α": 2,
"has_one.{u} α": 1,
"distrib.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))": 1,
"has_one.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_div.{u} α": 1,
"has_sizeof.{(max (u+1) 1)} (α -> string)": 2,
"has_inv.{u} α": 1,
"has_add.{u} α": 1,
"has_one.{u} α": 2,
"has_mul.{0} int": 56,
"has_mul.{u} α": 1,
"has_div.{u} α": 1,
"has_mul.{u} α": 2,
"has_add.{u} α": 1,
"has_zero.{u} α": 1,
"has_one.{u} α": 1,
"ordered_semiring.{u} α": 2,
"reflected.{2} Type (user_attribute simp_lemmas punit.{1})": 1,
"has_div.{u} α": 1,
"has_one.{u} α": 3,
"add_comm_semigroup.{u} α": 1,
"semigroup.{u} α": 1,
"has_div.{u} α": 1,
"division_ring.{u} α": 1,
"has_repr.{u} α": 1,
"has_div.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))": 1,
"has_one.{u} α": 3,
"ordered_comm_group.{u} α": 4,
"has_zero.{u} α": 2,
"mul_zero_class.{u} α": 1,
"has_one.{u} α": 4,
"has_le.{u} (list.{u} α)": 1,
"has_div.{u} α": 1,
"division_ring.{u} α": 2,
"zero_ne_one_class.{u} α": 2,
"reflected.{1} (list.{0} α) (list.nil.{0} α)": 1,
"monoid.{u} α": 1,
"division_ring.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_one.{u} α": 6,
"has_inv.{u} α": 3,
"has_one.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_div.{u} α": 1,
"has_div.{u} α": 1,
"semigroup.{u} α": 1,
"has_zero.{u} α": 6,
"has_mul.{u} α": 3,
"semigroup.{u} α": 1,
"partial_order.{u} α": 4,
"has_one.{u} α": 3,
"comm_semiring.{u} α": 2,
"has_zero.{u} α": 3,
"mul_zero_class.{u} α": 1,
"decidable_linear_order.{0} nat": 31,
"has_mul.{u} α": 6,
"has_one.{u} α": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_mul.{u} α": 5,
"zero_ne_one_class.{u} α": 2,
"monoid.{u} α": 1,
"division_ring.{u} α": 1,
"mul_zero_class.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"division_ring.{u} α": 1,
"is_trans.{u} α (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (decidable_linear_order.to_linear_order.{u} α _inst_1)))))": 1,
"zero_ne_one_class.{u} α": 2,
"division_ring.{u} α": 2,
"has_neg.{u} α": 4,
"mul_zero_class.{u} α": 1,
"has_div.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"semigroup.{u} α": 2,
"division_ring.{u} α": 6,
"has_mul.{u} α": 1,
"monoid.{u} α": 1,
"right_cancel_semigroup.{u} α": 2,
"decidable (has_mem.mem.{0 0} nat (list.{0} nat) (list.has_mem.{0} nat) p ps)": 1,
"division_ring.{u} α": 3,
"semigroup.{u} α": 1,
"has_sizeof.{u+1} (α -> α -> α)": 2,
"add_group.{u} α": 1,
"ring.{u} α": 1,
"has_div.{u} α": 13,
"has_zero.{u} α": 1,
"ordered_ring.{u} α": 4,
"has_repr.{0} (list.{0} nat)": 2,
"distrib.{u} α": 1,
"has_sizeof.{u+1} α": 2,
"Pi (a : char) (b : char), (decidable (has_lt.lt.{0} char char.has_lt a b))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"add_group.{u} α": 4,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_mul.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"ordered_semiring.{u} α": 2,
"has_sizeof.{0} (or (has_lt.lt.{0} nat nat.has_lt val (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))) (and (has_lt.lt.{0} nat nat.has_lt (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))))) val) (has_lt.lt.{0} nat nat.has_lt val (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))))))))))))))))))": 1,
"has_neg.{u} α": 11,
"zero_ne_one_class.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_div.{u} α": 2,
"is_asymm.{u} α r": 1,
"has_one.{u} α": 5,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_div.{u} α": 2,
"has_seq.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"has_zero.{u} α": 1,
"has_one.{u} α": 2,
"has_div.{u} α": 2,
"division_ring.{u} α": 4,
"reflected.{1} (list.{0} (option.{0} name)) _p.1": 1,
"has_zero.{u} α": 1,
"ordered_semiring.{0} nat": 21,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (mul a zero) zero))": 1,
"division_ring.{u} α": 1,
"add_group.{u} α": 1,
"has_sub.{u} α": 1,
"has_div.{u} α": 2,
"division_ring.{u} α": 5,
"preorder.{u} α": 4,
"division_ring.{u} α": 4,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"has_inv.{u} α": 8,
"Pi (a : list.{0} name), (reflected.{1} (list.{0} name) a)": 34,
"has_one.{u} α": 4,
"ordered_cancel_comm_monoid.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) c b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_mem.{u u} α (list.{u} α)": 1,
"has_div.{u} α": 14,
"has_lift_t.{u v} a b": 1,
"division_ring.{u} α": 9,
"ordered_comm_group.{u} α": 2,
"has_zero.{u} α": 5,
"monoid.{u} α": 1,
"has_lt.{u} α": 1,
"has_div.{u} α": 2,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))": 1,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_mul.{u} α": 1,
"has_div.{u} α": 1,
"has_mul.{u} α": 1,
"has_div.{u} α": 3,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"has_zero.{u} α": 1,
"has_div.{u} α": 3,
"has_monad_lift_t.{u_1 u_2 u_3} m n": 1,
"has_zero.{u} α": 2,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))": 2,
"preorder.{u} α": 2,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (has_lt.lt.{u} α (preorder.to_has_lt.{u} α (partial_order.to_preorder.{u} α (linear_order.to_partial_order.{u} α (linear_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm le_total)))) a b)))": 1,
"has_zero.{u} α": 2,
"linear_ordered_field.{u} α": 1,
"has_coe_t.{1 1} (reflected.{1} (user_attribute hinst_lemmas punit.{1}) (user_attribute.mk hinst_lemmas punit.{1} attr_name (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.some.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (n : name) (_x : nat) (_x : bool), (has_orelse.orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (alternative.to_has_orelse.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) tactic.alternative.{0}) punit.{1} (has_bind.and_then.{0 0} hinst_lemmas punit.{1} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (to_hinst_lemmas_core tactic.transparency.reducible bool.ff (list.cons.{0} name n (list.nil.{0} name)) hinst_lemmas.mk) tactic.skip) (tactic.fail.{0 0} punit.{1} format format.has_to_format (has_append.append.{0} format format.has_append (has_append.append.{0} format format.has_append (to_fmt.{0} string string.has_to_format (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (to_fmt.{0} name name.has_to_format n)) (to_fmt.{0} string string.has_to_format (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))))))))) (option.some.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1})) (fun (_x : name) (_x : bool), tactic.skip)) (user_attribute_cache_cfg.mk hinst_lemmas (fun (ns : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) hinst_lemmas hinst_lemmas (to_hinst_lemmas_core tactic.transparency.reducible bool.ff ns hinst_lemmas.mk) (fun (hs₁ : hinst_lemmas), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) hinst_lemmas hinst_lemmas (merge_hinst_lemma_attrs tactic.transparency.reducible bool.ff attr_names hs₁) (merge_hinst_lemma_attrs tactic.transparency.reducible bool.tt simp_attr_names))))) (has_append.append.{0} (list.{0} name) (list.has_append.{0} name) (has_append.append.{0} (list.{0} name) (list.has_append.{0} name) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (list.nil.{0} name)) attr_names) simp_attr_names)) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))) (expr bool.tt)": 1,
"has_sub.{u} α": 2,
"has_mul.{u} α": 2,
"has_mul.{u} α": 2,
"has_le.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (iff (lt a b) (and (le a b) (not (le b a)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (add (add a b) c) (add a (add b c))))": 1,
"distrib.{u} α": 2,
"has_sizeof.{u+1} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_dvd.{u} α": 6,
"division_ring.{u} α": 4,
"has_sizeof.{u+1} α": 4,
"has_add.{u} α": 3,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"ordered_comm_group.{u} α": 2,
"has_neg.{u} α": 2,
"monoid.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"monoid.{u} α": 2,
"semigroup.{u} α": 1,
"decidable c": 1,
"has_zero.{u} α": 1,
"has_div.{u} α": 1,
"has_pure.{u (max u v)} (state_t.{u v} σ m)": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"division_ring.{u} α": 2,
"linear_order.{u} α": 2,
"no_zero_divisors.{u} α": 2,
"has_zero.{u} α": 2,
"has_mul.{u} α": 2,
"has_zero.{u} α": 4,
"division_ring.{u} α": 2,
"has_mul.{u} α": 1,
"division_ring.{u} α": 2,
"division_ring.{u} α": 2,
"decidable (eq.{1} bool matched bool.tt)": 1,
"has_zero.{u} α": 1,
"has_zero.{u} α": 1,
"has_div.{u} α": 1,
"field.{u} α": 2,
"setoid.{u_a} α": 7,
"has_one.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (or (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b a)))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero))) (neg a) a) (has_zero.zero.{u} α (add_monoid.to_has_zero.{u} α (add_monoid.mk.{u} α add add_assoc zero zero_add add_zero)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_sizeof.{u+1} α": 1,
"add_comm_semigroup.{u} α": 13,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_le.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_mul.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"decidable (eq.{1} bool (expr.has_var_idx b (has_zero.zero.{0} nat nat.has_zero)) bool.tt)": 1,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"decidable_linear_order.{u} α": 1,
"decidable q": 2,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"ordered_semiring.{u} α": 4,
"division_ring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a b) (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) b a)))": 1,
"has_zero.{u} α": 7,
"has_div.{u} α": 6,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"functor.{u v} (except_t.{u v} ε m)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"monad.{u v} m": 55,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : le a b) (a_1 : le b c), (le a c))": 1,
"has_inv.{u} α": 1,
"has_div.{u} α": 2,
"monoid.{u} α": 1,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) a (inv a)) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"subsingleton.{(max (u_1+1) 1)} (Pi (a : α), (decidable (p a)))": 1,
"has_dvd.{0} nat": 30,
"add_group.{u} α": 4,
"has_lt.{u} α": 2,
"comm_semigroup.{u} α": 1,
"has_mul.{u} α": 2,
"has_lt.{u} α": 2,
"has_one.{u} α": 3,
"Pi (a : nat) (b : nat), (decidable (has_lt.lt.{0} nat nat.has_lt a b))": 1,
"division_ring.{u} α": 2,
"semiring.{u} α": 2,
"monoid.{u} α": 2,
"has_one.{u} α": 1,
"division_ring.{u} α": 2,
"has_zero.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (monoid.to_semigroup.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one))) (inv a) a) (has_one.one.{u} α (monoid.to_has_one.{u} α (monoid.mk.{u} α mul mul_assoc one one_mul mul_one)))))": 1,
"has_mul.{u} α": 1,
"has_sizeof.{0} (eq.{u+1} α (inv zero) zero)": 1,
"has_zero.{u} α": 1,
"has_zero.{u} α": 1,
"has_div.{u} α": 1,
"has_mul.{u} α": 1,
"has_mul.{u} α": 1,
"has_neg.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a zero) a))": 1,
"semigroup.{u} α": 1,
"has_lt.{u} α": 2,
"comm_semigroup.{u} α": 1,
"semigroup.{u} α": 1,
"comm_semigroup.{u} α": 1,
"has_lift_t.{ua₁+1 ua₂+1} a₁ a₂": 1,
"has_div.{u} α": 3,
"has_one.{u} α": 2,
"monad.{u v} m": 55,
"decidable (p a)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_comm_monoid.to_add_monoid.{u} α (add_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm)))) a c)), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) b c))": 1,
"comm_semigroup.{u} α": 1,
"group.{u} α": 2,
"has_div.{u} α": 3,
"has_mul.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"decidable b": 1,
"has_sub.{u} α": 2,
"comm_semigroup.{u} α": 1,
"has_zero.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) a b) (c : α), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (partial_order.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le le_antisymm))) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c a) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_monoid.to_add_semigroup.{u} α (add_group.to_add_monoid.{u} α (add_comm_group.to_add_group.{u} α (add_comm_group.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm))))) c b)))": 1,
"has_div.{u} α": 2,
"decidable_linear_ordered_comm_group.{u} α": 1,
"has_add.{u} α": 5,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) a one) a))": 1,
"has_div.{u} α": 2,
"division_ring.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_zero.{u} α": 2,
"monoid.{u} α": 1,
"has_div.{u} α": 2,
"has_le.{u} α": 2,
"has_zero.{u} α": 1,
"has_sizeof.{(imax u v)} (a -> S)": 1,
"has_mul.{u} α": 2,
"has_zero.{u} α": 2,
"has_zero.{u} α": 2,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"add_group.{u} α": 3,
"has_add.{u} α": 2,
"field.{u} α": 3,
"has_one.{u} α": 3,
"has_mul.{u} α": 2,
"decidable (eq.{1} bool (_private.477865211.is_delta_target e cs) bool.tt)": 1,
"monoid.{u} α": 2,
"zero_ne_one_class.{u} α": 1,
"has_zero.{u} α": 2,
"has_sub.{u} α": 2,
"has_add.{u} α": 3,
"has_zero.{u} α": 2,
"has_div.{u} α": 2,
"division_ring.{u} α": 11,
"has_add.{u} α": 1,
"comm_semigroup.{u} α": 35,
"has_div.{u} α": 3,
"comm_semigroup.{u} α": 1,
"division_ring.{u} α": 1,
"field.{u} α": 2,
"functor.{u_1 u_1} set.{u_1}": 1,
"has_inv.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"has_mul.{u} α": 2,
"decidable (has_le.le.{0} nat nat.has_le m n)": 1,
"has_lt.{u} α": 6,
"add_comm_semigroup.{u} α": 54,
"has_zero.{u} α": 1,
"has_sizeof.{(max (u+1) 1)} (Pi (a : α) (b : α), (decidable (eq.{u+1} α a b)))": 2,
"division_ring.{u} α": 1,
"has_zero.{u} α": 1,
"field.{u} α": 3,
"decidable (or (eq.{1} bool (list.empty.{0} name ids) bool.tt) (eq.{1} name (list.head.{0} name name.inhabited ids) (name.mk_string (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous)))": 1,
"has_lt.{u} α": 3,
"monoid.{u} α": 1,
"has_neg.{u} α": 2,
"division_ring.{u} α": 5,
"mul_zero_class.{u} α": 1,
"has_coe_t.{1 1} (reflected.{1} (user_attribute hinst_lemmas punit.{1}) (user_attribute.mk hinst_lemmas punit.{1} attr_name (has_append.append.{0} string string.has_append (has_append.append.{0} string string.has_append (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one)))))))) (to_string.{0} name name.has_to_string simp_attr_name)) (string.str string.empty (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (option.none.{0} (name -> nat -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (option.none.{0} (name -> bool -> tactic_state -> (interaction_monad.result.{0} tactic_state punit.{1}))) (user_attribute_cache_cfg.mk hinst_lemmas (fun (ns : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) hinst_lemmas hinst_lemmas (_private.787519257.to_hinst_lemmas tactic.transparency.reducible mk_name_set ns hinst_lemmas.mk) (fun (hs : hinst_lemmas), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) (list.{0} name) hinst_lemmas (attribute.get_instances simp_attr_name) (fun (ss : list.{0} name), (has_bind.bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (monad.to_has_bind.{0 0} (fun (α : Type), (tactic_state -> (interaction_monad.result.{0} tactic_state α))) (interaction_monad.monad.{0} tactic_state)) name_set hinst_lemmas (get_name_set_for_attr ex_attr_name) (fun (ex : name_set), (_private.787519257.to_hinst_lemmas tactic.transparency.reducible ex ss hs)))))))) (list.cons.{0} name (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (bit1.{0} nat nat.has_one nat.has_add (bit0.{0} nat nat.has_add (bit0.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one))))))))) name.anonymous) (list.cons.{0} name simp_attr_name (list.nil.{0} name)))) punit.reflect (has_pure.pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (applicative.to_has_pure.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) (alternative.to_applicative.{0 0} (fun (α : Type), (lean.parser_state -> (interaction_monad.result.{0} lean.parser_state α))) lean.parser.alternative)) punit.{1} punit.star.{1}))) (expr bool.tt)": 1,
"division_ring.{u} α": 1,
"field.{u} α": 2,
"semigroup.{u} α": 2,
"has_sizeof.{u+1} (α -> α)": 4,
"has_sizeof.{u+1} (α -> α -> α)": 4,
"decidable (eq.{1} nat (environment.inductive_num_indices env I_name) (has_zero.zero.{0} nat nat.has_zero))": 1,
"has_sizeof.{u+1} α": 4,
"has_sizeof.{0} (not (eq.{u+1} α zero one))": 1,
"has_neg.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_sizeof.{0} (Pi {a : α} (a_1 : not (eq.{u+1} α a (has_zero.zero.{u} α (zero_ne_one_class.to_has_zero.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one))))), (eq.{u+1} α (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (ring.to_semiring.{u} α (ring.mk.{u} α add add_assoc zero zero_add add_zero neg add_left_neg add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib)))) (inv a) a) (has_one.one.{u} α (zero_ne_one_class.to_has_one.{u} α (zero_ne_one_class.mk.{u} α zero one zero_ne_one)))))": 1,
"add_comm_semigroup.{u} α": 10,
"has_pure.{u v} m": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (add a b) c) (add (mul a c) (mul b c))))": 1,
"monad.{u v} m": 2,
"has_sizeof.{0} (eq.{u+1} α (inv zero) zero)": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a c)), (eq.{u+1} α b c))": 1,
"has_le.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) c b)), (eq.{u+1} α a c))": 1,
"has_sizeof.{(max (u+1) 1)} (α -> α -> Prop)": 4,
"monoid.{u} α": 1,
"has_sizeof.{0} (Pi (a : α), (le a a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul (mul a b) c) (mul a (mul b c))))": 1,
"ordered_comm_group.{u} α": 2,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_mul.mul.{u} α (semigroup.to_has_mul.{u} α (semigroup.mk.{u} α mul mul_assoc)) one a) a))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))": 1,
"add_group.{u} α": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) a b) (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) b a)))": 1,
"has_div.{u} α": 2,
"setoid.{u_c} φ": 2,
"has_sizeof.{0} (Pi (a : α) (b : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (preorder.mk.{u} α le lt le_refl le_trans lt_iff_le_not_le)) b a), (eq.{u+1} α a b))": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c a) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) c b)))": 1,
"decidable (has_lt.lt.{u} α _inst_1 (prod.fst.{u v} α β t) (prod.fst.{u v} α β s))": 1,
"has_neg.{u} α": 1,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) a b) (a_1 : has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_zero.zero.{u} α (mul_zero_class.to_has_zero.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero)))) c), (has_le.le.{u} α (preorder.to_has_le.{u} α (partial_order.to_preorder.{u} α (ordered_cancel_comm_monoid.to_partial_order.{u} α (ordered_cancel_comm_monoid.mk.{u} α add add_assoc zero zero_add add_zero add_comm add_left_cancel add_right_cancel le lt le_refl le_trans lt_iff_le_not_le le_antisymm add_le_add_left le_of_add_le_add_left)))) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) a c) (has_mul.mul.{u} α (mul_zero_class.to_has_mul.{u} α (semiring.to_mul_zero_class.{u} α (semiring.mk.{u} α add add_assoc zero zero_add add_zero add_comm mul mul_assoc one one_mul mul_one left_distrib right_distrib zero_mul mul_zero))) b c)))": 1,
"monoid.{u} α": 1,
"subsingleton.{1} (decidable c)": 1,
"division_ring.{u} α": 2,
"has_zero.{u} α": 8,
"monad_functor_t.{u u_1 v} n n' (option_t.{u v} m) (option_t.{u v} m')": 1,
"has_sizeof.{0} (Pi (a : α), (eq.{u+1} α (has_add.add.{u} α (add_semigroup.to_has_add.{u} α (add_semigroup.mk.{u} α add add_assoc)) zero a) a))": 1,
"has_one.{u} α": 6,
"applicative.{u v} m": 3,
"has_zero.{u} α": 2,
"has_zero.{u} α": 3,
"has_sizeof.{0} (Pi (a : α) (b : α) (c : α), (eq.{u+1} α (mul a (add b c)) (add (mul a b) (mul a c))))": 1,
"has_div.{u} α": 1}}