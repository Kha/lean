strict digraph  {
inhabited [shape=box];
nonempty [shape=box];
setoid [shape=box];
has_equiv [shape=box];
has_sizeof [shape=box];
has_well_founded [shape=box];
has_lift [shape=box];
has_lift_t [shape=box];
has_coe [shape=box];
has_coe_t [shape=box];
has_coe_t_aux [shape=box];
is_commutative [shape=box];
is_symm_op [shape=box];
is_preorder [shape=box];
is_refl [shape=box];
is_trans [shape=box];
is_total_preorder [shape=box];
is_total [shape=box];
is_partial_order [shape=box];
is_antisymm [shape=box];
is_linear_order [shape=box];
is_equiv [shape=box];
is_symm [shape=box];
is_per [shape=box];
is_strict_order [shape=box];
is_irrefl [shape=box];
is_strict_weak_order [shape=box];
is_incomp_trans [shape=box];
is_strict_total_order [shape=box];
is_trichotomous [shape=box];
preorder [shape=box];
has_le [shape=box];
has_lt [shape=box];
applicative [shape=box];
functor [shape=box];
has_pure [shape=box];
has_seq [shape=box];
has_seq_left [shape=box];
has_seq_right [shape=box];
partial_order [shape=box];
monad [shape=box];
has_bind [shape=box];
linear_order [shape=box];
alternative [shape=box];
has_orelse [shape=box];
decidable_linear_order [shape=box];
has_to_format [shape=box];
has_to_tactic_format [shape=box];
semigroup [shape=box];
has_mul [shape=box];
comm_semigroup [shape=box];
left_cancel_semigroup [shape=box];
right_cancel_semigroup [shape=box];
monoid [shape=box];
has_one [shape=box];
comm_monoid [shape=box];
group [shape=box];
has_inv [shape=box];
comm_group [shape=box];
add_semigroup [shape=box];
has_add [shape=box];
add_comm_semigroup [shape=box];
add_left_cancel_semigroup [shape=box];
add_right_cancel_semigroup [shape=box];
add_monoid [shape=box];
has_zero [shape=box];
add_comm_monoid [shape=box];
add_group [shape=box];
has_neg [shape=box];
add_comm_group [shape=box];
has_sub [shape=box];
distrib [shape=box];
mul_zero_class [shape=box];
zero_ne_one_class [shape=box];
ordered_cancel_comm_monoid [shape=box];
semiring [shape=box];
comm_semiring [shape=box];
has_dvd [shape=box];
ordered_comm_group [shape=box];
ring [shape=box];
comm_ring [shape=box];
no_zero_divisors [shape=box];
integral_domain [shape=box];
division_ring [shape=box];
decidable_linear_ordered_comm_group [shape=box];
decidable_linear_ordered_cancel_comm_monoid [shape=box];
field [shape=box];
discrete_field [shape=box];
ordered_semiring [shape=box];
linear_ordered_semiring [shape=box];
decidable_linear_ordered_semiring [shape=box];
ordered_ring [shape=box];
linear_ordered_ring [shape=box];
linear_ordered_comm_ring [shape=box];
decidable_linear_ordered_comm_ring [shape=box];
linear_ordered_field [shape=box];
discrete_linear_ordered_field [shape=box];
unique [shape=box];
subsingleton [shape=box];
traversable [shape=box];
"category_theory.category_struct" [shape=box];
"category_theory.has_hom" [shape=box];
"category_theory.category" [shape=box];
bitraversable [shape=box];
bifunctor [shape=box];
"category_theory.groupoid" [shape=box];
"category_theory.is_iso" [shape=box];
"is_strict_total_order'" [shape=box];
is_order_connected [shape=box];
is_extensional [shape=box];
is_well_order [shape=box];
is_asymm [shape=box];
directed_order [shape=box];
"lattice.semilattice_sup" [shape=box];
"lattice.has_sup" [shape=box];
"lattice.semilattice_inf" [shape=box];
"lattice.has_inf" [shape=box];
"lattice.lattice" [shape=box];
"lattice.distrib_lattice" [shape=box];
"lattice.order_top" [shape=box];
"lattice.has_top" [shape=box];
"lattice.order_bot" [shape=box];
"lattice.has_bot" [shape=box];
"lattice.semilattice_sup_top" [shape=box];
"lattice.semilattice_sup_bot" [shape=box];
"lattice.semilattice_inf_top" [shape=box];
"lattice.semilattice_inf_bot" [shape=box];
"lattice.bounded_lattice" [shape=box];
"lattice.bounded_distrib_lattice" [shape=box];
"category_theory.concrete_category" [shape=box];
"lattice.boolean_algebra" [shape=box];
ordered_comm_monoid [shape=box];
"lattice.complete_lattice" [shape=box];
"lattice.has_Sup" [shape=box];
"lattice.has_Inf" [shape=box];
canonically_ordered_monoid [shape=box];
"lattice.complete_linear_order" [shape=box];
nonzero_comm_semiring [shape=box];
nonzero_comm_ring [shape=box];
domain [shape=box];
has_div [shape=box];
"lattice.complete_distrib_lattice" [shape=box];
"lattice.complete_boolean_algebra" [shape=box];
nonneg_comm_group [shape=box];
char_zero [shape=box];
no_top_order [shape=box];
no_bot_order [shape=box];
nonneg_ring [shape=box];
linear_nonneg_ring [shape=box];
canonically_ordered_comm_semiring [shape=box];
densely_ordered [shape=box];
euclidean_domain [shape=box];
has_mod [shape=box];
"category_theory.limits.has_limits" [shape=box];
"category_theory.limits.has_colimits" [shape=box];
normalization_domain [shape=box];
gcd_domain [shape=box];
fintype [shape=box];
infinite [shape=box];
denumerable [shape=box];
encodable [shape=box];
"lattice.conditionally_complete_lattice" [shape=box];
"lattice.conditionally_complete_linear_order" [shape=box];
"lattice.conditionally_complete_linear_order_bot" [shape=box];
primcodable [shape=box];
uniform_space [shape=box];
topological_space [shape=box];
semimodule [shape=box];
module [shape=box];
manifold [shape=box];
vector_space [shape=box];
has_groupoid [shape=box];
emetric_space [shape=box];
has_edist [shape=box];
separated [shape=box];
"topological_space.first_countable_topology" [shape=box];
add_group_with_zero_nhd [shape=box];
topological_add_monoid [shape=box];
topological_add_group [shape=box];
metric_space [shape=box];
has_dist [shape=box];
premetric_space [shape=box];
local_ring [shape=box];
algebra [shape=box];
normed_group [shape=box];
has_norm [shape=box];
uniform_add_group [shape=box];
normed_ring [shape=box];
topological_monoid [shape=box];
topological_ring [shape=box];
normed_field [shape=box];
nondiscrete_normed_field [shape=box];
normed_space [shape=box];
measurable_space [shape=box];
principal_ideal_domain [shape=box];
"ideal.is_principal" [shape=box];
sequential_space [shape=box];
is_noetherian_ring [shape=box];
inner_product_space [shape=box];
has_inner [shape=box];
"measure_theory.measure_space" [shape=box];
inhabited -> nonempty;
setoid -> has_equiv;
has_sizeof -> has_well_founded;
has_lift -> has_lift_t;
has_coe -> has_coe_t;
has_coe -> has_coe_t_aux;
has_coe_t -> has_lift_t;
is_commutative -> is_symm_op;
is_preorder -> is_refl;
is_preorder -> is_trans;
is_total_preorder -> is_trans;
is_total_preorder -> is_total;
is_total_preorder -> is_preorder;
is_partial_order -> is_preorder;
is_partial_order -> is_antisymm;
is_linear_order -> is_partial_order;
is_linear_order -> is_total;
is_equiv -> is_preorder;
is_equiv -> is_symm;
is_per -> is_symm;
is_per -> is_trans;
is_strict_order -> is_irrefl;
is_strict_order -> is_trans;
is_strict_weak_order -> is_strict_order;
is_strict_weak_order -> is_incomp_trans;
is_strict_total_order -> is_trichotomous;
is_strict_total_order -> is_strict_weak_order;
preorder -> has_le;
preorder -> has_lt;
preorder -> "category_theory.category";
applicative -> functor;
applicative -> has_pure;
applicative -> has_seq;
applicative -> has_seq_left;
applicative -> has_seq_right;
partial_order -> preorder;
monad -> applicative;
monad -> has_bind;
linear_order -> partial_order;
alternative -> applicative;
alternative -> has_orelse;
decidable_linear_order -> linear_order;
decidable_linear_order -> "lattice.lattice";
decidable_linear_order -> "lattice.distrib_lattice";
has_to_format -> has_to_tactic_format;
semigroup -> has_mul;
comm_semigroup -> semigroup;
left_cancel_semigroup -> semigroup;
right_cancel_semigroup -> semigroup;
monoid -> semigroup;
monoid -> has_one;
comm_monoid -> monoid;
comm_monoid -> comm_semigroup;
group -> monoid;
group -> has_inv;
group -> left_cancel_semigroup;
group -> right_cancel_semigroup;
comm_group -> group;
comm_group -> comm_monoid;
add_semigroup -> has_add;
add_comm_semigroup -> add_semigroup;
add_left_cancel_semigroup -> add_semigroup;
add_right_cancel_semigroup -> add_semigroup;
add_monoid -> add_semigroup;
add_monoid -> has_zero;
add_comm_monoid -> add_monoid;
add_comm_monoid -> add_comm_semigroup;
add_group -> add_monoid;
add_group -> has_neg;
add_group -> add_left_cancel_semigroup;
add_group -> add_right_cancel_semigroup;
add_group -> has_sub;
add_comm_group -> add_group;
add_comm_group -> add_comm_monoid;
distrib -> has_mul;
distrib -> has_add;
mul_zero_class -> has_mul;
mul_zero_class -> has_zero;
zero_ne_one_class -> has_zero;
zero_ne_one_class -> has_one;
ordered_cancel_comm_monoid -> add_comm_monoid;
ordered_cancel_comm_monoid -> add_left_cancel_semigroup;
ordered_cancel_comm_monoid -> add_right_cancel_semigroup;
ordered_cancel_comm_monoid -> partial_order;
ordered_cancel_comm_monoid -> ordered_comm_monoid;
semiring -> add_comm_monoid;
semiring -> monoid;
semiring -> distrib;
semiring -> mul_zero_class;
semiring -> semimodule;
comm_semiring -> semiring;
comm_semiring -> comm_monoid;
comm_semiring -> has_dvd;
ordered_comm_group -> add_comm_group;
ordered_comm_group -> partial_order;
ordered_comm_group -> ordered_cancel_comm_monoid;
ring -> add_comm_group;
ring -> monoid;
ring -> distrib;
ring -> semiring;
ring -> module;
comm_ring -> ring;
comm_ring -> comm_semigroup;
comm_ring -> comm_semiring;
comm_ring -> algebra;
no_zero_divisors -> has_mul;
no_zero_divisors -> has_zero;
integral_domain -> comm_ring;
integral_domain -> no_zero_divisors;
integral_domain -> zero_ne_one_class;
integral_domain -> nonzero_comm_ring;
integral_domain -> domain;
division_ring -> ring;
division_ring -> has_inv;
division_ring -> zero_ne_one_class;
division_ring -> has_div;
division_ring -> domain;
decidable_linear_ordered_comm_group -> add_comm_group;
decidable_linear_ordered_comm_group -> decidable_linear_order;
decidable_linear_ordered_comm_group -> ordered_comm_group;
decidable_linear_ordered_comm_group -> decidable_linear_ordered_cancel_comm_monoid;
decidable_linear_ordered_cancel_comm_monoid -> ordered_cancel_comm_monoid;
decidable_linear_ordered_cancel_comm_monoid -> decidable_linear_order;
field -> division_ring;
field -> comm_ring;
field -> integral_domain;
discrete_field -> field;
discrete_field -> euclidean_domain;
discrete_field -> vector_space;
discrete_field -> local_ring;
ordered_semiring -> semiring;
ordered_semiring -> ordered_cancel_comm_monoid;
linear_ordered_semiring -> ordered_semiring;
linear_ordered_semiring -> linear_order;
linear_ordered_semiring -> char_zero;
linear_ordered_semiring -> no_top_order;
decidable_linear_ordered_semiring -> linear_ordered_semiring;
decidable_linear_ordered_semiring -> decidable_linear_order;
ordered_ring -> ring;
ordered_ring -> ordered_comm_group;
ordered_ring -> zero_ne_one_class;
ordered_ring -> ordered_semiring;
linear_ordered_ring -> ordered_ring;
linear_ordered_ring -> linear_order;
linear_ordered_ring -> linear_ordered_semiring;
linear_ordered_ring -> no_bot_order;
linear_ordered_ring -> domain;
linear_ordered_comm_ring -> linear_ordered_ring;
linear_ordered_comm_ring -> comm_monoid;
linear_ordered_comm_ring -> integral_domain;
decidable_linear_ordered_comm_ring -> linear_ordered_comm_ring;
decidable_linear_ordered_comm_ring -> decidable_linear_ordered_comm_group;
decidable_linear_ordered_comm_ring -> decidable_linear_ordered_semiring;
linear_ordered_field -> linear_ordered_ring;
linear_ordered_field -> field;
linear_ordered_field -> densely_ordered;
linear_ordered_field -> no_top_order;
linear_ordered_field -> no_bot_order;
discrete_linear_ordered_field -> linear_ordered_field;
discrete_linear_ordered_field -> decidable_linear_ordered_comm_ring;
discrete_linear_ordered_field -> discrete_field;
unique -> inhabited;
unique -> subsingleton;
unique -> fintype;
traversable -> functor;
"category_theory.category_struct" -> "category_theory.has_hom";
"category_theory.category" -> "category_theory.category_struct";
bitraversable -> bifunctor;
"category_theory.groupoid" -> "category_theory.category";
"category_theory.groupoid" -> "category_theory.is_iso";
"is_strict_total_order'" -> is_trichotomous;
"is_strict_total_order'" -> is_strict_order;
"is_strict_total_order'" -> is_order_connected;
"is_strict_total_order'" -> is_strict_total_order;
"is_strict_total_order'" -> is_extensional;
is_well_order -> "is_strict_total_order'";
is_well_order -> is_strict_total_order;
is_well_order -> is_extensional;
is_well_order -> is_trichotomous;
is_well_order -> is_trans;
is_well_order -> is_irrefl;
is_well_order -> is_asymm;
directed_order -> preorder;
"lattice.semilattice_sup" -> "lattice.has_sup";
"lattice.semilattice_sup" -> partial_order;
"lattice.semilattice_inf" -> "lattice.has_inf";
"lattice.semilattice_inf" -> partial_order;
"lattice.lattice" -> "lattice.semilattice_sup";
"lattice.lattice" -> "lattice.semilattice_inf";
"lattice.distrib_lattice" -> "lattice.lattice";
"lattice.order_top" -> "lattice.has_top";
"lattice.order_top" -> partial_order;
"lattice.order_bot" -> "lattice.has_bot";
"lattice.order_bot" -> partial_order;
"lattice.semilattice_sup_top" -> "lattice.order_top";
"lattice.semilattice_sup_top" -> "lattice.semilattice_sup";
"lattice.semilattice_sup_bot" -> "lattice.order_bot";
"lattice.semilattice_sup_bot" -> "lattice.semilattice_sup";
"lattice.semilattice_inf_top" -> "lattice.order_top";
"lattice.semilattice_inf_top" -> "lattice.semilattice_inf";
"lattice.semilattice_inf_bot" -> "lattice.order_bot";
"lattice.semilattice_inf_bot" -> "lattice.semilattice_inf";
"lattice.bounded_lattice" -> "lattice.lattice";
"lattice.bounded_lattice" -> "lattice.order_top";
"lattice.bounded_lattice" -> "lattice.order_bot";
"lattice.bounded_lattice" -> "lattice.semilattice_inf_top";
"lattice.bounded_lattice" -> "lattice.semilattice_inf_bot";
"lattice.bounded_lattice" -> "lattice.semilattice_sup_top";
"lattice.bounded_lattice" -> "lattice.semilattice_sup_bot";
"lattice.bounded_distrib_lattice" -> "lattice.distrib_lattice";
"lattice.bounded_distrib_lattice" -> "lattice.bounded_lattice";
"category_theory.concrete_category" -> "category_theory.category";
"lattice.boolean_algebra" -> "lattice.bounded_distrib_lattice";
"lattice.boolean_algebra" -> has_neg;
"lattice.boolean_algebra" -> has_sub;
ordered_comm_monoid -> add_comm_monoid;
ordered_comm_monoid -> partial_order;
"lattice.complete_lattice" -> "lattice.bounded_lattice";
"lattice.complete_lattice" -> "lattice.has_Sup";
"lattice.complete_lattice" -> "lattice.has_Inf";
"lattice.complete_lattice" -> "category_theory.limits.has_limits";
"lattice.complete_lattice" -> "category_theory.limits.has_colimits";
"lattice.complete_lattice" -> "lattice.conditionally_complete_lattice";
canonically_ordered_monoid -> ordered_comm_monoid;
canonically_ordered_monoid -> "lattice.order_bot";
"lattice.complete_linear_order" -> "lattice.complete_lattice";
"lattice.complete_linear_order" -> decidable_linear_order;
"lattice.complete_linear_order" -> "lattice.conditionally_complete_linear_order";
nonzero_comm_semiring -> comm_semiring;
nonzero_comm_semiring -> zero_ne_one_class;
nonzero_comm_ring -> comm_ring;
nonzero_comm_ring -> zero_ne_one_class;
nonzero_comm_ring -> nonzero_comm_semiring;
domain -> ring;
domain -> no_zero_divisors;
domain -> zero_ne_one_class;
"lattice.complete_distrib_lattice" -> "lattice.complete_lattice";
"lattice.complete_distrib_lattice" -> "lattice.bounded_distrib_lattice";
"lattice.complete_boolean_algebra" -> "lattice.boolean_algebra";
"lattice.complete_boolean_algebra" -> "lattice.complete_distrib_lattice";
nonneg_comm_group -> add_comm_group;
nonneg_comm_group -> ordered_comm_group;
nonneg_ring -> ring;
nonneg_ring -> zero_ne_one_class;
nonneg_ring -> nonneg_comm_group;
nonneg_ring -> ordered_ring;
linear_nonneg_ring -> domain;
linear_nonneg_ring -> nonneg_comm_group;
linear_nonneg_ring -> nonneg_ring;
linear_nonneg_ring -> linear_order;
linear_nonneg_ring -> linear_ordered_ring;
canonically_ordered_comm_semiring -> canonically_ordered_monoid;
canonically_ordered_comm_semiring -> comm_semiring;
canonically_ordered_comm_semiring -> zero_ne_one_class;
euclidean_domain -> nonzero_comm_ring;
euclidean_domain -> has_div;
euclidean_domain -> has_mod;
euclidean_domain -> integral_domain;
euclidean_domain -> principal_ideal_domain;
normalization_domain -> integral_domain;
gcd_domain -> normalization_domain;
infinite -> nonempty;
denumerable -> encodable;
denumerable -> primcodable;
"lattice.conditionally_complete_lattice" -> "lattice.lattice";
"lattice.conditionally_complete_lattice" -> "lattice.has_Sup";
"lattice.conditionally_complete_lattice" -> "lattice.has_Inf";
"lattice.conditionally_complete_linear_order" -> "lattice.conditionally_complete_lattice";
"lattice.conditionally_complete_linear_order" -> decidable_linear_order;
"lattice.conditionally_complete_linear_order_bot" -> "lattice.conditionally_complete_lattice";
"lattice.conditionally_complete_linear_order_bot" -> decidable_linear_order;
"lattice.conditionally_complete_linear_order_bot" -> "lattice.order_bot";
primcodable -> encodable;
uniform_space -> topological_space;
topological_space -> manifold;
topological_space -> has_groupoid;
topological_space -> measurable_space;
emetric_space -> has_edist;
emetric_space -> uniform_space;
emetric_space -> separated;
emetric_space -> "topological_space.first_countable_topology";
add_group_with_zero_nhd -> add_comm_group;
add_group_with_zero_nhd -> topological_space;
add_group_with_zero_nhd -> topological_add_monoid;
add_group_with_zero_nhd -> topological_add_group;
metric_space -> has_dist;
metric_space -> uniform_space;
metric_space -> has_edist;
metric_space -> separated;
metric_space -> emetric_space;
metric_space -> sequential_space;
premetric_space -> has_dist;
local_ring -> nonzero_comm_ring;
local_ring -> comm_ring;
normed_group -> has_norm;
normed_group -> add_comm_group;
normed_group -> metric_space;
normed_group -> uniform_add_group;
normed_group -> topological_add_monoid;
normed_group -> topological_add_group;
normed_ring -> has_norm;
normed_ring -> ring;
normed_ring -> metric_space;
normed_ring -> normed_group;
normed_ring -> topological_monoid;
normed_ring -> topological_ring;
normed_field -> has_norm;
normed_field -> discrete_field;
normed_field -> metric_space;
normed_field -> normed_ring;
normed_field -> normed_space;
nondiscrete_normed_field -> normed_field;
principal_ideal_domain -> integral_domain;
principal_ideal_domain -> "ideal.is_principal";
principal_ideal_domain -> is_noetherian_ring;
inner_product_space -> add_comm_group;
inner_product_space -> has_inner;
inner_product_space -> has_norm;
inner_product_space -> normed_group;
"measure_theory.measure_space" -> measurable_space;
}
